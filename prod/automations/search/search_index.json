{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"What is FlowRunner\u2122?","text":"<p>FlowRunner\u2122 is a visual workflow automation platform with native AI agent orchestration. Build workflows that run autonomously or incorporate human oversight at designated decision points.</p>"},{"location":"index.html#what-flowrunnertm-does","title":"What FlowRunner\u2122 Does","text":"<p>FlowRunner\u2122 orchestrates automated workflows that combine AI agents, human decision-making, and system integrations. Both technical and non-technical users can build workflows. Non-technical users work through the visual interface while technical users can leverage custom code and advanced integrations.</p> <ul> <li> <p> Automate with AI Agents</p> <p>AI agents handle complex decision-making within your workflows, making intelligent choices based on workflow context and coordinating with other agents.</p> <p> Configure AI agents</p> </li> <li> <p> Build Visually</p> <p>Create workflows through a drag-and-drop interface without writing code. Design multi-branched flows with parallel execution and reusable components.</p> <p> Working with blocks</p> </li> <li> <p> Add Human Oversight</p> <p>Insert human decision points at any workflow step. Contact people through email, Slack, WhatsApp, or phone with full context for informed decisions.</p> </li> <li> <p> Coordinate Multiple Agents</p> <p>Orchestrate teams of AI agents working together on complex tasks. Agents can invoke human oversight when needed and access tools through Model Context Protocol.</p> </li> <li> <p> Track Compliance</p> <p>Built-in audit trails, SLA monitoring, role-based access control, and compliance reporting ensure your workflows meet regulatory requirements.</p> <p> Compliance monitoring</p> </li> <li> <p> Bring Your Own Keys</p> <p>Use your own API keys for AI services. FlowRunner\u2122 supports multiple AI providers, giving you flexibility and control over your AI infrastructure.</p> <p> Configure API keys</p> </li> </ul>"},{"location":"index.html#core-platform-capabilities","title":"Core Platform Capabilities","text":"<ul> <li> <p> AI Agent Orchestration</p> <p>FlowRunner\u2122 treats AI agents as first-class workflow components. Agents make decisions based on workflow context, coordinate with other agents, invoke human oversight when needed, and access tools through Model Context Protocol (MCP).</p> <p> Giving agents tools</p> </li> <li> <p> Human-in-Loop Workflows</p> <p>Add human oversight anywhere in your workflow. AI agents can pause execution, contact humans through their preferred channel, and resume after receiving input. Humans receive full context for decision-making.</p> </li> <li> <p> Visual Workflow Building</p> <p>Design workflows through a visual interface with multi-branched flows, parallel execution, workflow groups for organization, branch synchronization, reusable SubFlows, and workflows as callable actions.</p> <p> Data flow in workflows</p> </li> <li> <p> Compliance and Governance</p> <p>Automatic audit trail logging, SLA tracking and monitoring, role-based access control (RBAC), single sign-on (SSO) support, and built-in compliance reporting.</p> <p> Compliance features</p> </li> <li> <p> Deployment Options</p> <p>Deploy FlowRunner\u2122 in the cloud or self-host on your infrastructure. Both deployment models provide full feature parity with no feature degradation.</p> </li> </ul>"},{"location":"index.html#who-uses-flowrunnertm","title":"Who Uses FlowRunner\u2122","text":"<p>FlowRunner\u2122 serves organizations that need automated workflows with AI decision-making, reliable human oversight of automated processes, compliance capabilities for regulated environments, multi-agent orchestration, and flexible workflow development approaches.</p> <p>Business users and citizen developers build workflows visually without coding knowledge. Technical users and developers leverage custom code, advanced integrations, and API access for complex workflows. Hybrid teams combine both approaches, with technical and non-technical users collaborating on automation projects within the same platform.</p>"},{"location":"index.html#development-approaches","title":"Development Approaches","text":"<p>FlowRunner\u2122 supports multiple development methods to fit your team's skills and requirements. Build entirely through the visual interface (no-code), combine visual building with custom code (low-code), or develop workflows programmatically when needed (code-first). Choose the approach that works best for your team.</p>"},{"location":"index.html#what-youll-learn","title":"What You'll Learn","text":"<p>This guide covers setting up your first workflow, configuring AI agents, adding human oversight points, managing workflow state and errors, building custom integrations, and monitoring and compliance reporting. Navigate through the chapters using the sidebar. Each section includes practical examples and code samples where applicable.</p>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<p>Start with the Installation Guide to set up FlowRunner\u2122, then proceed to Building Your First Workflow to create your first automation.</p> <p>For technical implementation details, see the Developer Reference. For visual workflow building, see Workflow Builder Guide.</p>"},{"location":"definitions.html","title":"Terminology","text":"<p>This chapter defines the key terms used throughout the FlowRunner\u2122 documentation.</p>"},{"location":"definitions.html#flow-concepts","title":"Flow Concepts","text":"<ul> <li> <p>Flow - A flow is an automated process that executes a series of actions based on defined logic. Flows can run autonomously or include human oversight at designated points.</p> </li> <li> <p>Flow Version - Each flow can have multiple versions. Only one version can be active at a time. To modify an active flow, clone the current version, make your changes, stop the old version, and start the new one. You cannot edit a running flow version.</p> </li> <li> <p>Flow Instance - A flow instance is a single execution of a flow version. When a flow version is in <code>LIVE</code> state, it can be instantiated. Each instance maintains its own execution context and data. Instances are created by schedules (see Scheduled Flows), events that activate triggers, or the Call Flow API.</p> </li> </ul>"},{"location":"definitions.html#flow-components","title":"Flow Components","text":"<ul> <li> <p>Block - Blocks are the building components of flows. Block types include triggers, actions, transformers, and conditions.</p> </li> <li> <p>Trigger - A trigger pauses flow execution until a specified event occurs. Examples include form submissions, API webhooks, or scheduled times. Triggers can be placed at any point in a flow.</p> </li> <li> <p>Action - An action performs a task within a flow. Actions can send emails, call APIs, generate reports, or execute custom code. Actions receive input data, process it, and pass results to subsequent blocks.</p> </li> <li> <p>Transformer - A transformer modifies data as it moves through a flow. Use transformers to extract values, convert formats, or manipulate data structures.</p> </li> <li> <p>Condition - A condition creates branching logic in a flow. The flow takes different paths based on whether the condition evaluates to true or false.</p> </li> <li> <p>Groups - Groups are container blocks that organize other blocks. FlowRunner\u2122 supports two group types: Trigger Group (contains multiple triggers) and Action Group (contains multiple actions).</p> </li> </ul>"},{"location":"definitions.html#flow-development","title":"Flow Development","text":"<ul> <li> <p>Flow Editor - The Flow Editor is the visual interface for building and editing flows. It provides a drag-and-drop workspace for designing automation logic.</p> </li> <li> <p>Test Mode - Test Mode runs flows with test data before deployment. Use it to validate flow logic and identify issues before activating a flow version.</p> </li> </ul>"},{"location":"definitions.html#compliance-and-monitoring","title":"Compliance and Monitoring","text":"<ul> <li> <p>SLA Condition - An SLA condition defines performance benchmarks for workflows. FlowRunner\u2122 monitors these conditions and tracks compliance.</p> </li> <li> <p>Non-compliance Rules - Non-compliance rules specify actions to take when a flow fails to meet SLA conditions. These rules automate response to performance issues.</p> </li> <li> <p>SLA Configurator - The SLA Configurator is a tool in the Flow Editor for defining SLA conditions and non-compliance rules. Use it to configure monitoring and compliance requirements for your flows.</p> </li> </ul>"},{"location":"flowmanager.html","title":"Flow Manager","text":"<p>Welcome to Flow Manager: Your Workflow Control Center.</p> <p>Flow Manager is the command center for your automation workflows. It helps you organize, oversee, and manage your workflows with precision and simplicity. In this chapter, you\u2019ll explore how Flow Manager empowers you to create, monitor, and refine your workflows, giving you full control over your automation processes.</p> <p></p>"},{"location":"flowmanager.html#flow-management","title":"Flow Management","text":"<p>Flow Manager is your central hub for managing workflows. It brings together all the tools you need to stay organized and keep your automation running smoothly. Let\u2019s take a closer look at what you can do here:  </p> <ul> <li>Create New Flows: Start building your automation workflows from scratch, tailoring each one to your specific needs and goals.  </li> <li>Manage Flow Versions: Make changes to your workflows without disrupting the live version. You can clone a live version, update it, and then seamlessly replace the old one by stopping it and launching your updated version.  </li> <li>Customize Flow Appearance: Make your workflows easier to navigate by personalizing their appearance to suit your style and preferences.  </li> <li>Assign Flow Execution Permissions: Control access to your workflows by managing who can execute them, keeping your automation secure and in the right hands.  </li> <li>Rename Flows: Keep your workspace organized by giving your workflows clear, meaningful names as your projects grow.  </li> <li>Delete Flows: Declutter your Flow Manager by removing workflows you no longer need, so you can focus on what matters most.  </li> </ul>"},{"location":"flowmanager.html#flow-version-management","title":"Flow Version Management","text":"<p>What is Version?</p> <p>In Flow Manager, a version represents a specific iteration of a workflow. Versions allow you to modify a workflow without affecting the one that is currently live. Only one version of a workflow can be live at any time. This means you can experiment, test, and refine your workflows in the background and seamlessly replace the active version when ready.  </p> <p>Flow Manager provides a comprehensive set of tools to manage the lifecycle of each Flow version. Here\u2019s what you can do:  </p> <ul> <li>Edit Flow Version: Adjust and refine your workflows to improve their performance or introduce new functionality without disrupting the live version.  </li> <li>Clone a Version: Create a duplicate of an existing version to build upon it, enabling rapid iteration and development.  </li> <li>Start/Stop Flow Version: Manage which version of a workflow is live by starting a new one or stopping the current active version. This ensures only your best, most polished iteration is in use.  </li> <li>Delete a Version: Remove outdated or unnecessary versions to keep your workflow environment organized and focused.  </li> <li>Navigate to the Version's Analytics: Explore detailed performance metrics for each version, giving you actionable insights to optimize your workflows.  </li> <li>Add a Description for the Flow Version: Provide clear documentation for each version\u2019s purpose and changes, helping you and your team stay aligned.  </li> </ul> <p>By mastering the tools and features of Flow Manager, you'll have everything you need to confidently create and manage your workflows. This foundation will help you streamline operations and unlock new levels of efficiency in your business processes.</p>"},{"location":"quickstart.html","title":"Quick Start Guide","text":"<p>FlowRunner\u2122 is a powerful tool for automating workflows, and getting started is a straightforward process. Whether you\u2019re new to Backendless or already have experience with its platform, this guide will help you set up your workspace and begin exploring FlowRunner\u2122.  </p>"},{"location":"quickstart.html#access-the-backendless-console","title":"Access the Backendless Console","text":"<p>To begin, navigate to the Backendless Console. This is your central hub for managing applications and accessing FlowRunner\u2122.  </p> <p>Backendless Console in Different Geographies</p> <p>Backendless is available in multiple hosting zones. To access FlowRunner\u2122 in a specific hosting zone, use the following URLs:  </p> <p>: https://develop.backendless.com/c/flow-runner : https://eu-develop.backendless.com/c/flow-runner </p>"},{"location":"quickstart.html#log-in-or-create-an-account","title":"Log In or Create an Account","text":"<p>You can log in using your Google or GitHub credentials for quick access. Alternatively, if you don\u2019t already have an account, create one using your email and password. Once your account is ready, log in to continue.  </p>"},{"location":"quickstart.html#set-up-your-workspace","title":"Set Up Your Workspace","text":"<p>If you\u2019re new to Backendless, you\u2019ll be greeted with a welcome screen as the system creates your workspace. This screen serves as your introduction to FlowRunner\u2122 and its features.  </p> <p> </p> <p>For users who already have applications in Backendless, the welcome screen offers two options. You can either create a new training/demo workspace specifically for FlowRunner\u2122 (this is the recommended option) or access FlowRunner\u2122 within the context of an existing application.  </p> <p> </p>"},{"location":"quickstart.html#explore-the-demo-workspace","title":"Explore the Demo Workspace","text":"<p>Once your workspace is ready and you\u2019ve selected the FlowRunner\u2122 training/demo workspace, you\u2019ll be presented with a collection of demo flows. These sample flows showcase various features and techniques available in FlowRunner\u2122, providing an excellent starting point for your exploration.  </p> <p>To learn more about these flows and how they work, refer to the Demo/Training Flows section of this guide, where you\u2019ll find detailed walkthroughs and explanations.  </p>"},{"location":"quickstart.html#create-your-first-flow","title":"Create Your First Flow","text":"<p>Now that your workspace is set up, let\u2019s build your first automation! </p>"},{"location":"quickstart.html#what-will-you-build","title":"What Will You Build?","text":"<p>In this tutorial, you\u2019ll create a flow that fetches news articles from an external API, analyzes their sentiment using AI, and logs the results in real-time. This simple yet powerful example will teach you how to:  </p> <ul> <li>Connect with external APIs to retrieve data dynamically.  </li> <li>Leverage AI tools for decision-making and sentiment analysis.  </li> <li>Log flow progress for monitoring and debugging.  </li> </ul>"},{"location":"quickstart.html#before-you-begin","title":"Before You Begin","text":"<p>Before diving into building your first flow, ensure you\u2019ve completed the following setup steps:  </p> <p>\u2705 Create a Backendless Developer Account Sign up for a free account at the Backendless Console. This account gives you access to FlowRunner\u2122 and all the tools needed to build, test, and run your flows.  </p> <p>\u2705 Obtain an API key from NewsAPI.org Register for an API key to fetch live news articles in your flow.  </p> <p>\u2705 Log in to the Backendless Console Once your account is ready, navigate to FlowRunner\u2122 to start building your flow.  </p> <p>By completing these steps, you\u2019ll have everything in place to start building and running your first FlowRunner\u2122 automation.  </p>"},{"location":"quickstart.html#follow-the-guided-tour-or-watch-the-video","title":"Follow the Guided Tour or Watch the Video","text":"<p>To help you get started, we provide two ways to learn:  </p> Guided TourVideo Tutorial <p>Step-by-step interactive walkthrough. </p> <p>Watch an in-depth explanation with a real-time demo. </p> <p>The following \"static\" values are used in the flow:</p> <ul> <li>URL in the HTTP Request block:   <pre><code>https://newsapi.org/v2/everything\n</code></pre></li> <li>Query in the HTTP Request block:     <pre><code>q=\"Quantum Computing\"&amp;apiKey=YOUR-API-KEY\n</code></pre></li> <li>AI Router Prompt:     <pre><code>You are provided a collection of JSON objects. These objects represent news \narticles. You will need to find the following three properties in each \nobject: title, description, and content. You will need to analyze the \nsentiment in these articles for Quantum Computing\n</code></pre></li> </ul>"},{"location":"quickstart.html#next-steps","title":"Next Steps","text":"<p>With these simple steps, you\u2019re ready to explore FlowRunner\u2122 and start automating your workflows. </p>"},{"location":"extensibility/action-development.html","title":"Lifecycle of Action Development","text":"<p>Developing a FlowRunner\u2122 action follows a structured lifecycle, which involves creating the API service, defining operations, adding the logic, and configuring the operation for FlowRunner\u2122. Below is an overview of each stage in the lifecycle:</p>"},{"location":"extensibility/action-development.html#1-create-the-api-service","title":"1. Create the API Service","text":"<p>The first step in developing a custom action is to create an API service within Backendless. This service acts as a container for one or more operations. Each operation can later be transformed into an action that is usable in FlowRunner\u2122. To create a new API service, navigate to the <code>API Services</code> screen and click the  icon:</p> <p>Where to find the API Services screen</p> <p>If you do not see the \"API Services\" icon in the sidebar on the left, click the <code>QUICK ACCESS</code> button in the upper left corner of the management console and search for \"API Services\":</p> <p></p> <p>Click the \"API Services\" item to access the screen. You can also click the  icon to create a shortcut in the sidebar.</p> <p></p> <p>A popup window opens and defaults to <code>CODELESS</code>. Assign a name for your service in the Service Name: field and click <code>SAVE</code>.</p> <p>Note</p> <p>If you plan to develop an action for a service that requires OAuth2 authentication, make sure to select the With OAuth2 Authorization template. There are several additional requirements for implementing an action for an service with OAuth2 authorization. Make sure to read the details in the OAuth2 Authorization chapter of this guide. </p>"},{"location":"extensibility/action-development.html#2-define-operations","title":"2. Define Operations","text":"<p>Once the API service is created, you can define specific operations within it. These operations represent the individual tasks or logic that will be turned into actions. An API service can have multiple operations, each serving a different purpose, such as interacting with a database, processing user input, or connecting to external services. When you create a new service, the system will automatically prompt you to create an operation by displaying the popup shown below, this is where you will be declaring an operation in your service. An operation must have a name and a description. Depending on what the operation does, you may also need to declare operation parameters.</p> <p>To add an operation (also known as \"method\"), click the   icon for your service as shown below:</p> <p></p>"},{"location":"extensibility/action-development.html#3-operation-setup","title":"3. Operation Setup","text":"<p>Configuring a operation has a direct impact on the presentation of the corresponding action in FlowRunner\u2122\u2122. The following configuration properties are of particular importance:</p> <p>Name: Identifies the action in FlowRunner\u2122\u2122. It is recommended to assign a name (or a short phrase) that clearly describes what the action does, providing insights about input and output values and overall functionality. The description will appear as a tooltip for the action block in the FlowRunner\u2122\u2122's Blocks Toolbox and when hovering the mouse of the block in a flow.</p> <p>Description: A description should clearly explain what the action/operation does and how to effectively use it in FlowRunner\u2122\u2122 workflows.</p> <p>Action Icon: Assign an icon that represents the action, making it easier to identify in the FlowRunner\u2122 Flow Editor. The icon will appear in a block representing the action in Flow Editor.</p> <p></p> <p>Block\u2019s Colors: Apply a custom color to the block\u2019s border to help distinguish it from other actions. The border can consist of two colors which, if they are different, will gradient from one to the other. By default, the colors are \"linked\", which means if you change onethe one on the left, the other will automatically change to the same color. However, you can click the  icon to unlink the colors, or simply pick another color with the color picker on the right which will remove the linking:</p> <p></p>"},{"location":"extensibility/action-development.html#4-define-service-configuration-parameters","title":"4. Define Service Configuration Parameters","text":"<p>In some cases, the operations of your service (i.e., FlowRunner\u2122 Actions) may require configuration information provided in advance. For example, consider a service designed to send and receive emails. To connect to an email server, the service needs details such as the server\u2019s address, port, username, and password. This information can be collected through service configuration parameters.</p> <p>Configuration parameters can be set up in the Service Configuration popup. To access this popup, select your service on the API Services screen and click the settings icon:</p> <p></p> <p>These parameters ensure that necessary configuration data is available for your operations without requiring it to be hard-coded or manually entered each time the action is used. For more information on setting up configuration parameters, see the Service Config Parameters section of this guide.</p>"},{"location":"extensibility/action-development.html#5-develop-action-logic","title":"5. Develop Action Logic","text":"<p>This is the stage where the actual logic of the action is implemented. If you\u2019re using Codeless, you will visually create the logic by dragging and dropping blocks in the logic editor. Codeless allows you to build logic without writing any code, making it accessible even for developers with minimal programming experience. You can also incorporate custom JavaScript code into Codeless if your action requires more advanced functionality.</p> <p>In this step, you define how the action will process data, interact with other services, or perform specific calculations. The logic implemented here determines the action's behavior when it is used within a flow.</p>"},{"location":"extensibility/action-development.html#6-deploy-and-test-iterations","title":"6. Deploy and Test Iterations","text":"<p>Once the logic has been added, the action needs to be thoroughly tested to ensure it behaves as expected. Backendless provides a testing environment where you can verify the action\u2019s functionality. This stage is crucial to catch any errors or unexpected behavior before the action is used in FlowRunner\u2122 or published to the Marketplace. The deployment process differs between services created with Codeless and Nodejs. For Codeless services, you should use the DEPLOY MODEL button located in the Codeless Logic Editor interface:</p> <p></p> <p>For more information about FlowRunner\u2122 Custom Action testing, see the Action Testing section of this guide.</p>"},{"location":"extensibility/action-testing.html","title":"Custom Action Testing","text":"<p>Testing your custom FlowRunner\u2122 actions is a crucial step in the development process. It ensures that your action behaves as expected and helps identify potential issues before it is used in a live environment. Whether your action interacts with external services, processes data, or works within an OAuth2 workflow, proper testing allows you to validate functionality, handle errors gracefully, and ensure smooth integration with other services.</p> <p>If your action interacts with an external service provider requiring OAuth2 authorization, you will need to create an OAuth connection by executing the OAuth workflow. You can initiate this workflow from either the API Services screen in the Backendless Console or directly from the Flow Editor interface.</p>"},{"location":"extensibility/action-testing.html#actions-with-oauth2-authorization","title":"Actions with OAuth2 Authorization","text":"<p>Before testing, make sure that your service is deployed. Once deployed, it will be listed on the API Services screen in the Backendless Console. Here\u2019s how to start testing OAuth2-enabled actions:</p> <ol> <li>On the API Services screen, find your deployed service and expand it to show a list of available operations. </li> <li>Select the operation you marked as a FlowRunner\u2122 action.</li> <li> <p>Under the LOGIN tab, locate the OAUTH2 INTEGRATION LOGIN section and click the LOGIN WITH OAUTH2 button. This triggers the OAuth2 workflow, allowing you to authorize your account with the external service provider.</p> <p> 4. Once authorization is successful, the connected account will appear in a drop-down list of available OAuth2 connections.</p> </li> </ol>"},{"location":"extensibility/action-testing.html#running-test-invocations","title":"Running Test Invocations","text":"<p>Before running a test, make sure you've provided the necessary data for your action. If your action requires OAuth2 authorization, ensure the OAuth2 connection is established first. Here\u2019s how to run a test:</p> <ol> <li>Select the PARAMETERS tab. You will see a dynamically generated form displaying the parameters required by the selected action or operation.</li> <li>Enter the appropriate test data into the parameter fields.</li> <li>Click the INVOKE button in the upper-right corner to trigger the operation. The system will execute the action with the test data, and the result will be displayed on the screen.</li> </ol> <p>Testing from the API Services screen is recommended because it offers a straightforward way to validate your action. However, if you prefer testing within a visual flow, you can also perform testing directly in the Flow Editor.</p>"},{"location":"extensibility/action-testing.html#testing-from-the-flow-editor","title":"Testing from the Flow Editor","text":"<p>The Flow Editor interface allows you to test your actions within the context of a flow. You can test your action\u2019s behavior in real-time and ensure its integration within a larger flow.</p> <p>For more detailed information on testing within flows, refer to the Testing your Flows section of this guide.</p> <p>Note</p> <p>If your action requires OAuth2 authorization, you\u2019ll see the LOGIN button in the properties sheet for your action in the Flow Editor. Refer to Step 5 in the Step-by-Step Explanation of the OAuth2 Authorization workflow for detailed steps on the login process.</p>"},{"location":"extensibility/action-testing.html#conclusion","title":"Conclusion","text":"<p>Testing ensures that your FlowRunner\u2122 actions work as intended and helps catch potential issues early in the development process. By testing actions through the API Services screen or the Flow Editor, you can simulate real-world scenarios and validate that OAuth2 workflows, external service integrations, and other complex functionality operate seamlessly. </p> <p>Always ensure that the OAuth2 connection is properly established before testing any action that relies on external service providers. This ensures that your service will perform correctly when it is put into production.</p>"},{"location":"extensibility/action-with-args-js.html","title":"Developing an Action with Arguments","text":"<p>This guide builds on the Basic Action Guide and extends the Get Top Headlines operation by adding input parameters. You will learn how to define and use arguments, making your FlowRunner\u2122 actions more flexible and adaptable to dynamic input.</p>"},{"location":"extensibility/action-with-args-js.html#what-are-action-arguments","title":"What Are Action Arguments?","text":"<p>Action arguments allow you to pass external data into your action when it is executed. Flow designers can supply argument values using static inputs, outputs from other actions, transformation operations, trigger events, or variables.</p> <p>When you define arguments, you also control how they appear in FlowRunner\u2122. You decide the data type, whether they are required, and how users interact with them\u2014such as text fields, dropdowns, or checkboxes.</p> <p>In this guide, you will define two arguments, integrate them into your action\u2019s logic, and test the result in FlowRunner\u2122.</p>"},{"location":"extensibility/action-with-args-js.html#what-this-guide-covers","title":"What This Guide Covers","text":"<p>In this guide, you will create a new Search News Headlines action with two parameters: category and q (query). Both are supported by the NewsAPI.org Top Headlines API: </p> <p>Once implemented, the category argument will appear in FlowRunner\u2122 as a dropdown list with predefined values, while q will be a free-form text input field. Both parameters will also accept dynamic values through the Expression Editor.</p> <p>Note</p> <p>In FlowRunner\u2122, any parameter can accept values via the Expression Editor. This makes connecting and transforming data between actions seamless.</p>"},{"location":"extensibility/action-with-args-js.html#implementing-the-operation","title":"Implementing the Operation","text":"<p>Arguments in your Node.js action function behave like typical JavaScript function parameters. However, to make them available as configurable inputs in FlowRunner\u2122, you must define them using special <code>@paramDef</code> JSDoc tags.</p> <p>Here is the complete action function, followed by a detailed breakdown of the argument declarations:</p> <pre><code>/**\n * @description Retrieves top news headlines for a category and/or a search query\n *\n * @route GET /getNewsWithCategoryOrQuery\n * @operationName Search News Headlines\n * @appearanceColor #FE1212 #191970\n * @executionTimeoutInSeconds 120\n * @paramDef {\"type\":\"String\",\"label\":\"Search Query\",\"name\":\"query\",\"required\":false,\"description\":\"Keywords or a phrase to search for.\"}\n * @paramDef {\"type\":\"String\",\"label\":\"News Category\",\"name\":\"category\",\"required\":false, \"uiComponent\": {\"type\":\"DROPDOWN\", \"options\":{ \"values\":[\"business\", \"entertainment\", \"general\", \"health\", \"science\", \"sports\", \"technology\"] }}, \"description\":\"The category you want to get the headlines for.\"}\n * @returns {Object} Returns news headlines from the specified category and/or a search query.\n * @sampleResult {\"status\":\"ok\",\"totalResults\":1,\"articles\":[{\"source\":{\"id\":\"the-hill\",\"name\":\"The Hill\"},\"author\":\"Tara Suter\",\"title\":\"West Virginia governor says he\u2019ll take legal action against NCAA over tournament snub - The Hill\",\"description\":\"West Virginia Gov. Patrick Morrisey (R) on Monday said he will take legal action against the NCAA over West Virginia University\u2019s (WVU) snub from the March Madness tournament. \u201cI\u2019ve asked Attorney General [JB McCuskey] to launch an investigation into the NCAA\u2026\",\"url\":\"https://thehill.com/homenews/state-watch/5199135-west-virginia-governor-says-hell-take-legal-action-against-ncaa-over-tournament-snub/\",\"urlToImage\":\"https://thehill.com/wp-content/uploads/sites/2/2024/11/AP24131791907837-e1730586407708.jpg?w=1280\",\"publishedAt\":\"2025-03-17T19:51:12Z\",\"content\":\"Skip to content...\"}]}\n */\nasync getNewsWithCategoryOrQuery(query, category) {\n  try {\n    let requestQuery = {\n      country: 'us',\n      apiKey: this.apiKey\n    }\n\n    if (category) {\n      requestQuery.category = category;\n    }\n\n    if (query) {\n      requestQuery.q = query;\n    }\n\n    return await Backendless.Request['get']('https://newsapi.org/v2/top-headlines')\n      .set({\n        'User-Agent': 'FlowRunner\u2122'\n      })\n      .query(requestQuery)\n  } catch (error) {\n    logger.error(`NewsAPI - error: ${error.message}`)\n    throw error\n  }\n}\n</code></pre>"},{"location":"extensibility/action-with-args-js.html#defining-parameters-with-paramdef","title":"Defining Parameters with <code>@paramDef</code>","text":"<p>As shown in the code, function arguments behave like typical parameters in JavaScript. To make them visible in FlowRunner\u2122 as input fields, define them using the <code>@paramDef</code> tag:</p> <pre><code>* @paramDef {\"type\":\"String\",\"label\":\"Search Query\",\"name\":\"query\",\"required\":false,\"description\":\"Keywords or a phrase to search for.\"}\n* @paramDef {\"type\":\"String\",\"label\":\"News Category\",\"name\":\"category\",\"required\":false, \"uiComponent\": {\"type\":\"DROPDOWN\", \"options\":{ \"values\":[\"business\", \"entertainment\", \"general\", \"health\", \"science\", \"sports\", \"technology\"] }}, \"description\":\"The category you want to get the headlines for.\"}\n</code></pre> <p>Once declared, FlowRunner\u2122 automatically renders these arguments as form fields: </p>"},{"location":"extensibility/action-with-args-js.html#search-query-parameter","title":"Search Query Parameter","text":"<p>The Search Query is rendered as a standard text input field. Its configuration is:</p> <pre><code>@paramDef { \n    \"type\":\"String\",\n    \"label\":\"Search Query\",\n    \"name\":\"query\",\n    \"required\":false,\n    \"description\":\"Keywords or a phrase to search for.\"\n}\n</code></pre> Property Value Description <code>type</code> <code>\"String\"</code> The parameter\u2019s data type <code>label</code> <code>\"Search Query\"</code> The label displayed in FlowRunner\u2122 <code>name</code> <code>query</code> The argument\u2019s name in the function signature <code>required</code> <code>false</code> Whether the parameter is mandatory <code>description</code> <code>\"Keywords or a phrase to search for.\"</code> Tooltip shown in FlowRunner\u2122"},{"location":"extensibility/action-with-args-js.html#news-category-parameter","title":"News Category Parameter","text":"<p>The News Category argument is rendered as a dropdown list with predefined values:</p> <pre><code>@paramDef {\n  \"type\":\"String\",\n  \"label\":\"News Category\",\n  \"name\":\"category\",\n  \"required\":false, \n  \"uiComponent\": {\n    \"type\":\"DROPDOWN\", \n    \"options\":{ \n      \"values\":[\"business\", \"entertainment\", \"general\", \"health\", \"science\", \"sports\", \"technology\"] \n    }\n  }, \n  \"description\":\"The category you want to get the headlines for.\"\n}\n</code></pre> Property Value Description <code>type</code> <code>\"String\"</code> The parameter\u2019s data type <code>label</code> <code>\"News Category\"</code> The label displayed in FlowRunner\u2122 <code>name</code> <code>category</code> The argument\u2019s name in the function signature <code>required</code> <code>false</code> Whether the parameter is mandatory <code>uiComponent</code> <code>{ \"type\": \"DROPDOWN\", ... }</code> Defines the dropdown behavior <code>description</code> <code>\"The category you want to get the headlines for.\"</code> Tooltip shown in FlowRunner\u2122"},{"location":"extensibility/action-with-args-js.html#rendering-ui-components","title":"Rendering UI Components","text":"<p>The News Category parameter is shown as a dropdown in FlowRunner\u2122 due to the <code>uiComponent</code> property. This property specifies the component <code>\"type\"</code>, which in this case is <code>\"DROPDOWN\"</code>, along with a list of valid <code>\"options\"</code>.  </p> <p>FlowRunner\u2122 supports various input types for rendering arguments. To explore more UI component options, refer to the Parameter Rendering documentation.</p>"},{"location":"extensibility/action-with-dictionary-js.html","title":"Developing an Action with Dictionary Arguments","text":"<p>In this guide, you will enhance the action you created in the Build Basic Action Guide and expanded in the Build Action with Arguments Guide. You will implement a dictionary argument, which allows your FlowRunner\u2122 action to fetch external data and present it to the user as a dynamic list of selectable options.</p> <p>For example, let\u2019s say your Search News Headlines action should allow users to choose a specific news source. Instead of asking users to type the source manually, you will implement a dictionary function that dynamically fetches available sources from an external API and presents them as a selectable dropdown in FlowRunner\u2122: </p> <p>This approach is ideal when your action needs to present up-to-date choices - such as API resources, dynamic datasets, or filtered lists. It also applies when available options depend on prior selections, like choosing a specific sheet from a selected Google Sheets document.</p>"},{"location":"extensibility/action-with-dictionary-js.html#scenario-example-newsapiorg","title":"Scenario Example: NewsAPI.org","text":"<p>In this guide, you will enhance the Search News Headlines action you created in the previous chapter by adding a dictionary parameter. Specifically, you will integrate it with NewsAPI.org to allow users to select a news source from a dynamically populated list. The Top Headlines endpoint accepts a <code>sources</code> parameter, but obtaining valid source values requires calling a separate API: </p> <p>Below is the documentation for the corresponding Sources endpoint, which you will use to dynamically populate the dictionary list: </p>"},{"location":"extensibility/action-with-dictionary-js.html#implementation-overview","title":"Implementation Overview","text":"<p>Enabling dictionary functionality requires two main tasks:</p> <ol> <li>Build a dictionary function - A function that retrieves and formats dynamic options.</li> <li>Link the dictionary to a parameter - Connects the input field to your dictionary logic for dynamic selection.</li> </ol>"},{"location":"extensibility/action-with-dictionary-js.html#build-dictionary-function","title":"Build Dictionary Function","text":"<p>A dictionary function fetches external data and prepares it for FlowRunner\u2019s dropdown UI. It powers an input that supports search, pagination, and clearing selections: </p>"},{"location":"extensibility/action-with-dictionary-js.html#what-this-function-does","title":"What This Function Does","text":"<p>Here is a full implementation of a dictionary function that retrieves available news sources from NewsAPI.org. </p> <ul> <li>Fetches source options from NewsAPI.org.</li> <li>Filters items based on user search input.</li> <li>Returns results in the required FlowRunner\u2122 dictionary format.</li> </ul> <pre><code>//------------ DICTIONARIES -------------------\n\n/**\n * @typedef {Object} DictionaryPayload\n * @property {String} [search]\n * @property {String} [cursor]\n * @property {Object} [criteria]\n */\n\n/**\n * @typedef {Object} DictionaryItem\n * @property {String} label\n * @property {any} value\n * @property {String} note\n */\n\n/**\n * @typedef {Object} DictionaryResponse\n * @property {Array&lt;DictionaryItem&gt;} items\n * @property {String} cursor\n * @property {Object} criteria\n */\n\n/**\n * @registerAs DICTIONARY\n * @route POST /getSourcesDictionary\n * @param {DictionaryPayload} payload\n * @returns {DictionaryResponse}\n */\n\nasync getSourcesDictionary({ search, cursor, criteria }) {\n  const sourcesResponse = await Backendless.Request.get('https://newsapi.org/v2/top-headlines/sources')\n    .set({\n      'User-Agent': 'FlowRunner\u2122'\n    })\n    .query({\n      apiKey: this.apiKey\n    })\n\n  let filteredItems = sourcesResponse.sources\n\n  if (search) {\n    search = search.toLowerCase()\n\n    filteredItems = sourcesResponse.sources.filter((i) =&gt; {\n      return i.name?.toLowerCase().includes(search) || i.id?.toLowerCase() === search\n    })\n  }\n\n  return {\n    cursor: cursor,\n    items: filteredItems.map((item) =&gt; {\n      return {\n        label: item.name,\n        value: item.id,\n        note: `${item.category}, ${item.language}`,\n      }\n    })\n  }\n}\n</code></pre>"},{"location":"extensibility/action-with-dictionary-js.html#about-the-dictionary-typedefs","title":"About the Dictionary Typedefs","text":"<p>The first three <code>@typedef</code> blocks define shared types and should only be declared once per service file:</p> <pre><code>/**\n * @typedef {Object} DictionaryPayload\n * @property {String} [search]\n * @property {String} [cursor]\n * @property {Object} [criteria]\n */\n\n/**\n * @typedef {Object} DictionaryItem\n * @property {String} label\n * @property {any} value\n * @property {String} note\n */\n\n/**\n * @typedef {Object} DictionaryResponse\n * @property {Array&lt;DictionaryItem&gt;} items\n * @property {String} cursor\n * @property {Object} criteria\n */\n</code></pre> <p>The dictionary function is registered using the <code>@registerAs DICTIONARY</code> tag and a matching <code>@route</code> declaration:</p> <pre><code>/**\n * @registerAs DICTIONARY\n * @route POST /getSourcesDictionary\n * @param {DictionaryPayload} payload\n * @returns {DictionaryResponse}\n */\n\nasync getSourcesDictionary({ search, cursor, criteria }) {\n</code></pre>"},{"location":"extensibility/action-with-dictionary-js.html#return-format","title":"Return Format","text":"<p>A valid dictionary response must include: - items: An array of selectable options. - cursor: Used for pagination (optional depending on your use case). - label, value, note: Fields used by FlowRunner\u2019s UI.</p> <pre><code>  return {\n    cursor: cursor,\n    items: filteredItems.map((item) =&gt; {\n      return {\n        label: item.name,\n        value: item.id,\n        note: `${item.category}, ${item.language}`,\n      }\n    })\n  }\n</code></pre>"},{"location":"extensibility/action-with-dictionary-js.html#link-dictionary-to-parameter","title":"Link Dictionary to Parameter","text":"<p>With the dictionary function ready, you can now link it to a parameter inside your action using the <code>dictionary</code> property in the <code>@paramDef</code>.</p> <p>Below is an updated version of your <code>getNewsWithCategoryOrQuery</code> action, now with an additional source parameter tied to your dictionary function:</p> <pre><code>/**\n * @description Retrieves top news headlines for a category and/or a search query\n *\n * @route GET /getNewsWithCategoryOrQuery\n * @operationName Search News Headlines\n * @appearanceColor #FE1212 #191970\n * @executionTimeoutInSeconds 120\n * @paramDef {\"type\":\"String\",\"label\":\"News Category\",\"name\":\"category\",\"required\":false, \"uiComponent\": {\"type\":\"DROPDOWN\", \"options\":{ \"values\":[\"business\", \"entertainment\", \"general\", \"health\", \"science\", \"sports\", \"technology\"] }}, \"description\":\"The category you want to get headlines for.\"}\n * @paramDef {\"type\":\"String\",\"label\":\"Search Query\",\"name\":\"query\",\"required\":false,\"description\":\"Keywords or a phrase to search for.\"}\n * @paramDef {\"type\":\"String\",\"label\":\"Source\",\"name\":\"source\",\"required\":false,\"dictionary\":\"getSourcesDictionary\", \"description\":\"News source to get headlines from.\"}\n * @returns {Object} Returns news headlines from the specified category and/or a search query.\n */\nasync getNewsWithCategoryOrQuery(category, query, source) {\n</code></pre> <p>The <code>\"dictionary\": \"getSourcesDictionary\"</code> property binds the Source input to the dictionary logic, enabling dynamic dropdown values in FlowRunner\u2122. <pre><code>* @paramDef {\n  \"type\":\"String\",\n  \"label\":\"Source\",\n  \"name\":\"source\",\n  \"required\":false,\n  \"dictionary\":\"getSourcesDictionary\",\n  \"description\":\"News source to get headlines from.\"\n}\n</code></pre></p>"},{"location":"extensibility/action-with-dictionary-js.html#best-practices","title":"Best Practices","text":"<p>To ensure a smooth user experience and efficient integration, follow these best practices:</p> <p>Optimize API Requests - Limit returned records (e.g., up to 100 items) to improve UI performance. - Use external API pagination if supported.</p> <p>Implement Effective Search - Filter results based on the <code>search</code> input passed by FlowRunner\u2122. - Support partial and case-insensitive matches.</p> <p>Handle Errors Gracefully - Log and catch API errors inside dictionary functions. - Return empty lists or helpful notes if data retrieval fails.</p> <p>Minimize Unnecessary Calls - Cache static data or slow-changing datasets (e.g., static category lists) to avoid redundant API requests.</p> <p>Standardize the Output - Always provide label, value, and note fields for consistency. - Keep dropdown labels short and clear.</p> <pre><code>{\n  \"label\": \"The Verge\",\n  \"value\": \"the-verge\",\n  \"note\": \"technology, en\"\n}\n</code></pre> <p>By following this approach, you will provide FlowRunner\u2122 users with responsive and user-friendly dictionary inputs connected to real-time external data.</p>"},{"location":"extensibility/actions-quick-start.html","title":"Custom Action Development Guide","text":"<p>In this guide, you will learn how to build a Codeless FlowRunner\u2122 action that integrates with NewsAPI. If you previously worked on creating your first flow, you may recognize this service.  </p> <p>Action Development Guides</p> <p>The action development guide is divided into three parts to keep instructions organized and easy to follow:  </p> <ul> <li> <p>Build Basic Action Guide (the current chapter) \u2013 Covers the fundamentals of developing an action. This chapter walks you through creating an action without arguments, using only one configuration item: an API Key.  </p> </li> <li> <p>Build Action with Arguments Guide \u2013 Builds on the basic action by introducing arguments. This guide explains how to declare action parameters, use them in implementation logic, and configure them in FlowRunner\u2122.  </p> </li> <li> <p>Build Dictionary Operation \u2013 Explores a special type of argument called a dictionary. This argument allows your action to dynamically generate a list of possible parameter values. For example, you can use it to let users choose from a list of Slack channels, Airtable bases, or other external data sources.  </p> </li> </ul> <p>Once you have implemented and tested your first action, we recommend progressing through the guides in order to expand your understanding and capabilities.  </p> <p>By the end of these guides, you will have a fully functional Codeless action with a configurable API key and action parameters for retrieving related news articles. Once completed, you\u2019ll be able to use this action in a variety of automations, such as:</p> <ul> <li>Retrieving news articles based on a search query and analyzing them with AI for content generation.</li> <li>Storing fetched news data in Airtable or Google Sheets for tracking and further processing.</li> <li>Summarizing articles with AI and automatically sending reports via email.</li> </ul> <p>These are just a few possibilities - your custom action can be adapted to fit many different automation scenarios.    </p>"},{"location":"extensibility/actions-quick-start.html#create-a-new-service","title":"Create a New Service","text":"<p>To get started, navigate to the API Services section of the Backendless Console. If you do not have the API Services section bookmarked, click the QUICK ACCESS button:  </p> <p>Search for API Services and click the  icon to bookmark the screen.   </p> <p>Now you have a shortcut for the API Services screen in the vertical icon bar on the left. Click the API Services icon to naviate to the screen. Click the  icon to create a new API Service.  </p> <p>The \"Build From Scratch\" template is selected by default. Unless your FlowRunner\u2122 extension requires OAuth2 authentication, keep this selection. If OAuth2 is needed, select \"With OAuth2 Authorization\" instead. For more details, refer to the OAuth2 Authorization chapter.  </p> <p>In the Service Class Name field, enter <code>NewsAPI</code>. You will notice that the value automatically appears in the FlowRunner\u2122 Extension Name field as well. While the first field is mainly technical, the FlowRunner\u2122 Extension Name is critical - this is how your extension will appear in the FlowRunner\u2122 Marketplace and the list of custom FlowRunner\u2122 extensions.  </p> <p>The service icon is optional but required if you plan to submit your extension to the Marketplace. </p> <p>The screenshot below is what the New Service popup should look like (do not click the SAVE button yet):  </p>"},{"location":"extensibility/actions-quick-start.html#set-up-configuration-parameters","title":"Set Up Configuration Parameters","text":"<p>Next, while you are still in the New Service popup, configure the Service Configuration Parameters. Before proceeding, it\u2019s important to understand their purpose:  </p> <p>What Are Service Configuration Parameters?</p> <p>FlowRunner\u2122 actions can have action-specific parameters that apply only to individual instances of the action. These can be static or dynamic values defined within a flow. However, some extensions require a global configuration parameter that applies to all operations in the service. A common example is an API key required by the service APIs.  </p> <p>When you define Service Configuration Parameters, FlowRunner\u2122 users will see a Configure button when they install your extension. Clicking it opens a form where they can enter values required for the service to function. Backendless/FlowRunner\u2122 makes the configuration item values entered by the users available to your service implementation (as you will see shortly). </p> <p>Since NewsAPI requires an API key, let\u2019s add a configuration parameter for it:  </p> <ol> <li>Click the ADD NEW button.  </li> <li>Enter the details as shown below: </li> <li>Click SAVE to finalize the service creation.  </li> </ol> <p>Once saved, a Create Operation popup will appear. Since an API service is meaningless without operations, FlowRunner\u2122 encourages you to define an operation immediately.  </p>"},{"location":"extensibility/actions-quick-start.html#add-an-operation","title":"Add an Operation","text":"<p>Each Codeless API Service Operation becomes a FlowRunner\u2122 action. If you are not familiar with \"API operations\", see the information box below:</p> <p>API Service Operation Elements</p> <p>When adding an operation, you will define:  </p> <ol> <li>Name - The action name displayed in FlowRunner\u2122. Choose something concise and meaningful.  </li> <li>Description - A tooltip description that appears when users hover over the action in FlowRunner\u2122.  </li> <li>HTTP Endpoint - The HTTP method the operation will use:  <ul> <li>GET - Fetch data without modifying the system.  </li> <li>POST - Create new data in the external system.  </li> <li>PUT/PATCH - Update existing data.  </li> <li>DELETE - Remove data.  </li> </ul> </li> <li>Operation Parameters - Define input parameters users will configure when adding this action to a flow.  </li> <li>Operation Response - (Optional) Define the expected response format.  </li> </ol> <p>Additionally, you\u2019ll see the \"Register in FlowRunner\u2122 as...\" section. This is where you specify:  </p> <ul> <li>Whether the operation functions as an Action, Trigger, or Dictionary.  </li> <li>The action\u2019s icon and block colors in the FlowRunner\u2122 editor.  </li> </ul> <p>For this guide, you will implement the Get Top Headlines operation. As you progress, you will learn how to add more complex operations.  </p> <p>Follow the steps below:  </p> <ol> <li> <p>Configure the operation as shown in the screenshot: </p> </li> <li> <p>Click SAVE.  </p> </li> </ol>"},{"location":"extensibility/actions-quick-start.html#add-an-implementation","title":"Add an Implementation","text":"<p>Once the operation is created, a Codeless placeholder appears. Click EDIT to enter the Codeless editor and begin building the logic. </p> <p>If you're familiar with Codeless, use the screenshot below as a reference for your implementation: </p> <p>If you are not familiar with Codeless, the interactive guide below provides step-by-step implementation instructions:</p>"},{"location":"extensibility/actions-quick-start.html#using-the-action-in-flowrunnertm","title":"Using the Action in FlowRunner\u2122","text":"<p>Note</p> <p>This guide assumes you have a basic understanding of FlowRunner\u2122, including how to create a flow, use automation blocks, and manage flow data. If you are new to FlowRunner\u2122, we recommend starting with Creating Your First Flow.  </p> <p>Now that your custom action is ready, it\u2019s time to test it in FlowRunner\u2122.  </p> <ol> <li>Navigate to FlowRunner\u2122 and create a new flow. Name it News Summary Flow. </li> <li>Open the Flow Editor and scroll down to the Custom Actions section in the block toolbox. You will see your Get Top Headlines action. </li> <li>Drag the action into the flow.  </li> <li>Enable Test Mode and click the  icon to run the action.  </li> <li>Once executed, FlowRunner\u2122 will display the action result in the Block Result Inspector panel. </li> </ol> <p>For a complete demo of using the action in a real flow, follow the interactive walkthrough:  </p>"},{"location":"extensibility/actions-quick-start.html#final-thoughts","title":"Final Thoughts","text":"<p>You\u2019ve successfully built and tested your first Codeless FlowRunner\u2122 extension. This guide covered:  </p> <ul> <li>Creating a FlowRunner\u2122 extension from scratch.  </li> <li>Defining Service Configuration Parameters.  </li> <li>Adding operations that become FlowRunner\u2122 actions.  </li> <li>Implementing a Codeless logic for API integration.  </li> <li>Using the action in a FlowRunner\u2122 automation.  </li> </ul> <p>With this knowledge, you can create more powerful custom actions that integrate FlowRunner\u2122 with external services, expanding its capabilities. Happy automating! \ud83d\ude80  </p>"},{"location":"extensibility/actions-with-args.html","title":"Developing an Action with Arguments","text":"<p>This guide continues from the Basic Action Guide, enhancing the Get Top Headlines operation by adding parameters. You will learn how to define and use action arguments, making your FlowRunner\u2122 extensions more flexible and configurable.</p>"},{"location":"extensibility/actions-with-args.html#understanding-action-arguments","title":"Understanding Action Arguments","text":"<p>Action arguments let you pass input data into an operation. When an action has arguments, flow designers can provide input from various sources, including static values, results from other actions, transformation operations, trigger events, or variables.  </p> <p>When defining arguments for an operation, you control how they appear in FlowRunner\u2122, including their type, default values, and UI visualization (such as dropdowns, checkboxes, or text fields). This guide will walk you through defining arguments, updating your operation's logic, and testing the action in FlowRunner\u2122.</p>"},{"location":"extensibility/actions-with-args.html#opening-the-operation-for-editing","title":"Opening the Operation for Editing","text":"<p>Navigate to the API Services section and locate the Get Top Headlines operation. Click the  icon next to its name: </p> <p>You used this popup in the Basic Action Guide when you initially defined the operation. Now, let\u2019s check the NewsAPI.org documentation to see what additional parameters we can include. </p> <p>The <code>category</code> and <code>q</code> arguments are particularly useful. The <code>category</code> argument will be a dropdown list with predefined values, while the <code>q</code> argument will be a free-form text input. The free-form field can also accept values through the Expression Editor.  </p> <p>Note</p> <p>In reality all arguments can accept values through the Expression Editor. One of the FlowRunner\u2122 goals is to make data flow from one block to another as simple and as seamless as possible.</p>"},{"location":"extensibility/actions-with-args.html#declaring-arguments","title":"Declaring Arguments","text":"<p>Below is the parameter setup in the Edit Operation popup. Notice that argument names can differ from the API parameter names. For example, instead of \"category,\" we use News Category, and instead of \"q,\" we use Search Query. </p> <p>In the Edit Operation popup, you'll see two fields:  </p> <ul> <li>Parameter Name \u2013 The internal parameter name used in Codeless logic.  </li> <li>Parameter Label \u2013 The name displayed in FlowRunner\u2122 for user input.  </li> </ul> <p>For the category argument, set Visualize As to List of Values (dropdown). This option, when rendered in FlowRunner\u2122, creates a combobox where users can choose from a predefined set of values. Click the  icon next to the dropdown to configure the available values. In the popup, enter \"Labels\" and \"Values\" as shown below. Labels define what users see in the combobox, while Values represent the actual data sent to your Codeless implementation. </p> <p>Ensure the Values match the expected literals from NewsAPI.org (e.g., <code>business</code>, <code>entertainment</code>). Click SAVE to apply the changes.</p>"},{"location":"extensibility/actions-with-args.html#updating-the-codeless-logic","title":"Updating the Codeless Logic","text":"<p>Now that the arguments are declared, update the logic to use them.  </p> <p>While Get Top Headlines is selected, switch to the LOGIC tab and click EDIT to open the Codeless editor. You'll see a block for each parameter you declared. </p> <p>Modify the logic to include the argument values in the API request. The logic must check whether the user provided values for category and q, as they are optional. </p> <p>Alternatively, if you are comfortable using Codeless variables you can implement a more compact version: </p> <p>Click DEPLOY MODEL to save and apply your changes.  </p>"},{"location":"extensibility/actions-with-args.html#testing-the-action-in-flowrunnertm","title":"Testing the Action in FlowRunner\u2122","text":"<p>After deployment, switch to FlowRunner\u2122 and test the action. Open the flow you created in the previous guide, select Get Top Headlines, and notice that the action now includes the new parameters. </p> <p>Enter a value for the Search Query, choose a News Category, and run the action in Test Mode. </p> <p>By following these steps, you have successfully added arguments to an action, updated its logic, and tested it in FlowRunner\u2122. Now, users can dynamically filter headlines using your custom parameters.</p>"},{"location":"extensibility/basic-action-js.html","title":"Custom Action Development Guide","text":"<p>In this guide, you will learn how to build a Node.js FlowRunner\u2122 action that integrates with NewsAPI. If you previously worked on creating your first flow, you may recognize this service.</p> <p>Action Development Guides</p> <p>The action development guide is divided into three parts to keep instructions organized and easy to follow:</p> <ul> <li> <p>Build Basic Action Guide (the current chapter) \u2013 Introduces the fundamentals of developing an action. You will create an action without arguments, using only one configuration item: an API Key.</p> </li> <li> <p>Build Action with Arguments Guide \u2013 Extends the basic action by introducing arguments. This guide explains how to declare action parameters, use them in your implementation logic, and configure them in FlowRunner\u2122.</p> </li> <li> <p>Build Dictionary Operation \u2013 Introduces a special type of argument called a dictionary. This allows your action to dynamically generate a list of selectable parameter values. For example, you can use it to let users choose from a list of Slack channels, Airtable bases, or other external data sources.</p> </li> </ul> <p>Once you have implemented and tested your first action, we recommend following the guides in sequence to expand your understanding and capabilities.</p> <p>By the end of these guides, you will have a fully functional FlowRunner\u2122 action with a configurable API key and action parameters to retrieve related news articles. Once completed, you will be able to use this action in various automation scenarios, such as:</p> <ul> <li>Retrieving news articles based on a search query and analyzing them with AI for content generation.</li> <li>Storing fetched news data in Airtable or Google Sheets for tracking and further processing.</li> <li>Summarizing articles with AI and automatically sending reports via email.</li> </ul> <p>These are just a few examples \u2013 your custom action can be adapted for many automation workflows.</p> <p>You will now implement an action that retrieves top news headlines. See the NewsAPI documentation for reference.</p> <p>Below is the complete source code. A detailed walkthrough is provided later in this chapter:</p> <pre><code>'use strict';\n\n// Hardcoding your API key is not a good idea, however, it comes in very handy for debugging\nconst API_KEY = \"YOUR NEWSAPI API KEY GOES HERE\" \n\n// We will use logging so you can see how it works.\nconst logger = Backendless.Logging.getLogger('NewsAPI Extension')\n\n/**\n * \n *  @integrationName NewsAPI \n * \n **/\nclass NewsAPI {\n  // The constructor is a great place to capture any values which come from the service\n  // configuration parameters. In the case of this service, there is one configuration\n  // item, which is the API key.\n  constructor(config) {\n    this.apiKey = config.apiKey || API_KEY\n  }\n\n  /**\n   * @description Retrieves top news headlines\n   * @route GET /getTopHeadlines\n   * @operationName Get Top Headlines\n   * @appearanceColor #FE1212 #191970\n   * @executionTimeoutInSeconds 120\n   * @sampleResult {\"status\":\"ok\",\"totalResults\":1,\"articles\":[{\"source\":{\"id\":\"the-hill\",\"name\":\"The Hill\"},\"author\":\"Tara Suter\",\"title\":\"West Virginia governor says he\u2019ll take legal action against NCAA over tournament snub - The Hill\",\"description\":\"West Virginia Gov. Patrick Morrisey (R) on Monday said he will take legal action against the NCAA over West Virginia University\u2019s (WVU) snub from the March Madness tournament. \u201cI\u2019ve asked Attorney General [JB McCuskey] to launch an investigation into the NCAA\u2026\",\"url\":\"https://thehill.com/homenews/state-watch/5199135-west-virginia-governor-says-hell-take-legal-action-against-ncaa-over-tournament-snub/\",\"urlToImage\":\"https://thehill.com/wp-content/uploads/sites/2/2024/11/AP24131791907837-e1730586407708.jpg?w=1280\",\"publishedAt\":\"2025-03-17T19:51:12Z\",\"content\":\"Skip to content\\r\\nWest Virginia Gov. Patrick Morrisey (R) on Monday said he will take legal action against the NCAA over West Virginia University\u2019s (WVU) snub from the March Madness tournament.\\r\\n\u201cI\u2019ve asked Attorney General [JB McCuskey] to launch an investigation into the NCAA and whether they violated antitrust or consumer protection laws by excluding WVU from March Madness.\u201d\\r\\nWVU\u2019s men\u2019s basketball team was not selected for the March Madness tournament after finishing with a 9-23 record this season. The school fired men\u2019s basketball head coach Bob Huggins in June after he resigned following a DUI arrest, per ESPN.\\r\\n\u201cThe NCAA\u2019s actions in denying WVU an opportunity to play in March Madness not only hurt our state, but also the students and fans who passionately support West Virginia athletics,\u201d Morrisey said in a statement. \u201cI will take legal action against the NCAA if necessary to protect the rights and interests of our student-athletes and the people of West Virginia.\u201d\\r\\nThe NCAA did not immediately respond to a request for comment from The Hill.\"}]}\n   */\n  async getTopHeadlines() {\n    try {\n      return await Backendless.Request['get']('https://newsapi.org/v2/top-headlines')\n        .set( {\n          'User-Agent':'FlowRunner\u2122'\n        })\n        .query({\n          country:'us',\n          apiKey:this.apiKey\n        })\n    } catch (error) {\n      logger.error(`NewsAPI - error: ${error.message}`)\n      throw error\n    }\n  }\n}\n\nBackendless.ServerCode.addService(NewsAPI, [\n   {\n     order: 0,\n     displayName: 'API Key',\n     type: Backendless.ServerCode.ConfigItems.TYPES.STRING,\n     required: true,\n     name: 'apiKey',\n     hint: 'Your NewsAPI API key. You can obtain one from the newsapi.org website.',\n   }\n]);\n</code></pre>"},{"location":"extensibility/basic-action-js.html#register-as-extension","title":"Register as Extension","text":"<p>For an API Service to be recognized as a FlowRunner\u2122 extension, the service class must include the <code>@integrationName</code> JSDoc tag:</p> <pre><code>/**\n * \n *  @integrationName NewsAPI \n * \n **/\nclass NewsAPI {\n</code></pre>"},{"location":"extensibility/basic-action-js.html#service-icon","title":"Service Icon","text":"<p>You can define an icon for your extension using a class-level annotation. This icon will appear next to the extension name in FlowRunner\u2019s Blocks Toolbox. The same icon is used for all actions and triggers unless overridden at the individual action or trigger level. The icon must be specified in <code>data:image/type:base64</code> format, where <code>type</code> can be <code>png</code>, <code>svg+xml</code>, and so on. For example:</p> <pre><code>/**\n *  @integrationName NewsAPI \n *  @integrationIcon data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0NDggNTEyIj48IS0t...\n **/\nclass NewsAPI {\n</code></pre>"},{"location":"extensibility/basic-action-js.html#service-constructor","title":"Service Constructor","text":"<p>If your service uses configuration items (explained further in the section below), declare a constructor that initializes instance properties. In the example above, notice the fallback logic for debugging purposes\u2014when configuration items are not yet provided, a hardcoded <code>API_KEY</code> is used. Keep in mind, hardcoding sensitive values is a temporary solution and should be avoided in production:</p> <pre><code>class NewsAPI {\n  // The constructor is a great place to capture any values which come from the service\n  // configuration parameters. In the case of this service, there is one configuration\n  // item, which is the API key.\n  constructor(config) {\n    this.apiKey = config.apiKey || API_KEY\n  }\n</code></pre>"},{"location":"extensibility/basic-action-js.html#configuration-items","title":"Configuration Items","text":"<p>The NewsAPI endpoints require an API key. Typically, you will want users of your FlowRunner\u2122 extension to provide this key. This approach also applies to other shared values used across multiple flows. In such cases, your service can declare Configuration Items, which prompt the user to supply these values.</p> <p>Configuration items are defined at the bottom of the service code:</p> <pre><code> Backendless.ServerCode.addService(NewsAPI, [\n   {\n     order: 0,\n     displayName: 'API Key',\n     type: Backendless.ServerCode.ConfigItems.TYPES.STRING,\n     required: true,\n     name: 'apiKey',\n     hint: 'Your NewsAPI API key. You can obtain one from the newsapi.org website.',\n   }\n]);\n</code></pre> <p>This declaration results in a Configure button appearing when the NewsAPI action is used in FlowRunner\u2122: </p> <p>Clicking the button opens a form dynamically generated from your configuration item definition. In this example:</p> <ul> <li>A single string input field is registered (<code>Backendless.ServerCode.ConfigItems.TYPES.STRING</code>).</li> <li>The internal name <code>apiKey</code> is referenced in the service\u2019s constructor (<code>config.apiKey</code>).</li> <li>The field is marked as required.</li> <li>The tooltip is defined using the <code>hint</code> property.</li> </ul> <p>The resulting configuration form appears as follows: </p> <p>For more information, see the Configuration Items section of this guide.</p>"},{"location":"extensibility/basic-action-js.html#action-function","title":"Action Function","text":"<p>A FlowRunner\u2122 action is a Node.js function with special JSDoc-style annotations. Below is the <code>getTopHeadlines</code> action, which FlowRunner\u2122 displays as Get Top Headlines because of the <code>@operationName</code> tag:</p> <pre><code>  /**\n   * @description Retrieves top news headlines\n   * @route GET /getTopHeadlines\n   * @operationName Get Top Headlines\n   * @appearanceColor #FE1212 #191970\n   * @executionTimeoutInSeconds 120\n   * @sampleResult { ... }\n   */\n  async getTopHeadlines() {\n</code></pre>"},{"location":"extensibility/basic-action-js.html#explanation-of-tags","title":"Explanation of Tags","text":"<ul> <li><code>@description</code> \u2013 Provides a tooltip for the action block in FlowRunner\u2122.</li> <li><code>@route</code> \u2013 Optional. Defines how the operation is exposed within Backendless infrastructure.</li> <li><code>@appearanceColor</code> \u2013 Sets two border colors for the action block using hexadecimal RGB values.</li> <li><code>@executionTimeoutInSeconds</code> \u2013 Sets the recommended maximum execution time for the action.</li> <li><code>@sampleResult</code> \u2013 Provides a sample result. This is critical as FlowRunner\u2122 users will reference this structure when working with the action output in the Expression Editor.</li> </ul>"},{"location":"extensibility/basic-action-js.html#additional-notes","title":"Additional Notes","text":"<ul> <li>The action function should always be declared as <code>async</code>.</li> <li>The example above uses the Backendless.Request package, but you may use any method for external API communication.</li> <li>Always catch and log errors. If necessary, rethrow them so they are visible to the Flow logic.</li> <li>If you would like the action to have its own icon different from the service icon, use the <code>@appearanceIcon</code> tag. The tag has the same format as the <code>@integrationIcon</code> tag described above.</li> </ul>"},{"location":"extensibility/basic-action-js.html#serviceextension-registration","title":"Service/Extension Registration","text":"<p>To register the service and all the actions it implements, use the <code>Backendless.ServerCode.addService</code> API. Notice the first argument is a reference to the service class, the second argument is a collection of Configuration Items: <pre><code>Backendless.ServerCode.addService(NewsAPI, [\n    {},{}\n]\n</code></pre></p>"},{"location":"extensibility/config-items.html","title":"Service Configuration Items","text":"<p>A configuration item is a reusable value that a user provides when setting up a FlowRunner\u2122 extension. These values are typically used to pass required settings, such as API keys, booleans, or dates, into your extension\u2019s logic. Once defined, configuration items are available across all actions, triggers, and dictionary functions in your extension.</p> <p>A common use case is an API key required by the third-party service your extension communicates with. Instead of prompting the user for this key in every action, you define it once as a configuration item.</p> <p>When configuration items are present, FlowRunner\u2122 displays a Configure button in the action or trigger\u2019s configuration panel: </p> <p>Clicking the button opens a form where the user can provide values for all configuration items. This configuration is done once per extension and applies globally to all blocks from that extension.</p>"},{"location":"extensibility/config-items.html#set-up-config-items-in-code","title":"Set Up Config Items in Code","text":"<p>To define configuration items in code, provide them as the second argument to the <code>Backendless.ServerCode.addService()</code> method. This argument should be an array of objects, where each object defines one configuration item.</p>"},{"location":"extensibility/config-items.html#example","title":"Example","text":"<p>The following example registers several configuration items using different data types. These fields appear in the configuration form for the extension and can be accessed in your logic through the <code>config</code> object.</p> <pre><code>Backendless.ServerCode.addService(MyService, [\n  {\n    order: 0,\n    displayName: 'API Key',\n    type: Backendless.ServerCode.ConfigItems.TYPES.STRING,\n    required: true,\n    name: 'apiKey',\n    hint: 'Your API key from the third-party service.'\n  },\n  {\n    order: 1,\n    displayName: 'Environment',\n    type: Backendless.ServerCode.ConfigItems.TYPES.CHOICE,\n    required: true,\n    name: 'environment',\n    options: ['sandbox', 'production'],\n    hint: 'Choose the target environment for API requests.'\n  },\n  {\n    order: 2,\n    displayName: 'Enable Logging',\n    type: Backendless.ServerCode.ConfigItems.TYPES.BOOL,\n    required: false,\n    name: 'enableLogging',\n    hint: 'Check to enable debug logging.'\n  },\n  {\n    order: 3,\n    displayName: 'Request Timeout',\n    type: Backendless.ServerCode.ConfigItems.TYPES.STRING,\n    required: false,\n    name: 'timeout',\n    hint: 'Timeout in milliseconds for external API requests.'\n  }\n])\n</code></pre> <p>Breakdown:</p> <ul> <li><code>apiKey</code> uses the <code>STRING</code> type for entering a text-based API key.</li> <li><code>environment</code> uses <code>CHOICE</code> to create a dropdown with predefined options (<code>sandbox</code> or <code>production</code>).</li> <li><code>enableLogging</code> uses <code>BOOL</code> to show a checkbox input.</li> <li><code>timeout</code> is another <code>STRING</code> input, but it could just as easily be a <code>NUMBER</code> if supported in your internal logic.</li> </ul>"},{"location":"extensibility/config-items.html#accessing-config-values","title":"Accessing Config Values","text":"<p>Once the user has configured values, they are passed into your extension\u2019s constructor via a <code>config</code> object. Each configuration item appears as a property on that object using the name you defined. The configuration items declared in the example above can be accessed in your service like this:</p> <pre><code>class MyService {\n  constructor(config) {\n    this.apiKey = config.apiKey\n    this.environment = config.environment\n    this.enableLogging = config.enableLogging\n    this.timeout = config.timeout\n  }\n}\n</code></pre>"},{"location":"extensibility/config-items.html#configuration-item-properties","title":"Configuration Item Properties","text":"Field Description <code>order</code> Determines the display order in the configuration form. Lower values appear first. <code>displayName</code> The label shown in the configuration UI. <code>type</code> The data type for the input. See supported types below. <code>options</code> Required only for <code>CHOICE</code> type. An array of string values for the dropdown list. <code>required</code> Whether this field must be filled out by the user. <code>name</code> The internal name used to access the value in your logic. <code>hint</code> Tooltip text displayed in the UI. Use it to describe the purpose of the item."},{"location":"extensibility/config-items.html#supported-data-types","title":"Supported Data Types","text":"<p>Use the constants in <code>Backendless.ServerCode.ConfigItems.TYPES</code> to define the input type for your configuration fields.</p> Type Description <code>STRING</code> Single-line text input. Use for standard string values. <code>TEXT</code> Multi-line text input. Suitable for longer input like JSON or descriptions. <code>BOOL</code> Checkbox for true/false input. <code>DATE</code> Date/time picker. Use when a specific date or deadline is required. <code>CHOICE</code> Dropdown menu. Must include an <code>options</code> array of strings."},{"location":"extensibility/config-items.html#set-up-config-items-in-the-ui","title":"Set Up Config Items in the UI","text":"<p>You can define configuration items directly when creating a new API service in the Backendless Console. The New Service popup includes a Service Configuration Parameters section.</p> <p>To add a configuration item, click the ADD NEW button: </p> <p>Each configuration item requires the following information:</p> <ul> <li>Label - The display name shown in the configuration form.</li> <li>Hint/Tooltip - A short explanation shown next to the field, usually explaining what the value is for and how to obtain it.</li> <li>Data Type - The type of input to collect (string, boolean, date, etc.).</li> <li>Default Value - A default value that pre-fills the field.</li> <li>Required - Whether the item must be filled out before the configuration is considered valid.</li> </ul> <p>You can delete an item using the  icon. To reorder items, drag them using the  icon: </p>"},{"location":"extensibility/config-items.html#accessing-config-values-in-codeless","title":"Accessing Config Values in Codeless","text":"<p>If you're building your logic using Codeless, you can access configuration item values using the Get Service Config block. This block is available under the Context Blocks section in the Codeless logic editor: </p> <p>The block returns a value for the specified configuration item. </p> <p>By defining configuration items properly, you can make your FlowRunner\u2122 extension easier to configure, safer to use, and more reusable across different flows. Whether you\u2019re building in Node.js or Codeless, configuration items give you a clean way to externalize user-provided settings.</p>"},{"location":"extensibility/custom-action.html","title":"About Custom Actions","text":"<p>In FlowRunner\u2122\u2122, an action represents a custom piece of logic that developers can use within a flow. From a technical standpoint, an action is an API service operation that is specifically configured to be recognized by FlowRunner\u2122\u2122 as a (re)usable block. This enables you to design, develop, and deploy functionality that can be easily integrated into flows, just like the built-in actions already provided by the platform.</p>"},{"location":"extensibility/custom-action.html#what-is-an-action","title":"What is an Action?","text":"<p>An action is essentially an operation/method within an API service. Every action is defined as part of a service, meaning the first step in creating an action is to create an API service itself. Once the service is in place, you can define multiple operations within it. These operations can perform various tasks, such as processing data, connecting to third-party services, or executing custom business logic.</p> <p>For the operation to be recognized as a FlowRunner\u2122\u2122 action, it must be specifically marked as a \"FlowRunner\u2122\u2122 Action\"<sup>1</sup>. This allows it to appear as a draggable block in the FlowRunner\u2122\u2122 toolbox, where it can be easily used and connected to other blocks within a flow. Once set up, these custom actions behave exactly like the built-in actions, enabling smooth integration into any workflow.</p> <p>You can develop custom actions using either Codeless or JavaScript (Node.js). Both approaches - Codeless and JavaScript - offer the same technical capabilities, but the Codeless approach provides more user-friendly features in the Backendless Console, making it easier to create, configure, and manage custom actions.</p>"},{"location":"extensibility/custom-action.html#codeless-vs-javascript-nodejs","title":"Codeless vs. JavaScript (Node.js)","text":"<p>With the Codeless approach, you have the flexibility to create hybrid solutions that combine both graphical logic programming and code, or even rely entirely on code if that's your preference. This method offers significant ease-of-use through the Backendless Console's user interface, which streamlines the process of creating custom actions, configuring parameters, and integrating third-party services.</p> <p>On the other hand, the JavaScript (Node.js) approach provides the same level of power and flexibility but requires more manual coding. While both approaches offer equivalent technical functionality, Codeless comes with enhanced tools in the Backendless Console, making it ideal for developers who prefer a visual environment or need to work with complex configurations, such as OAuth 2.0 authentication.</p>"},{"location":"extensibility/custom-action.html#codeless-advantages","title":"Codeless Advantages","text":"<p>The Codeless approach not only simplifies the development of custom actions but also provides additional interface features that make the process smoother and more efficient. These include:</p> <ul> <li> <p>Visual Interface for Action Creation: The Codeless environment offers a drag-and-drop interface for building logic, making it easier to visualize the flow and structure of your custom actions.     </p> </li> <li> <p>User Interface for Service Configuration: The Backendless Console offers dedicated user interfaces for configuring service parameters, allowing you to provide an additional layer of behavior customization to the end users of your actions.     </p> </li> <li> <p>OAuth 2.0 Integration: For services that require OAuth 2.0 authentication (such as Google, Slack, Facebook, or Mailchimp), the Codeless interface makes it easier to integrate user authentication with these services into your custom actions.     </p> </li> </ul>"},{"location":"extensibility/custom-action.html#action-development-features","title":"Action Development Features","text":"<p>When developing custom actions in the Backendless Console, you have access to a wide range of features designed to simplify the process and enhance your development workflow:</p> <ul> <li> <p>Creation of New Actions: Easily create and configure new actions that can be integrated into FlowRunner\u2122\u2122 workflows.</p> </li> <li> <p>Visual Action Customization: Customize the appearance of your action block by assigning an icon, adjusting the color border, and adding a descriptive tooltip that will appear when users hover over the action.</p> </li> <li> <p>Service Configuration Parameters: Define and manage parameters for your custom actions, ensuring smooth interaction with external services or internal data.</p> </li> <li> <p>Integration with OAuth 2.0 Services: Simplify the integration of third-party services requiring OAuth 2.0 authentication, such as Google, Slack, Facebook, and Mailchimp.</p> </li> <li> <p>Built-In Logic Editor: Use the Codeless logic editor to visually construct complex operations or integrate custom JavaScript logic, depending on your chosen approach.</p> </li> <li> <p>Deployment and Testing Environment: Test and deploy your custom actions directly from the Backendless Console, making it easy to iterate on development and ensure your actions function as expected in live workflows.</p> </li> </ul>"},{"location":"extensibility/custom-action.html#getting-started","title":"Getting Started","text":"<p>To become familiar with the process of developing a custom action for FlowRunner\u2122\u2122, we recommend following the Quick Start Guide, which will walk you through creating, configuring, and deploying a custom action using both the Codeless and JavaScript approaches. </p> <p>For a complete walkthrough of all the features and capabilities available to developers of custom actions, follow the chapters in this section of the guide.</p> <ol> <li> <p>This option is enabled by default for Codeless API Services\u00a0\u21a9</p> </li> </ol>"},{"location":"extensibility/dictionary-arguments.html","title":"Developing an Action with Dictionary Arguments","text":"<p>In this guide, you will continue building on the action you developed in the Basic Action Guide and enhanced in the Action with Arguments Guide. This chapter introduces a special type of action parameter called a dictionary, which allows dynamic population of selectable values in FlowRunner\u2122.  </p> <p>Imagine that your Get Top Headlines action in FlowRunner\u2122 allows users to select a news source. Ideally, a FlowRunner\u2122 user should be able to click the Source input parameter and see a dynamically generated list of available sources as shown below: </p> <p>Dictionary arguments make this possible by fetching and displaying selectable options from an external source.</p> <p>To illustrate this, let\u2019s revisit the external service you have already integrated - NewsAPI.org. One of the parameters supported by its Top Headlines endpoint is <code>sources</code>: </p> <p>As shown in the NewsAPI.org documentation referenced above, retrieving a list of available sources requires calling a separate endpoint. The documentation for that endpoint is shown below: </p>"},{"location":"extensibility/dictionary-arguments.html#implementation-steps","title":"Implementation Steps","text":"<p>Implementing the behavior described above requires two main steps:  </p> <ol> <li>Create a dictionary operation - This operation retrieves and formats a list of selectable values.  </li> <li>Reference the dictionary operation in an argument - This links the action parameter to the dictionary operation, enabling dynamic selection.  </li> </ol>"},{"location":"extensibility/dictionary-arguments.html#implementing-a-dictionary-operation","title":"Implementing a Dictionary Operation","text":"<p>To create a dictionary operation, follow these steps:  </p> <ol> <li>Open the API Services screen and select the Get Top Headlines service.  </li> <li> <p>Click the NEW OPERATION button. </p> </li> <li> <p>In the New Codeless Operation popup:  </p> <ul> <li>Enter <code>getSources</code> as the Name.  </li> <li>Select Dictionary from the Register in FlowRunner\u2122 as dropdown located in a panel in the lower-right corner of the interface.  </li> <li>Keep all the default operation parameters.  </li> </ul> <p>Your popup should look like this when configured correctly: </p> </li> <li> <p>Click SAVE to create the operation.  </p> </li> </ol> <p>To complete the final step, implement the Codeless logic for this dictionary operation: </p> <p>Every dictionary operation, including the one shown above, must return an object containing an <code>items</code> property. This property holds a collection of selectable items, each with the following fields:  </p> <ul> <li><code>value</code> \u2013 The actual value passed to the main service operation when selected.  </li> <li><code>label</code> \u2013 The user-friendly name displayed in FlowRunner\u2122.  </li> <li><code>node</code> \u2013 Additional information that enhances the selection, such as metadata or descriptions.  </li> </ul>"},{"location":"extensibility/dictionary-arguments.html#linking-an-argument-with-dictionary","title":"Linking an Argument with Dictionary","text":"<p>Now, let\u2019s integrate the dictionary operation into the Get Top Headlines action:  </p> <ol> <li>Open the API Services screen and locate the Get Top Headlines operation.  </li> <li>Click the  icon next to its name to open the Edit Operation popup.  </li> <li> <p>Add a new parameter named Source and configure it as follows:     Set the Options Provider Method to <code>getSources</code> (this links the parameter to the dictionary operation).  </p> <p>The configuration should look like this: </p> </li> <li> <p>Click SAVE to apply the changes.  </p> </li> </ol>"},{"location":"extensibility/dictionary-arguments.html#updating-the-codeless-logic","title":"Updating the Codeless Logic","text":"<p>Next, update the Get Top Headlines logic to include the new Source argument:  </p> <ol> <li>Open the LOGIC tab and click EDIT to enter the Codeless editor.  </li> <li> <p>Modify the logic to handle the new Source parameter: </p> </li> <li> <p>Click DEPLOY MODEL to save and apply the changes.  </p> </li> </ol>"},{"location":"extensibility/dictionary-arguments.html#testing-the-action-in-flowrunnertm","title":"Testing the Action in FlowRunner\u2122","text":"<p>With everything set up, navigate to FlowRunner\u2122 and test your action:  </p> <ol> <li>Open the flow that includes your Get Top Headlines action.  </li> <li>Select the action, and you\u2019ll see a new Source parameter.  </li> <li>Click the Source input field. FlowRunner\u2122 will send a request to your dictionary operation and display a list of available sources. </li> </ol> <p>Now, your action dynamically fetches and displays selectable values, enhancing the user experience in FlowRunner\u2122.</p>"},{"location":"extensibility/mcp-integration.html","title":"MCP Server Integration","text":"<p>FlowRunner\u2122 integrates with Model Context Protocol (MCP) servers to extend workflow capabilities. Register MCP servers to make their tools available as FlowRunner\u2122 actions and AI Agent tools.</p>"},{"location":"extensibility/mcp-integration.html#what-is-mcp","title":"What is MCP?","text":"<p>Model Context Protocol (MCP) is a standardized protocol for exposing tools and resources to AI systems. MCP servers provide collections of tools that can be called by AI agents or used directly in workflows.</p> <p>When you register an MCP server in FlowRunner\u2122, all server tools become available as workflow actions. Tools can be used in AI Agent configurations, tool parameters integrate with FlowRunner\u2122's Expression Editor, and tool results can be referenced by other blocks in the workflow.</p>"},{"location":"extensibility/mcp-integration.html#accessing-mcp-server-management","title":"Accessing MCP Server Management","text":"<p>Open the MCP Server management screen using either method:</p> <p>Method 1: Block List Panel Click the MCP icon next to the search bar in the Block List panel.</p> <p>Method 2: Quick Access Menu Click the QUICK ACCESS button and select MCP Servers.</p>"},{"location":"extensibility/mcp-integration.html#registering-an-mcp-server","title":"Registering an MCP Server","text":"<p>To register a new MCP server:</p> <ol> <li> <p>Enter the MCP URL    Provide the publicly accessible URL for the MCP server.</p> </li> <li> <p>Configure Server Name    Enter a name to identify this server in the FlowRunner\u2122 UI. This name appears in the Block List panel.</p> </li> <li> <p>Set Server Logo    Choose how the server appears visually:</p> </li> <li>Avatar letters - Auto-generated from the server URL</li> <li>Predefined logos - Select from available icons</li> <li> <p>Background color - Cycle through color options to customize appearance</p> </li> <li> <p>Configure Authentication (Optional)    If the MCP server requires authentication, expand the Authentication Settings section and configure:</p> <p>Token Authentication:</p> <ul> <li>Custom Header Name (default: \"Authorization\")</li> <li>Token value (e.g., \"Bearer Token\")</li> </ul> <p>OAuth 2.0:</p> <ul> <li>Client ID</li> <li>Client Secret</li> </ul> </li> <li> <p>Register the Server    Click REGISTER. FlowRunner\u2122 validates the server URL and authentication, then adds the server to your registered servers list.</p> </li> </ol> <p>If registration fails, verify the MCP URL is publicly accessible, authentication credentials are correct, and the server implements the MCP protocol correctly.</p>"},{"location":"extensibility/mcp-integration.html#managing-registered-servers","title":"Managing Registered Servers","text":"<p>The Registered Servers list displays all configured MCP servers. Each entry shows the server logo (icon and background color), server name, MCP URL, an EDIT button to modify server configuration, and a REMOVE button to delete the server registration.</p>"},{"location":"extensibility/mcp-integration.html#editing-a-server","title":"Editing a Server","text":"<p>Click EDIT to modify an existing server configuration. The edit screen shows all registration fields (URL, name, logo, authentication), an Available Tools section listing all tools exposed by the server with their descriptions and parameters, and buttons to reload tools, save changes, or cancel.</p> <p>Use RELOAD TOOLS when the MCP server adds or updates tools without changing its URL.</p>"},{"location":"extensibility/mcp-integration.html#removing-a-server","title":"Removing a Server","text":"<p>Click REMOVE to delete a server registration. This removes the server from the Block List panel and makes its tools unavailable in workflows. Note that existing workflows using the server's tools will fail if executed.</p> <p>Remove servers before deleting workflows that depend on them, or update workflows to remove MCP tool references.</p>"},{"location":"extensibility/mcp-integration.html#using-mcp-tools-in-workflows","title":"Using MCP Tools in Workflows","text":"<p>After registering an MCP server, its tools appear in the Block List panel under MCP SERVERS.</p>"},{"location":"extensibility/mcp-integration.html#locating-mcp-tools","title":"Locating MCP Tools","text":"<p>MCP servers are listed by their configured name and logo. Expand a server to view its available tools. Each tool displays its icon (matching the server logo), tool name, description (on hover), and action count indicator.</p>"},{"location":"extensibility/mcp-integration.html#adding-mcp-tools-to-flows","title":"Adding MCP Tools to Flows","text":"<p>Drag any MCP tool from the Block List panel into the flow canvas. MCP tools function as standard FlowRunner\u2122 actions. Configure tool parameters in the block settings panel, use Expression Editor for dynamic parameter values, reference tool results in subsequent blocks, and apply conditional logic based on tool outputs.</p>"},{"location":"extensibility/mcp-integration.html#tool-parameters","title":"Tool Parameters","text":"<p>MCP tool parameters integrate with FlowRunner\u2122's parameter system. All parameters support Expression Editor, parameter types follow FlowRunner\u2122 conventions, required parameters are marked, and parameter validation follows the tool schema.</p> <p>Access tool results using Expression Editor syntax:</p> <pre><code>${blockName.result.propertyName}\n</code></pre> <p>Tool results can be used as input for any downstream block in the workflow.</p>"},{"location":"extensibility/mcp-integration.html#using-mcp-tools-with-ai-agents","title":"Using MCP Tools with AI Agents","text":"<p>MCP tools are available as tools for AI Agent blocks. When configuring an AI Agent, open the AI Agent block settings, navigate to the Tools section, and select MCP tools from registered servers. The AI Agent can invoke these tools during execution.</p> <p>AI Agents can call MCP tools based on task requirements, pass parameters to tools dynamically, process tool results, and chain multiple tool calls together.</p> <p>For AI Agent configuration details, see AI Agent documentation.</p>"},{"location":"extensibility/mcp-integration.html#mcp-tool-execution","title":"MCP Tool Execution","text":"<p>When a workflow executes an MCP tool, FlowRunner\u2122 sends a request to the MCP server with authentication credentials (if configured). Parameters are passed according to the tool schema. The server processes the request and returns results, which are made available to subsequent blocks.</p> <p>Tool execution follows FlowRunner\u2122's standard error handling. If a tool fails, the workflow stops at that block unless error handling is configured. Error details are logged, and error handlers can catch and process failures.</p> <p>See Error Handling for managing tool failures.</p>"},{"location":"extensibility/mcp-integration.html#best-practices","title":"Best Practices","text":""},{"location":"extensibility/mcp-integration.html#server-configuration","title":"Server Configuration","text":"<p>Use descriptive server names that indicate the server's purpose. Configure authentication for production servers, test server connectivity before registering, and document which workflows depend on each MCP server.</p>"},{"location":"extensibility/mcp-integration.html#tool-usage","title":"Tool Usage","text":"<p>Verify tool availability before building workflows. Use Expression Editor for dynamic tool parameters, add error handling for tool failures, and test workflows after MCP server updates.</p>"},{"location":"extensibility/mcp-integration.html#maintenance","title":"Maintenance","text":"<p>Reload tools after server updates, monitor tool execution for errors, update authentication credentials when they expire, and remove unused servers to keep the Block List clean.</p>"},{"location":"extensibility/mcp-integration.html#troubleshooting","title":"Troubleshooting","text":"Problem Solutions Server Registration Fails - Cannot register MCP server Verify the MCP URL is publicly accessible, check authentication credentials, confirm the server implements MCP protocol, and review server logs for connection errors. Tools Not Appearing - Registered server shows no tools Click RELOAD TOOLS in the server edit screen, verify the server exposes tools via MCP protocol, check server logs for tool discovery errors, or re-register the server if tools remain unavailable. Tool Execution Fails - MCP tool fails during workflow execution Verify tool parameters are correctly configured, check authentication credentials are valid, review tool execution logs, test the tool directly via the MCP server's interface, and add error handling to the workflow. Authentication Errors - Authentication fails when calling tools Verify authentication settings match server requirements, check token or OAuth credentials are current, test authentication by reloading tools, and contact the MCP server administrator for credential issues."},{"location":"extensibility/mcp-integration.html#related-documentation","title":"Related Documentation","text":"<ul> <li>AI Agent - Using MCP tools with AI Agents</li> <li>Expression Editor - Referencing tool results</li> <li>Error Handling - Managing tool failures</li> <li>Custom Actions - Alternative extensibility approach</li> </ul>"},{"location":"extensibility/oauth2-services.html","title":"Services with OAuth2 Authorization","text":"<p>FlowRunner\u2122's custom actions can integrate with any network-based resource. Many of these resources rely on the OAuth2 authorization protocol. Implementing OAuth2 can sometimes be complex, so FlowRunner\u2122 and Backendless provide a built-in mechanism that makes it easier for developers to create services that use the OAuth2 authorization workflow.</p> <p>Here\u2019s an improved version of your draft with better flow and readability. I\u2019ve kept the technical depth while making it more intuitive and easier to understand.</p>"},{"location":"extensibility/oauth2-services.html#how-does-it-work","title":"How Does It Work?","text":"<p>Integrating OAuth2 into FlowRunner\u2122 involves several key steps, making it easy for developers to add OAuth2 authorization to their custom services. Below is an overview of the process:</p> <pre><code>sequenceDiagram\n    autonumber\n    actor Developer\n    participant FlowRunner\n    participant Backendless as Your API Service\n    participant OAuth2Provider as OAuth2 Service Provider\n\n    Developer-&gt;&gt;Backendless: Create API service with OAuth2 Authorization template\n    Developer-&gt;&gt;Backendless: Implement OAuth2 methods and custom actions\n    Developer-&gt;&gt;Backendless: Deploy and test service\n    Developer-&gt;&gt;FlowRunner\u2122: Add custom action to flow\n    activate FlowRunner\n    FlowRunner\u2122-&gt;&gt;Developer: Display \"Login\" button\n    deactivate FlowRunner\n    Developer-&gt;&gt;FlowRunner\u2122: Click \"Login\" button\n    FlowRunner\u2122-&gt;&gt;OAuth2Provider: Redirect to OAuth2 service provider\n    activate OAuth2Provider\n    OAuth2Provider-&gt;&gt;Developer: Authenticate user\n    OAuth2Provider--&gt;&gt;Backendless: Return OAuth2 access code\n    deactivate OAuth2Provider</code></pre>"},{"location":"extensibility/oauth2-services.html#step-by-step-explanation","title":"Step-by-Step Explanation","text":"<p>OAuth2 integrations may seem complex due to their many components, but we\u2019ll break down each step to make the process easier. Every step outlined above has a corresponding section below, where we dive deeper into the details.</p> <ol> <li> <p>Create a New Service Using the OAuth2 Template</p> <p>New API services can be created from the API Services screen in the Backendless Console. Click the :plus: icon and use the New Service popup. To enable OAuth2 authorization in your service, select the With OAuth2 Authorization option from the Template dropdown list.  </p> <p></p> <p>When creating a service with OAuth2, you\u2019ll need to provide additional information:</p> <ul> <li>Integration Name: This name identifies the service in your implementation. It's best to use the name of the OAuth provider (e.g., Google, Facebook).</li> <li>Integration Icon: This visual icon helps recognize the OAuth provider in the UI, usually the provider's logo.</li> </ul> <p>These details are also used in the Connections Manager, where you can view and manage active OAuth2 authorizations (called connections).</p> <p>Once the service is created, Backendless will include three key methods responsible for managing the OAuth2 workflow. You can learn more about these methods in the OAuth2 Service Operations section.</p> </li> <li> <p>Implement OAuth2 Methods</p> <p>When the service is created, Backendless generates the necessary OAuth2 methods to facilitate authorization. These methods enable the service to seamlessly integrate with OAuth2 workflows.</p> <p>You can implement these methods using Codeless (drag-and-drop logic) or in a hybrid approach combining Node.js code with Codeless. The OAuth2 Service Operations section of this guide covers the specifics of these methods.</p> <p></p> </li> <li> <p>Deploy and Test the Service</p> <p>Once the methods and actions are implemented, the service is deployed and tested. The deployment process depends on whether you\u2019re using Codeless or JavaScript. If you are developing the service locally, deployment steps will vary. For detailed guidance, refer to the Action Testing section of the documentation.</p> </li> <li> <p>Add Custom Actions to a Flow</p> <p>After deploying the service, any operation marked as a FlowRunner\u2122 Action will appear in FlowRunner\u2019s Custom Actions section. Each custom action is identified by its operation name, service name, and the icon you specified during setup. To use the action in a flow, simply drag it into the Flow Editor.</p> <p></p> <p>Note</p> <p>For a custom action to appear in Flow Editor, your service must have an operation marked as a FlowRunner\u2122 Action.</p> </li> <li> <p>Displaying the OAuth2 Login Button</p> <p>If the custom action\u2019s service was created using the OAuth2 Authorization template, you will see a Login button in the action\u2019s properties panel. This button signals that the service requires OAuth2 authentication.</p> <p></p> </li> <li> <p>Starting the Authorization Process</p> <p>Clicking the Login button starts the OAuth2 authorization sequence. FlowRunner\u2122 will redirect the user to the OAuth2 provider\u2019s login page. The provider typically hosts a login form where users enter their credentials.</p> </li> <li> <p>Redirect to OAuth2 Login</p> <p>FlowRunner\u2122 retrieves the OAuth2 endpoint URL from the service when the Login button is clicked. A new window opens with the provider\u2019s login form, where the user authenticates and grants access to the requested permissions (known as scopes). Scopes might include reading emails, accessing files, or viewing user information.</p> <p></p> </li> <li> <p>User Authentication and Permission Granting</p> <p>Once authenticated, the user grants permission for the service to access specific scopes (such as email or profile information). This is a crucial part of the OAuth2 authorization workflow.</p> </li> <li> <p>Access Token Delivered</p> <p>After user authentication, the OAuth2 provider returns an access token to Backendless. The token grants your service authorized access to the provider\u2019s API. This process is managed by Backendless, which coordinates the exchange of an authorization code for an access token.</p> <p>You can manage all OAuth2 connections through the Connections Manager interface in Backendless. This screen lets you view and manage active OAuth2 authorizations for various services.</p> </li> </ol>"},{"location":"extensibility/oauth2-services.html#oauth2-service-operations","title":"OAuth2 Service Operations","text":"<p>To integrate an API Service with the OAuth2 workflow in FlowRunner\u2122, the service must implement the following key operations:</p> <ul> <li><code>getOAuth2ConnectionURL</code>: Responsible for returning the complete Authorization Endpoint URL provided by the OAuth2 service provider. This URL is where users will be redirected to authenticate.</li> <li><code>executeCallback</code>: Handles the exchange of the temporary authorization code received from the OAuth2 provider for a more permanent authorization token.</li> <li><code>refreshToken</code>: Since the authorization token received may expire after a certain period, this operation is responsible for refreshing the token when needed.</li> </ul> <p>When you create an OAuth2-enabled API service, Backendless automatically generates placeholders for these methods. However, it is up to you to implement them. While the specific details may vary depending on the OAuth2 provider, the general process is standardized across all compliant providers. The sequence diagram below illustrates how these operations work within the OAuth2 workflow.</p>"},{"location":"extensibility/oauth2-services.html#oauth2-workflow","title":"OAuth2 Workflow","text":"<p>Note</p> <p>The diagram below zooms in on steps 7-9 from the earlier breakdown of the OAuth2 flow.</p> <pre><code>sequenceDiagram\n    autonumber\n    actor Developer\n    participant FlowRunner\u2122 as FlowRunner\u2122/Backendless\n    participant APIService as Your API Service\n    participant OAuth2Provider as OAuth2 Service Provider\n\n    Developer-&gt;&gt;FlowRunner\u2122: Click \"Login\" button\n    FlowRunner\u2122-&gt;&gt;APIService: Call `getOAuth2ConnectionURL`\n    APIService--&gt;&gt;FlowRunner\u2122: Return Authorization Endpoint URL\n    FlowRunner\u2122-&gt;&gt;Developer: Redirect to Authorization Endpoint\n    Developer-&gt;&gt;OAuth2Provider: Authenticate and grant permissions\n    OAuth2Provider-&gt;&gt;FlowRunner\u2122: Send temporary auth code via callback\n    FlowRunner\u2122-&gt;&gt;APIService: Call `executeCallback` on API Service\n    activate APIService\n    APIService-&gt;&gt;OAuth2Provider: Exchange code for auth token\n    OAuth2Provider--&gt;&gt;APIService: Return auth token (with optional expiration)\n    APIService--&gt;&gt;FlowRunner\u2122: Return auth token and expiration (if any)\n    deactivate APIService\n    FlowRunner\u2122-&gt;&gt;FlowRunner\u2122: Monitor token expiration\n    FlowRunner\u2122-&gt;&gt;APIService: Call `refreshToken` when needed\n    APIService-&gt;&gt;OAuth2Provider: Request new token\n    OAuth2Provider--&gt;&gt;APIService: Return refreshed token\n    APIService--&gt;&gt;FlowRunner\u2122: Return refreshed token</code></pre>"},{"location":"extensibility/oauth2-services.html#step-by-step-explanation_1","title":"Step-by-Step Explanation","text":"<ol> <li> <p>Developer/User clicks the Login button    The OAuth2 authorization process starts when the user clicks the Login button in FlowRunner\u2122.</p> </li> <li> <p>FlowRunner\u2122 calls the <code>getOAuth2ConnectionURL</code> operation    FlowRunner\u2122, acting in conjunction with Backendless, calls the <code>getOAuth2ConnectionURL</code> method on your API Service to get the OAuth2 provider's Authorization Endpoint URL.</p> </li> <li> <p>API Service returns the Authorization Endpoint URL    The API Service provides the URL where the user will be redirected to authenticate.</p> </li> <li> <p>Developer/User is redirected to the Authorization Endpoint    The developer/user is redirected to the OAuth2 provider's login page.</p> </li> <li> <p>Developer/User authenticates and grants permissions    The developer/user logs in at the OAuth2 provider\u2019s login page and grants the requested permissions (scopes). These might include access to resources like email, profile data, or other user information.</p> </li> <li> <p>OAuth2 provider sends a temporary authorization code via callback    After successful login and permission grant, the OAuth2 provider sends a temporary authorization code to Backendless through a callback URL.</p> </li> <li> <p>Backendless calls the <code>executeCallback</code> operation on the API Service    Upon receiving the authorization code, Backendless calls the <code>executeCallback</code> method in the API Service, instructing it to handle the next step of the OAuth2 process: exchanging the authorization code for an access token.</p> </li> <li> <p>API Service exchanges the code for an access token    The API Service, specifically the <code>executeCallback</code> operation communicates with the OAuth2 provider, sending the temporary authorization code and requesting an access token.</p> </li> <li> <p>OAuth2 provider returns the access token    The OAuth2 provider sends back the access token along with additional information such as the token's expiration time (if any).</p> </li> <li> <p>API Service returns the token and expiration details to Backendless     The API Service passes the access token and any associated expiration time to Baxckendless, enabling the service to use the token for authenticated requests.</p> </li> <li> <p>Backendless monitors the token\u2019s expiration     Backendless keeps track of the token\u2019s expiration time. If the token is set to expire, Backendless will take action to ensure that the service remains authenticated.</p> </li> <li> <p>Backendless calls the <code>refreshToken</code> operation when needed     When Backendless detects that the token is about to expire, it calls the <code>refreshToken</code> operation on the API Service to request a new token.</p> </li> <li> <p>API Service requests a new token from the OAuth2 provider     The API Service, specifically the <code>refreshToken</code> operation contacts the OAuth2 provider, sending a request to refresh the token before it expires.</p> </li> <li> <p>OAuth2 provider returns a refreshed token     The OAuth2 provider responds by sending a new, refreshed access token.</p> </li> <li> <p>API Service returns the refreshed token to Backendless     Finally, the API Service passes the new token back to Backendless, ensuring continued access to the OAuth2-protected resources.</p> </li> </ol> <p>This detailed explanation shows how each operation in the OAuth2 process is handled within FlowRunner\u2122/Backendless. The API Service plays a critical role in managing interactions with the OAuth2 provider, while FlowRunner\u2122 ensures that the OAuth2 workflow, including token expiration and refreshing, is handled smoothly. By implementing the <code>getOAuth2ConnectionURL</code>, <code>executeCallback</code>, and <code>refreshToken</code> methods, you enable secure and dynamic OAuth2 authentication for your services.</p>"},{"location":"extensibility/oauth2-services.html#oauth2-connection-manager","title":"OAuth2 Connection Manager","text":"<p>// TODO</p>"},{"location":"extensibility/oauth2-services.html#oauth2-operation-details","title":"OAuth2 Operation Details","text":""},{"location":"extensibility/oauth2-services.html#getoauth2connectionurl","title":"getOAuth2ConnectionURL","text":"<p>This operation is responsible for generating and returning the full Authorization Endpoint URL for the OAuth2 provider. The URL must include all the necessary query parameters required by the OAuth2 service provider, ensuring a smooth authorization process. </p> <p>The query parameters typically include, but are not limited to:</p> <ul> <li><code>client_id</code>: The client identification issued by the OAuth2 provider.</li> <li><code>redirect_uri</code>: The URL to which the OAuth2 provider should redirect after the user authorizes the application.</li> <li><code>response_type</code>: Typically set to <code>code</code>, indicating that the app is requesting an authorization code.</li> <li><code>scope</code>: A list of permissions or access levels that the application is requesting from the user (e.g., access to profile data, email, etc.).</li> <li> <p><code>state</code>: An optional parameter that can be used to maintain the state between the request and callback, often used to prevent CSRF attacks.</p> </li> <li> <p>The returned URL must be a fully formed absolute URL, ready for the user to be redirected to. </p> </li> <li>You may need to customize the URL based on the specific OAuth2 provider, as different providers might require additional or differently named parameters.</li> <li>Ensure that the callback URL (also known as the redirect URI) matches the one registered with the OAuth2 provider, as mismatches can cause errors during the authorization process.</li> </ul> <p>An example of what the Authorization Endpoint URL might look like after this operation completes: <pre><code>https://oauth2provider.com/auth?client_id=YOUR_CLIENT_ID&amp;redirect_uri=https://yourapp.com/callback&amp;response_type=code&amp;scope=email+profile&amp;state=xyz123\n</code></pre></p> <p>This URL will redirect the user to the OAuth2 provider\u2019s authorization page, where they can log in and grant the requested permissions.</p> CODELESSJS <p></p> <pre><code>/**\n * @operationName getOAuth2ConnectionURL\n * @route GET /getOAuth2ConnectionURL\n */\nasync getOAuth2ConnectionURL() {\n  return 'https://... Put the external service OAuth2 URL here'\n}\n</code></pre>"},{"location":"extensibility/oauth2-services.html#executecallback","title":"executeCallback","text":"<p>This operation is responsible for exchanging a temporary authorization code for a more permanent authorization token, which may still have an expiration. The token received from this exchange must be used in the APIs provided by the OAuth2 service provider. Below is a general guideline for implementing this operation.</p> <p>The process typically involves sending an outbound HTTP request to the OAuth2 service provider. Ensure the request conforms to the specific requirements of the provider. In most implementations, the process includes the following steps:</p> <ul> <li>POST Request: Send a <code>POST</code> request to the URL designated by the OAuth2 provider for token exchange.</li> <li>Content-Type: Set the <code>Content-Type</code> header to <code>application/x-www-form-urlencoded</code>. This means the required parameters, such as the authorization code and client credentials, are sent in the request body as <code>key=value</code> pairs separated by <code>&amp;</code>.</li> </ul> <p>The return value of this operation must be an object containing the following properties:</p> <ul> <li><code>token</code>: The authorization token obtained from the OAuth2 provider as a result of the code-to-token exchange.</li> <li><code>expirationInSeconds</code>: If the token has an expiration time, this property should indicate the number of seconds until the token expires.</li> <li><code>refreshToken</code>: If the token is refreshable, include the refresh token provided by the OAuth2 provider. This token will be used later to renew the authorization token when it expires.</li> <li><code>connectionIdentityName</code>: A unique identifier for the connection with the OAuth2 provider. This could be the logged-in user's identity, such as their email address, or a static string value that represents the connection. The returned value will be used to identify the connection in the OAuth Connection Manager.</li> </ul> <p>Make sure the implementation of this method adheres to the OAuth2 provider's specific token exchange requirements, such as sending client credentials, the authorization code, and any other necessary data. The returned object allows Backendless to manage the token lifecycle and ensure the connection with the OAuth2 provider remains active.</p> CODELESSJS <p></p> <pre><code>/**\n * @typedef {Object} executeCallback_ResultObject\n *\n * @property {String} token\n * @property {String} refreshToken\n * @property {Number} expirationInSeconds\n * @property {Object} userData\n * @property {String} connectionIdentityName\n * \n * @operationName executeCallback\n * @route POST /executeCallback\n * @param {Object} [callbackObject]\n * @returns {executeCallback_ResultObject}\n */\nasync executeCallback(callbackObject) {\n\n  // PERFORM CODE TO TOKEN EXCHANGE HERE \n\n    return ({ \n      token: 'TOKEN FROM OAUTH2 SERVICE PROVIDER',\n      expirationInSeconds: EXPIRATION IF ANY,\n      refreshToken: 'REFRESH TOKEN IF ANY',\n      connectionIdentityName: 'NAME OF THE CONNECTION' \n    })\n}\n</code></pre>"},{"location":"extensibility/oauth2-services.html#refreshtoken","title":"refreshToken","text":"<p>This operation is responsible for renewing the authorization token when the existing one obtained in the <code>executeCallback</code> operation expires. When the system detects that the current token has expired, it automatically calls this operation. </p> <p>The operation receives the refresh token as a parameter, which is provided by the OAuth2 service during the initial token exchange. The refresh token is used to request a new authorization token from the OAuth2 provider.</p> <p>The response from this operation must be an object containing the following properties:</p> <ul> <li><code>token</code>: The new (renewed) authorization token obtained from the OAuth2 provider.</li> <li><code>expirationInSeconds</code>: The number of seconds until the renewed token expires. If the token has no expiration, this value can be omitted or set to <code>null</code>.</li> <li><code>refreshToken</code>: Some OAuth service providers require the refresh token itself to be periodically refreshed. If the refresh token changes, use the <code>refreshToken</code> property in the response to return the updated refresh token. Otherwise, this property can be removed from the response.</li> </ul> <p>When implementing this operation logic, it is important to keep in mind the following:</p> <ul> <li>Ensure the request to the OAuth2 provider adheres to the provider\u2019s requirements for token refreshing. Typically, this involves sending a <code>POST</code> request to the token endpoint with the refresh token and other necessary credentials.</li> <li>The refreshed token should be returned promptly to avoid interruptions in service.</li> <li>Not all tokens can be refreshed indefinitely. Be mindful of potential limitations or expiration policies imposed by the OAuth2 provider.</li> </ul> <p>This method ensures that your API service continues to operate without needing to manually re-authenticate once the original token expires.</p> CODELESSJS <p></p> <pre><code>/**\n * @typedef {Object} refreshToken_ResultObject\n *\n * @property {String} token\n * @property {Number} expirationInSeconds\n *\n * @operationName refreshToken\n * @route PUT /refreshToken\n * @param {String} refreshToken\n * @returns {refreshToken_ResultObject}\n */\nasync refreshToken(refreshToken) {\n  /**\n   * Send a request to the OAuth Service provider\n   * to obtain a renewed auth token. Use the provided\n   * refresh token in the renewal operation.\n   */ \n  return ({ \n    token: 'RENEWED AUTH TOKEN FROM THE PROVIDER',\n    expirationInSeconds: TOKEN-EXPIRATION-IN-SECONDS \n  })\n}\n</code></pre>"},{"location":"extensibility/overview.html","title":"About Extensibility","text":"<p>FlowRunner\u2122 can be extended to meet specific workflow requirements. Use MCP server integration for external tools, build custom actions for specialized operations, or create custom triggers for application-specific events.</p> <p>Pre-built Extensions</p> <p>FlowRunner\u2122 includes pre-built extensions for popular services including Gmail, Google Drive, Google Sheets, Outlook, Airtable, Slack, and others. Each extension provides specialized actions and triggers for that service. These extensions are built using the same extensibility framework documented in this section.</p> <p>Community developers can create and publish additional extensions to the FlowRunner\u2122 integration directory. Approved extensions become available to all users.</p>"},{"location":"extensibility/overview.html#extension-methods","title":"Extension Methods","text":"<p>FlowRunner\u2122 supports three approaches to extensibility:</p>"},{"location":"extensibility/overview.html#mcp-server-integration","title":"MCP Server Integration","text":"<p>Register Model Context Protocol (MCP) servers to add external tools to FlowRunner\u2122. MCP integration provides access to tools from any MCP-compatible server with automatic tool discovery and registration. Tools become available as workflow actions and AI Agent tools without requiring custom code.</p> <p>MCP integration works with publicly accessible MCP servers. Register a server once, and all its tools become available across your workflows. See MCP Server Integration for registration and usage details.</p>"},{"location":"extensibility/overview.html#custom-actions","title":"Custom Actions","text":"<p>Custom Actions define new operations that function like built-in FlowRunner\u2122 actions. Build Custom Actions when you need to integrate with third-party APIs or external services, execute complex business logic specific to your application, create reusable operations across multiple workflows, or encapsulate domain-specific functionality.</p> <p>Custom Actions can be built using AI coding assistant or JavaScript (Node.js). Once developed, these actions appear in the Block List panel and can be added to any flow.</p>"},{"location":"extensibility/overview.html#custom-triggers","title":"Custom Triggers","text":"<p>Custom Triggers define events or conditions that pause workflow execution until activated. Unlike standard triggers that only start workflows, Custom Triggers can be placed anywhere in a flow. Use Custom Triggers to trigger workflows based on external events (webhooks, system events), pause and resume workflows at specific points, handle application-specific events tied to your business logic, or wait for user actions or external system state changes.</p> <p>Custom Triggers can be reused across multiple workflows and placed at any execution point where conditional pausing is needed.</p>"},{"location":"extensibility/overview.html#choosing-an-extension-method","title":"Choosing an Extension Method","text":"<p>Select the appropriate extension method based on your requirements:</p> <p>Use MCP Server Integration when:</p> <ul> <li>Tools already exist on an MCP server</li> <li>You need to integrate external services that provide MCP endpoints</li> <li>You want to leverage the MCP ecosystem without writing code</li> <li>Multiple workflows need access to the same external tools</li> </ul> <p>Use Custom Actions when:</p> <ul> <li>You need application-specific business logic</li> <li>Integration requires custom authentication or data transformation</li> <li>Functionality is specific to your FlowRunner\u2122 instance</li> <li>You want to create proprietary operations</li> </ul> <p>Use Custom Triggers when:</p> <ul> <li>Workflows must pause for external events</li> <li>You need conditional execution based on application state</li> <li>Standard triggers don't match your event model</li> <li>User interaction or approval is required mid-workflow</li> </ul>"},{"location":"extensibility/overview.html#extension-development","title":"Extension Development","text":"<p>The <code>EXTEND</code> section provides comprehensive documentation for building custom extensions. Topics include custom actions (defining new operations with configurable parameters), service configuration (adding authentication and connection settings), OAuth2 authorization (implementing OAuth2 flows for third-party services), no-code development (building actions using Codeless), JavaScript development (building actions using Node.js), dictionary operations (creating actions with dynamic parameter options), and parameter rendering (configuring how parameters appear in the UI).</p> <p>Start with the appropriate development guide based on your preferred approach (Codeless or JavaScript) and the complexity of your custom extension.</p>"},{"location":"extensibility/parameter-ui-types.html","title":"Parameter Rendering","text":"<p>When defining an action in a FlowRunner\u2122 extension, you can control how each parameter appears in the Flow Editor\u2019s configuration panel using the <code>@paramDef</code> annotation. This annotation defines the parameter\u2019s data type, label, and additional UI rendering options.</p> <p>By default, parameters are rendered as input fields that integrate with the Expression Editor. However, you can customize how a parameter is displayed by specifying a UI component using the <code>uiComponent</code> property inside the <code>@paramDef</code>.</p> <p>This allows you to render checkboxes, dropdowns, date pickers, and other input types to match the nature of the parameter.</p>"},{"location":"extensibility/parameter-ui-types.html#example","title":"Example","text":"<p>The sample below demonstrates how to declare parameters with various supported UI components. Scroll horizontally to see all <code>@paramDef</code> declarations:</p> <pre><code>/**\n * @description Demonstrates all supported FlowRunner\u2122 UI input types using @paramDef annotations.\n *\n * @route POST /demoUiTypes\n * @operationName Demo: UI Input Types\n *\n * @appearanceColor #808080 #A9A9A9\n *\n * @executionTimeoutInSeconds 60\n *\n * @paramDef {\"type\":\"Boolean\",\"label\":\"Checkbox Option\",\"name\":\"checkboxOption\",\"required\":false,\"description\":\"A boolean input using a checkbox.\",\"uiComponent\":{\"type\":\"CHECKBOX\"}}\n * @paramDef {\"type\":\"Boolean\",\"label\":\"Toggle Option\",\"name\":\"toggleOption\",\"required\":false,\"description\":\"A boolean input using a toggle switch.\",\"uiComponent\":{\"type\":\"TOGGLE\"}}\n * @paramDef {\"type\":\"Number\",\"label\":\"Numeric Input\",\"name\":\"numericInput\",\"required\":false,\"description\":\"A number input using a plain numeric field.\",\"uiComponent\":{\"type\":\"NUMERIC\"}}\n * @paramDef {\"type\":\"Number\",\"label\":\"Numeric Stepper\",\"name\":\"numericStepper\",\"required\":false,\"description\":\"A number input with a stepper UI.\",\"uiComponent\":{\"type\":\"NUMERIC_STEPPER\"}}\n * @paramDef {\"type\":\"Number\",\"label\":\"Date Picker\",\"name\":\"datePicker\",\"required\":false,\"description\":\"A date input that returns a timestamp.\",\"uiComponent\":{\"type\":\"DATE_PICKER\"}}\n * @paramDef {\"type\":\"Number\",\"label\":\"Date Time Picker\",\"name\":\"dateTimePicker\",\"required\":false,\"description\":\"A date/time input that returns a timestamp.\",\"uiComponent\":{\"type\":\"DATE_TIME_PICKER\"}}\n * @paramDef {\"type\":\"String\",\"label\":\"Dropdown Option\",\"name\":\"dropdownOption\",\"required\":false,\"description\":\"A dropdown input with predefined values.\",\"uiComponent\":{\"type\":\"DROPDOWN\", \"options\":{\"values\":[\"Option A\", \"Option B\", \"Option C\"]}}}\n * @paramDef {\"type\":\"String\",\"label\":\"Multiline Text\",\"name\":\"multiLineText\",\"required\":false,\"description\":\"A multi-line text area for long strings.\",\"uiComponent\":{\"type\":\"MULTI_LINE_TEXT\"}}\n * @paramDef {\"type\":\"String\",\"label\":\"Single Line Text\",\"name\":\"singleLineText\",\"required\":false,\"description\":\"A single-line text input field.\",\"uiComponent\":{\"type\":\"SINGLE_LINE_TEXT\"}}\n * @paramDef {\"type\":\"String\",\"label\":\"File Selector\",\"name\":\"fileSelector\",\"required\":false,\"description\":\"A file selector from Backendless Files.\",\"uiComponent\":{\"type\":\"FILE_SELECTOR\"}}\n *\n * @sampleReturn {\"success\":true}\n */\nasync demoUiTypes(\n  checkboxOption,\n  toggleOption,\n  numericInput,\n  numericStepper,\n  datePicker,\n  dateTimePicker,\n  dropdownOption,\n  multiLineText,\n  singleLineText,\n  fileSelector\n) {\n  // Demo only - implementation intentionally left empty\n}\n</code></pre> <p>When used in FlowRunner\u2122, the parameters appear in the UI with appropriate input types: </p>"},{"location":"extensibility/parameter-ui-types.html#supported-ui-components","title":"Supported UI Components","text":"<p>Below is a summary of all supported <code>uiComponent.type</code> values and their expected behavior:</p> UI Component Parameter Type Description Required Options <code>CHECKBOX</code> <code>Boolean</code> Displays a checkbox input. None <code>TOGGLE</code> <code>Boolean</code> Displays a toggle switch. None <code>NUMERIC</code> <code>Number</code> Displays a plain number input field. None <code>NUMERIC_STEPPER</code> <code>Number</code> Displays a number input with increment/decrement buttons. None <code>DATE_PICKER</code> <code>Number</code> Displays a calendar input. Returns a timestamp (milliseconds). None <code>DATE_TIME_PICKER</code> <code>Number</code> Displays a combined date and time selector. Returns a timestamp. None <code>DROPDOWN</code> <code>String</code> Displays a dropdown list with predefined options. <code>values</code> (array of strings) <code>MULTI_LINE_TEXT</code> <code>String</code> Displays a textarea for long-form input. None <code>SINGLE_LINE_TEXT</code> <code>String</code> Displays a single-line text input. None <code>FILE_SELECTOR</code> <code>String</code> Opens a file browser for selecting a file from Backendless Files. Returns file path. None"},{"location":"extensibility/parameter-ui-types.html#notes","title":"Notes","text":"<ul> <li>All UI components still support the Expression Editor, unless the field is restricted by type (for example, toggles and checkboxes).</li> <li>The <code>DROPDOWN</code> type requires a list of <code>values</code>, provided in the <code>options</code> property.</li> <li>The <code>TIME_PICKER</code> type is not currently implemented and should be avoided for now.</li> </ul>"},{"location":"extensibility/parameter-ui-types.html#required-vs-optional-parameters","title":"Required vs Optional Parameters","text":"<p>Every <code>@paramDef</code> includes a <code>required</code> property. This flag determines whether the user must provide a value for the parameter in the FlowRunner\u2122 UI.</p> <ul> <li>If <code>required</code> is set to <code>true</code>, the field is marked as mandatory. FlowRunner\u2122 will prevent the user from running the flow until a value is provided.</li> <li>If <code>required</code> is <code>false</code>, the input is optional, and the user may leave it blank.</li> </ul> <p>This distinction is especially important when using inputs like dropdowns or toggles. Make sure your action code/logic accounts for optional parameters by including conditional checks in your implementation.</p>"},{"location":"extensibility/parameter-ui-types.html#dictionary-arguments","title":"Dictionary Arguments","text":"<p>If you need to render a list of options that are not static, but instead retrieved from an API or depend on other values in the flow, use a dictionary argument instead of a predefined dropdown.</p> <p>Dictionary arguments allow your parameter to be powered by a custom function that dynamically fetches the list of options at runtime.</p> <p>For example, you might use a dictionary to: - Let the user select a Slack channel from their workspace - Display available Airtable bases or Google Sheets tabs - Retrieve filtered items from an external API</p> <p>To learn more, see the Developing an Action with Dictionary Arguments chapter.</p>"},{"location":"extensibility/service-config.html","title":"Service Configuration Parameters","text":"<p>When building an API service, it's important to make it flexible so it can work in different scenarios. For example, imagine you're creating a service that integrates with an FTP server. This service could allow file uploads and downloads, changing directories, and retrieving directory listings. To perform these tasks, the service needs to connect to the FTP server. But instead of hardcoding the server details into the service itself, you can make the service more reusable by allowing configuration of the FTP server information.</p> <p>This is where Service Configuration Parameters come into play. These parameters let you, or anyone using your service, enter specific details like the server's address, login credentials, or other settings. This flexibility allows the service to be used with any FTP server, not just a predefined one. Whether you're building the service for yourself or sharing it through the Backendless Marketplace, configuration parameters ensure that the service can adapt to different environments.</p>"},{"location":"extensibility/service-config.html#declaring-config-parameters","title":"Declaring Config Parameters","text":"<p>You can declare configuration parameters when you first create a Codeless service in the Backendless Console. </p> <p></p> <p>However, if you didn\u2019t set them up during creation, you can always add or modify them later by accessing the Service Configuration popup.</p> <p></p> <p>To declare a new configuration parameter, click ADD NEW. When you add parameters after the service is created, the system will automatically generate a form where the required values can be entered. This form is dynamically built, reflecting the attributes of the parameters you define.</p> <p></p> <p>Each configuration parameter includes a few key attributes:</p> <ul> <li>Label: This is the name that will be displayed next to the input field, letting users know what data to enter.</li> <li>Hint/Tooltip: You can provide additional context by adding a tooltip. This will display a help icon next to the field, offering more information when users hover over it.</li> <li>Data Type: This determines how the input field will appear. For example, it could be a text box, a checkbox, or a date picker, depending on what kind of data the parameter requires.</li> <li>Default Value: You can specify a default value, which will automatically fill the field unless another value is provided.</li> </ul> <p>If certain parameters are crucial to the service, you can mark them as required. This ensures that users must provide a value for these fields before they can proceed. You can also reorder the parameters by dragging them with the burger icon, making it easier to customize how the form looks and functions.</p>"},{"location":"extensibility/service-config.html#choosing-the-right-data-type","title":"Choosing the Right Data Type","text":"<p>The data type for each parameter is important because it defines the kind of input the user will provide. Backendless offers several options, allowing you to choose the best match for the data being requested:</p> <ul> <li>Single Line Text: Displays a single input field. This is ideal for strings, numbers, or alphanumeric entries.</li> <li>Checkbox: Offers a simple true or false option.</li> <li>Date: Presents a date and time picker, which is perfect for scheduling or time-based data.</li> <li>Select: Creates a dropdown list where the user can select from predefined options.</li> <li>Multi Line Text: Gives a larger input area for longer text entries.</li> </ul> <p></p> <p>For the Select data type, you will see an additional component where you can define all possible options for the drop-down: </p> <p>When you click the change options button, you will see a popup where you can define the options for the config parameter: </p> <p>The data type you choose should match the kind of information your service needs, ensuring that the input is both practical and user-friendly.</p>"},{"location":"extensibility/service-config.html#config-parameters-in-flowrunner","title":"Config Parameters in FlowRunner","text":"<p>If any of your service operations are marked as FlowRunner\u2122 Actions, users will be able to configure the service directly within FlowRunner\u2122. When they add a service action to a flow, they\u2019ll see a Configure button, which opens up the form with the configuration parameter fields. This makes it easy to set or update the service's configuration right in the flow, ensuring that the correct settings are applied without needing to leave the FlowRunner\u2122 environment.</p> <p></p> <p>Note</p> <p>It\u2019s important to note that provided configuration values apply across the entire service, meaning all operations within the service will use the same set of configuration values.</p>"},{"location":"extensibility/service-config.html#accessing-config-data-in-logic","title":"Accessing Config Data in Logic","text":"<p>Once you've declared configuration parameters, they can easily be accessed in your Codeless logic. The Codeless editor includes special blocks that let you retrieve the value of any configuration parameter. To use it, simply drag the block into your logic and choose the specific parameter from a dropdown list. This makes it straightforward to integrate the provided configuration data into your service's operations, allowing the service to work dynamically with user-defined values. </p>"},{"location":"extensibility/service-config.html#configuration-and-the-marketplace","title":"Configuration and the Marketplace","text":"<p>If you're planning to share your service through the Backendless Marketplace, configuration parameters are an essential part of making your service user-friendly. When someone installs your service, they\u2019ll be prompted to complete the configuration form during the installation process. This ensures that the service is properly set up from the beginning, allowing it to run smoothly without additional setup.</p> <p>Once installed, users can always revisit the configuration settings. They can do this by opening the Service Configuration popup from the API Services section or by using the Configure button in FlowRunner\u2122. This ongoing flexibility allows users to adjust the service to their needs at any time, making your service adaptable and easy to use in various environments.</p>"},{"location":"extensibility/setup-node-env.html","title":"Development Environment Setup","text":"<p>You can develop custom FlowRunner\u2122 extensions using Node.js either locally on your workstation or directly within Backendless Console. We recommend setting up a local development environment for maximum flexibility and control. A local setup allows you to debug your FlowRunner\u2122 extensions before deploying them, manage dependencies (such as additional Node.js npm modules), and streamline your workflow.  </p> <p>However, in some situations, it may be helpful to use the fully cloud-hosted environment within Backendless Console to make quick adjustments. This guide explains how to set up both approaches, starting with the recommended local setup.</p>"},{"location":"extensibility/setup-node-env.html#local-environment-setup","title":"Local Environment Setup","text":"<p>To begin, navigate to the API Services screen in Backendless.</p> <p>Finding the API Services screen</p> <p>If you do not see the API Services icon in the sidebar, click the QUICK ACCESS button in the upper-left corner of the console and search for \"API Services.\" Click API Services to open the screen. You can also click the  icon to pin it to the sidebar.  </p>"},{"location":"extensibility/setup-node-env.html#creating-a-new-service","title":"Creating a New Service","text":"<p>On the API Services screen, click the  icon to create a new API Service. </p> <p>When the New API Service popup appears, it defaults to CODELESS. Switch to the JS tab. The default selection is Build From Scratch. Keep this option unless your extension requires OAuth2 authentication. In that case, select With OAuth2 Authorization and refer to the OAuth2 Authorization guide for more details.</p> <p>In the Service Class Name field, enter <code>NewsAPI</code>. This naming will align with later tutorials. The name will also auto-fill the FlowRunner\u2122 Extension Name field, which will be used to identify your extension in FlowRunner\u2122 Marketplace and within the list of custom FlowRunner\u2122 extensions.</p> <p>The service icon is optional for development but required if you plan to submit your extension to the Marketplace. The icon can also be configured at the source code level of your implementation.</p> <p></p> <p>Click SAVE to create the service.</p>"},{"location":"extensibility/setup-node-env.html#accessing-the-service-code","title":"Accessing the Service Code","text":"<p>At this point, the service has been created, but it does not yet include any operations. Next, you will access the service's source code. Navigate to the Coding screen by clicking QUICK ACCESS, searching for coding, and selecting Coding located under Cloud Code: </p>"},{"location":"extensibility/setup-node-env.html#download-project-archive","title":"Download Project Archive","text":"<p>In Cloud Code Coding, make sure the following selections are made:</p> <ul> <li>Choose JS in the Language dropdown.</li> <li>Select NewsAPI in the Model dropdown.</li> </ul> <p>Note</p> <p>Each API Service you create automatically generates a corresponding \"model\" with the same name as the service class. For now, you can treat this as an internal detail.</p> <p>Expand the NewsAPI folder to reveal index.js, then click the file to open it. The file contains a basic service scaffold: </p> <p>Although Cloud Code Coding includes a built-in editor and deployment options, you will now focus on setting up your local environment. To do this, click Download Project: </p>"},{"location":"extensibility/setup-node-env.html#project-contents","title":"Project Contents","text":"<p>The downloaded ZIP archive contains:</p> <ul> <li>Project configuration files</li> <li>Necessary dependencies, including CodeRunner, a command-line tool for testing and deploying services</li> <li>The service\u2019s source code</li> </ul> <p>Extract the archive into a directory on your workstation. For consistency, this documentation refers to this directory as <code>[BASE_DIR]</code>.</p>"},{"location":"extensibility/setup-node-env.html#installing-prerequisites","title":"Installing Prerequisites","text":"<p>Before continuing, ensure Node.js and NPM are installed on your system with the following minimum versions:</p> <ul> <li>Node.js version 18.20.6 or higher</li> <li>NPM version 10.8.2 or higher</li> </ul>"},{"location":"extensibility/setup-node-env.html#installing-project-dependencies","title":"Installing Project Dependencies","text":"<p>Open a terminal or command prompt and navigate to [BASE_DIR]. Run the following command to install all required components:</p> <pre><code>npm i\n</code></pre> <p>Your local development environment is now ready for building and testing FlowRunner\u2122 extensions.</p>"},{"location":"extensibility/setup-node-env.html#remote-environment-setup","title":"Remote Environment Setup","text":"<p>You briefly visited the Coding section earlier to download the project archive. The Coding screen also provides a full browser-based environment where you can manage your project files and edit code directly. </p>"},{"location":"extensibility/setup-node-env.html#working-with-the-file-tree","title":"Working with the File Tree","text":"<p>The Coding screen includes a folder and file tree where you can create, move, and delete project files and folders. To open the context menu, right-click within the file tree: </p> <p>You can also use drag-and-drop to move files and folders within the tree.</p>"},{"location":"extensibility/setup-node-env.html#using-the-toolbar","title":"Using the Toolbar","text":"<p>A toolbar at the top of the screen gives you quick access to essential project operations: </p> <p> - Save the project to the server without deploying it. This stores your code but does not make it live.</p> <p> - Save and deploy the project. Deployment activates the latest code changes.</p> <p> - Download the project archive to your local machine.</p>"},{"location":"flow-editing/blocknaming.html","title":"Naming Your Blocks","text":"<p>Block names in FlowRunner\u2122 play a crucial role in maintaining clarity and understanding within your workflows. Assigning meaningful, context-specific names helps align blocks with your business processes, making workflows easier to navigate, understand, and maintain.  </p>"},{"location":"flow-editing/blocknaming.html#contextual-naming","title":"Contextual Naming","text":"<p>Pre-defined block names describe generic functions, but they may not reflect the specifics of your business operations. Renaming blocks to fit their role in your workflow improves clarity.  </p> <p>For example:  </p> <ul> <li>Rename Save Record in Database to Save Customer Details to highlight its purpose.  </li> <li>Update Condition to Has the Customer Ordered from Us Before? for immediate context.  </li> </ul> <p>Meaningful names make it easier for you and your team to understand a workflow at a glance. </p>"},{"location":"flow-editing/blocknaming.html#using-the-name-property","title":"Using the <code>Name</code> Property","text":"<p>Each block includes a Name property that allows for customization. Assigning descriptive names as soon as you place blocks on the canvas is a best practice. This ensures your workflow is intuitive and reflects your business processes clearly.  </p> <p>Naming blocks isn\u2019t just about aesthetics - it\u2019s essential for creating workflows that are clear, maintainable, and aligned with your business objectives. Thoughtful naming ensures workflows are accessible to your team, accurately represent your processes, and support effective automation.  </p>"},{"location":"flow-editing/communicate-with-ui.html","title":"Bidirectional Communication with UI","text":"<p>Bidirectional communication between a UI and a FlowRunner\u2122 flow allows real-time interaction by leveraging Backendless' real-time messaging feature. This technique enables flows to send data back to a UI page during execution, creating dynamic, responsive experiences. While not a built-in feature, it is achievable using FlowRunner\u2122 and Backendless UI Builder.  </p> <p>In this chapter, we\u2019ll explore how to establish this connection and implement real-time updates from a flow to a UI.  </p>"},{"location":"flow-editing/communicate-with-ui.html#technique-overview","title":"Technique Overview","text":"<p>The communication setup is based on real-time messaging channels:  </p> <pre><code>sequenceDiagram\n    participant UI as UI Page\n    participant Backendless as Backendless\n    participant Flow as FlowRunner\u2122 Flow\n\n    UI-&gt;&gt;Backendless: Start Flow (Call Flow)\n    Backendless-&gt;&gt;Flow: Initialize Flow Instance\n    Flow--&gt;&gt;Backendless: Return Execution ID\n    Backendless--&gt;&gt;UI: Execution ID (executionId)\n\n    Note over UI: Establish Real-Time Channel&lt;br&gt;using executionId\n    UI-&gt;&gt;Backendless: Subscribe to Real-Time Channel (executionId)\n\n    Flow-&gt;&gt;Backendless: Send Data to Channel\n    Backendless--&gt;&gt;UI: Deliver Message to Channel\n\n    Note over UI: Process Received Data</code></pre> <ul> <li>When a UI page loads, it starts a new flow instance and establishes a real-time channel tied to the flow\u2019s unique execution ID.  </li> <li>The flow sends data back to the channel using the Send Data to UI extension from the Marketplace.  </li> <li>The UI listens for messages on the same channel, processing data as it arrives.  </li> </ul> <p>This interaction allows a seamless exchange of data, ideal for building dynamic applications such as chat interfaces, live dashboards, or progress monitors.  </p>"},{"location":"flow-editing/communicate-with-ui.html#implementation-steps","title":"Implementation Steps","text":""},{"location":"flow-editing/communicate-with-ui.html#start-the-flow-from-ui","title":"Start the Flow from UI","text":"<p>When the UI page loads, the first step is to start the flow and use the flow identifier to create a real-time communication channel.  </p> <p>Navigate to the On Before Page Enter event for your UI page. This event ensures the logic runs as soon as the page starts loading:  </p> <p> </p> <p>Use a Call Flow Codeless block to initiate the flow. This block is specific to the flow you want to start and can be found in the flow\u2019s dedicated menu in the Codeless toolbox:  </p> <p></p> <p>Once the flow is started, its executionId (unique flow instance ID) is a part of the returned object. Merge this ID into the page\u2019s <code>PageData</code> for later use:  </p> <p></p>"},{"location":"flow-editing/communicate-with-ui.html#create-a-real-time-listener","title":"Create a Real-Time Listener","text":"<p>With the flow running, the next step is to establish a real-time listener on the UI to receive messages from the flow. The Codeless blocks enabling real-time messaging are available under the Real Time API category. The block used in this solution is called Add RT Message Listener with id:</p> <p></p> <p>In your page\u2019s logic, which can be anywhere/anytime after the <code>Call Flow</code> block , create a Real-Time Message Listener that listens on the channel named after the flow\u2019s <code>executionId</code>.  </p> <p></p>"},{"location":"flow-editing/communicate-with-ui.html#process-incoming-data","title":"Process Incoming Data","text":"<p>When a message is received, it will be available in the <code>message</code> variable. The flow\u2019s data will be accessible in the <code>message</code> property, ready for use in your page.  </p> <p></p>"},{"location":"flow-editing/communicate-with-ui.html#send-data-from-flow","title":"Send Data from Flow","text":"<p>On the flow side, use the Send Data to UI extension to send data to the established real-time channel. Open the Marketplace in FlowRunner\u2122: </p> <p></p> <p>Install the Send Data to UI extension: </p> <p></p> <p>Drag the Send Data to UI action into your flow. </p> <p></p> <p>Configure its Data parameter with any value available in the flow\u2014this can include action results, variables, or transformed data.  </p> <p></p> <p>When the flow executes this block, it sends the data to the real-time channel tied to the flow\u2019s <code>executionId</code>.  </p>"},{"location":"flow-editing/communicate-with-ui.html#sample-flow","title":"Sample Flow","text":"<p>For a hands-on demonstration of the technique described in this chapter, explore the AI Chatbot sample flow. This flow, along with its corresponding sample page, offers an out-of-the-box example of bidirectional communication between FlowRunner\u2122 and a UI.  </p> <p>The sample flow showcases how real-time updates from a flow to a UI can be implemented effectively, providing a clear starting point for applying this technique to your own projects.  </p> <p> </p> <p>Bidirectional communication with FlowRunner\u2122 and Backendless UI opens up exciting possibilities for real-time, interactive applications. By combining flows, real-time messaging, and dynamic UI updates, you can build powerful systems that respond instantly to user and backend activities. Let me know if further examples or refinements are needed!  </p>"},{"location":"flow-editing/conditions.html","title":"Conditional Logic","text":"<p>Conditional logic in FlowRunner\u2122 allows you to create decision points within your automation, directing the flow based on specific conditions. Think of it as a fork in the road where the flow will follow one path if the condition is met (yes) and a different path if it is not (no). For instance, your flow might take different actions depending on whether it is a weekend or a weekday.</p> <p>At the heart of every condition is a question that results in a \"yes\" or \"no\" answer. Here are some examples:</p> <ul> <li>Does the order have priority shipping?</li> <li>Is this a returning customer?</li> <li>Is the current time within business hours?</li> </ul>"},{"location":"flow-editing/conditions.html#building-condition-logic","title":"Building Condition Logic","text":"<p>Conditions can be integrated into various areas of your flow, including triggers and the dedicated <code>Condition</code> block. Configuring a condition involves building a logical expression that must evaluate to either <code>true</code> or <code>false</code>. </p>"},{"location":"flow-editing/conditions.html#single-condition-check","title":"Single Condition Check","text":"<p>A single condition check performs one evaluation against a specific value. For example:</p> <ul> <li>Is variable <code>X</code> greater than 5?</li> <li>Does a string in a result element contain the word <code>\"urgent\"</code>?</li> </ul> <p>When you configure a single condition check, you need to specify the following parameters:</p> <ol> <li>Value to Check: This is the value that will be evaluated. You use the Expression Editor to select this value. It can be any value obtained through the Expression Editor.</li> <li>Value Data Type: This indicates the data type of the value selected in the <code>Value to Check</code> field. The operations available depend on the data type. For instance, if the data type is <code>STRING</code>, operations like <code>STARTS WITH</code>, <code>CONTAINS</code>, and <code>ENDS WITH</code> will be available. If the data type is <code>INT</code>, the operations will include <code>GREATER THAN</code>, <code>LESS THAN</code>, etc.</li> <li>Operation: This is the function to be performed against the value specified in the Value to Check parameter. Most operations require an additional value.</li> <li>Additional Fields: These appear dynamically based on the selected operation. For example, comparison operations include a Value field that supports the Expression Editor for dynamic values.</li> </ol> <p>Consider the examples below:</p> <ol> <li> <p>Check if the <code>Order Status Result</code> element's value equals the word <code>PROCESSED</code>:</p> <p></p> </li> <li> <p>Check if the <code>Products Purchased Result</code> element's value is greater than 10:</p> <p></p> </li> </ol>"},{"location":"flow-editing/conditions.html#multiple-condition-checks","title":"Multiple Condition Checks","text":"<p>When you add more than one condition check, FlowRunner\u2122 labels them as \"Part A,\" \"Part B,\" and so on. These parts are connected using <code>AND</code> and <code>OR</code> operators to create complex logical expressions.</p> <p>Consider the example below. At the bottom of the screenshot, you will see how the parts are connected to create the final logical expression for the condition:</p> <p></p> <p>Clicking the <code>AND</code> operator changes it to <code>OR</code> and vice versa. FlowRunner\u2122 uses conventional boolean logic with these operators. Each part is evaluated and results in either <code>TRUE</code> or <code>FALSE</code>. The following rules apply:</p> <pre><code>TRUE AND TRUE = TRUE\nTRUE AND FALSE = FALSE\nTRUE OR TRUE = TRUE\nTRUE OR FALSE = TRUE\nFALSE AND FALSE = FALSE\nFALSE OR FALSE = FALSE\n</code></pre> <p>For expressions with three or more parts, you can assign precedence in the expression evaluation using parentheses. Anything in parentheses is evaluated first. Consider the following example with three parts:</p> <p></p> <p>The parts in the condition are organized in the following expression:</p> <p></p> <p>It may be ambiguous how the expression will be evaluated if any part is <code>FALSE</code>. To clarify, you can group parts using parentheses.</p> <p>Adding Parentheses</p> <p>To add a parenthesis, simply click in the space between the parts and the <code>AND</code>/<code>OR</code> operators.</p> <p>Once parentheses are present, it is easier to understand how the expression will be evaluated. The following two examples produce different results depending on how individual parts are evaluated:</p> <p></p> <p>or</p> <p></p>"},{"location":"flow-editing/conditions.html#available-operations-by-data-type","title":"Available Operations by Data Type","text":"<p>The following tables show all available operations for each Value Data Type and their additional configuration requirements:</p>"},{"location":"flow-editing/conditions.html#string-operations","title":"STRING Operations","text":"Operation Description Additional Fields <code>EQUALS</code> Compare exact string values Value (Expression Editor) <code>DOES NOT EQUAL</code> Compare exact string values Value (Expression Editor) <code>CONTAINS</code> Check if string contains substring Value (Expression Editor) <code>DOES NOT CONTAIN</code> Check if string contains substring Value (Expression Editor) <code>STARTS WITH</code> Check string prefix Value (Expression Editor) <code>DOES NOT START WITH</code> Check string prefix Value (Expression Editor) <code>ENDS WITH</code> Check string suffix Value (Expression Editor) <code>DOES NOT END WITH</code> Check string suffix Value (Expression Editor) <code>IS EMPTY</code> Check if string has no content None <code>IS NOT EMPTY</code> Check if string has content None <code>IS NULL</code> Check if value doesn't exist None <code>IS NOT NULL</code> Check if value exists None"},{"location":"flow-editing/conditions.html#int-and-double-operations","title":"INT and DOUBLE Operations","text":"Operation Description Additional Fields <code>EQUALS</code> Compare numeric values Value (Expression Editor) <code>DOES NOT EQUAL</code> Compare numeric values Value (Expression Editor) <code>GREATER THAN</code> Compare magnitude Value (Expression Editor) <code>LESS THAN</code> Compare magnitude Value (Expression Editor) <code>GREATER OR EQUAL</code> Compare with equality Value (Expression Editor) <code>LESS OR EQUAL</code> Compare with equality Value (Expression Editor)"},{"location":"flow-editing/conditions.html#boolean-operations","title":"BOOLEAN Operations","text":"Operation Description Additional Fields <code>IS NULL</code> Check if value doesn't exist None <code>IS NOT NULL</code> Check if value exists None <code>IS TRUE</code> Check true state None <code>IS NOT TRUE</code> Check true state None <code>IS FALSE</code> Check false state None <code>IS NOT FALSE</code> Check false state None"},{"location":"flow-editing/conditions.html#datetime-operations","title":"DATETIME Operations","text":"Operation Description Additional Fields <code>IS</code> Compare with specific dates Date Type dropdown<sup>1</sup> <code>IS NOT</code> Compare with specific dates Date Type dropdown<sup>1</sup> <code>BEFORE</code> Compare chronological order Date Type dropdown<sup>1</sup> <code>AFTER</code> Compare chronological order Date Type dropdown<sup>1</sup> <code>AT OR BEFORE</code> Include equality in comparison Date Type dropdown<sup>1</sup> <code>AT OR AFTER</code> Include equality in comparison Date Type dropdown<sup>1</sup> <code>WITHIN</code> Check if date falls within time period Time Period dropdown<sup>2</sup> <code>NOT WITHIN</code> Check if date falls within time period Time Period dropdown<sup>2</sup>"},{"location":"flow-editing/conditions.html#image-operations","title":"IMAGE Operations","text":"Operation Description Additional Fields All STRING operations Same as STRING data type Same as STRING <code>AI QUESTION</code> Ask AI a yes/no question about image Yes/No Question (Expression Editor) <p>AI Image Analysis</p> <p>The AI QUESTION operation sends the image URL and your question to AI, which automatically responds with a boolean answer to control the condition outcome.</p>"},{"location":"flow-editing/conditions.html#json-object-operations","title":"JSON OBJECT Operations","text":"Operation Description Additional Fields <code>IS EMPTY</code> Check if object has no properties None <code>HAS KEY</code> Check if specific key exists Key (Expression Editor) <code>HAS KEY WITH VALUE</code> Check key exists with specific value Key, Value (both Expression Editor) <code>HAS SPECIFIC TYPE</code> Check if key contains specific data type Key (Expression Editor), Type dropdown<sup>3</sup>"},{"location":"flow-editing/conditions.html#json-array-operations","title":"JSON ARRAY Operations","text":"Operation Description Additional Fields <code>IS EMPTY</code> Check if array has no elements None <code>CONTAINS VALUE</code> Check if array contains specific value Value (Expression Editor) <code>LENGTH GREATER THAN</code> Compare array size Value (Expression Editor) <code>LENGTH LESS THAN</code> Compare array size Value (Expression Editor) <code>LENGTH GREATER THAN OR EQUALS</code> Compare with equality Value (Expression Editor) <code>LENGTH LESS THAN OR EQUALS</code> Compare with equality Value (Expression Editor) <code>LENGTH EQUALS</code> Check exact array size Value (Expression Editor) <code>ALL ELEMENTS OF TYPE</code> Verify all elements match data type Type dropdown<sup>3</sup> <code>ELEMENT AT INDEX EQUALS</code> Check specific array position value Index, Value (both Expression Editor) <code>ALL ELEMENTS NOT NULL</code> Verify no null elements None <code>ALL ELEMENTS MEET CONDITION</code> Check all elements against condition Nested condition configuration<sup>4</sup> <code>SOME ELEMENTS MEET CONDITION</code> Check if any elements meet condition Nested condition configuration<sup>4</sup>"},{"location":"flow-editing/conditions.html#error-handling","title":"Error Handling","text":"<p>Conditions can encounter various error scenarios that you should be prepared to handle:</p> <p>Invalid Property References: When a property reference is invalid or missing, FlowRunner\u2122 generates an error. For error handling purposes, the Condition block can be connected to a Handle Error block to manage these scenarios gracefully.</p> <p>Data Type Mismatches: If the actual data type doesn't match the selected Value Data Type, FlowRunner\u2122 attempts to auto-guess the type and perform data conversion. This automatic conversion helps maintain flow continuity but may not always produce expected results.</p> <p>Network Errors: Network errors are possible only with the AI operation when processing IMAGE data types. In such cases, FlowRunner\u2122 generates an error that can be handled through standard error handling mechanisms.</p> <p>Best Practices for Error Prevention: - Validate property paths before using them in conditions - Use appropriate null checks when working with optional data - Test conditions with various data scenarios during development - Implement error handling paths for critical decision points</p>"},{"location":"flow-editing/conditions.html#best-practices","title":"Best Practices","text":""},{"location":"flow-editing/conditions.html#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Keep complex conditions as simple as possible while maintaining accuracy</li> <li>Use specific data types rather than relying on auto-conversion</li> <li>Consider breaking very complex conditions into multiple simpler Condition blocks</li> <li>Place more likely conditions first in OR expressions to short-circuit evaluation</li> </ul>"},{"location":"flow-editing/conditions.html#condition-design-strategy","title":"Condition Design Strategy","text":"<ul> <li>Use descriptive property names and clear comparison values</li> <li>Group related logical parts using parentheses for clarity</li> <li>Document complex condition logic with descriptive block names</li> <li>Test edge cases and boundary conditions thoroughly</li> </ul>"},{"location":"flow-editing/conditions.html#debugging-complex-conditions","title":"Debugging Complex Conditions","text":"<ul> <li>Test individual condition checks before combining them into parts</li> <li>Use simple test data to verify condition logic</li> <li>Add temporary logging or outputs to track condition evaluation</li> <li>Break complex conditions into smaller, testable components</li> </ul>"},{"location":"flow-editing/conditions.html#condition-block","title":"Condition Block","text":"<p>The <code>Condition</code> block allows you to set up a logical expression and then branches the flow into two paths: <code>Yes</code> and <code>No</code>. If the expression evaluates to <code>true</code>, the flow follows the <code>Yes</code> branch. Otherwise, it follows the <code>No</code> branch. </p> <p></p>"},{"location":"flow-editing/conditions.html#example-flow","title":"Example Flow","text":"<p>Consider a scenario where you want the flow to behave differently based on whether it is a weekend or a weekday. You can set up a condition that checks the current day of the week:</p> <p></p> <p>The <code>Condition</code> block in this example uses the following logic:</p> <p></p> <p>This logic checks if the <code>Week Day Number</code> value is either Saturday (value <code>6</code>) or Sunday (value <code>7</code>). Based on this check, the flow can take different actions.</p> <ul> <li>On Weekends - when <code>Week Day Number</code> is greater or equal <code>6</code>: You might want the flow to send an alert to the team informing them of weekend activity, or perhaps delay certain non-urgent processes until Monday.</li> <li>On Weekdays - for all other values stored in <code>Week Day Number</code>: The flow could continue with regular processing, such as sending orders to the shipping department or performing routine updates.</li> </ul> <p>The <code>Condition</code> block is highly versatile, enabling you to create complex logical expressions. These expressions can include multiple parts combined using <code>AND</code> and <code>OR</code> operators. Additionally, the <code>Condition</code> block can handle various data types, making it a powerful tool for building sophisticated decision-making processes within your flows. </p> <p>For a detailed overview of the <code>Condition</code> block's capabilities, refer to the Condition Block chapter in the Block Reference section of this guide.</p>"},{"location":"flow-editing/conditions.html#conditions-with-triggers","title":"Conditions with Triggers","text":"<p>All built-in FlowRunner\u2122 triggers can be enhanced with a condition that acts as a \"filter\". These conditions follow the same rules described above for configuring logical expressions. When a trigger has an associated condition, it will only be activated if the condition evaluates to <code>TRUE</code>. This ensures that your flows only proceed under the specific circumstances you define, adding an extra layer of precision and control to your automation processes.</p> <p>By organizing your conditions effectively, you can create complex and precise logical flows that ensure your automation behaves exactly as intended.</p> <ol> <li> <p>Date Type Options: SPECIFIC DATE, SPECIFIC DATE/TIME, SPECIFIC YEAR/MONTH, SPECIFIC YEAR, TODAY, TOMORROW, YESTERDAY\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Time Period Options: THE PAST WEEK, THE PAST MONTH, THE PAST YEAR, THE NEXT WEEK, THE NEXT MONTH, THE NEXT YEAR, THE NEXT DAYS (with day count field), THE PAST DAYS (with day count field)\u00a0\u21a9\u21a9</p> </li> <li> <p>Type Options: String, Int, Double, Boolean, Datetime, Image, JSON Object, JSON Array\u00a0\u21a9\u21a9</p> </li> <li> <p>Nested Condition: Includes Value Data Type dropdown and Operation selection with additional fields based on selected type and operation\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"flow-editing/custom-actions.html","title":"Custom Actions","text":"<p>Custom actions in FlowRunner\u2122 allow you to extend the functionality of your flows by embedding custom logic that you\u2019ve implemented. Whether you need to process data, interact with external APIs, or automate specific tasks, custom actions give you the flexibility to build and integrate any type of functionality into your flow.</p> <p>Custom actions can be implemented using either Codeless (drag-and-drop logic) or Node.js, depending on your preference and requirements. Once deployed, these actions become part of the FlowRunner\u2122 environment and can be used just like any other block in the Flow Editor. For an indepth look see the Custom Actions section of this guide.</p>"},{"location":"flow-editing/custom-actions.html#implementing-custom-actions","title":"Implementing Custom Actions","text":"<p>You have the freedom to create custom actions that handle various types of logic. These actions can interact with external services, manipulate data, or perform complex logic, and they are particularly useful when you need to execute tasks that go beyond the built-in FlowRunner\u2122 blocks. Custom Action development workflow is described in detail in the Action Development section of this guide.</p> <p>If your custom action interacts with an external service provider that requires OAuth2 authorization, you can easily integrate OAuth2 into the action. This ensures that your action can securely access third-party services, such as APIs, using proper authentication. FlowRunner\u2122 handles the OAuth2 workflow for you, making it easy to implement authorization in custom actions.</p>"},{"location":"flow-editing/custom-actions.html#using-custom-actions","title":"Using Custom Actions","text":"<p>Once you deploy a custom action through Cloud Logic, it automatically appears in the Blocks Toolbox of the Flow Editor. From there, you can drag and drop it into your flow and connect it to other blocks just like any built-in block. </p> <p></p> <p>Custom actions fully integrate into the FlowRunner\u2122 environment, allowing you to:</p> <ul> <li>Use them in flows by linking them with other blocks.</li> <li>Test and debug them directly in the Flow Editor using Test Mode.</li> </ul> <p>This seamless integration ensures your custom actions work smoothly alongside all other blocks in FlowRunner\u2122.</p>"},{"location":"flow-editing/custom-actions.html#installing-from-the-marketplace","title":"Installing from the Marketplace","text":"<p>In addition to creating your own custom actions, FlowRunner\u2122 allows you to install pre-built custom actions from the Backendless Marketplace. These marketplace actions can be added to your flows and used immediately, saving you time and effort. Whether you\u2019re looking for specific functionality or want to explore available integrations, the marketplace offers a wide variety of ready-to-use actions that you can install and customize.</p> <p>Custom actions in FlowRunner\u2122 empower you to extend your flows with powerful, reusable logic. Whether you implement them using Codeless or Node.js, these actions integrate smoothly with the Flow Editor, providing flexibility and functionality. With the added benefit of OAuth2 support and the ability to install actions from the marketplace, you have everything you need to build and enhance your flows with ease.</p>"},{"location":"flow-editing/dataflow.html","title":"Data Movement in Flows","text":"<p>Creating workflows in FlowRunner\u2122 involves dynamic data interactions across various components. Each element within your flow\u2014such as actions, triggers, conditions, utilities, and transformers\u2014handles data in specific ways. These elements take input parameters and produce results that drive your workflow forward. For example, the <code>Send Email</code> block requires an email address to send a message, demonstrating how inputs are essential for the block's function.</p> <p></p>"},{"location":"flow-editing/dataflow.html#data-references","title":"Data References","text":"<p>As your flow executes, each block completes its tasks and produces a \"result\". This result can range from a simple data point to a complex set of information.</p> <p>Note</p> <p>Trigger blocks do not produce a \"result\". Instead, they provide access to the data they have received, which can be used throughout your flows.</p> <p>For instance, a trigger that activates when a web form is submitted captures the information provided by a customer. This data is stored and can be utilized in subsequent blocks of the flow. You can assign a user-friendly name to each result element, making it easier to reference and manage within the Flow Editor.</p> <p></p>"},{"location":"flow-editing/dataflow.html#data-transformation","title":"Data Transformation","text":"<p>Often, the output from one block needs modification before it can be used by subsequent blocks in the flow. For example, if you need to email a customer who filled out a web form, you might need to extract their email address from the submission data. Transformers and Expressions allow you to adapt incoming data to meet the requirements of downstream tasks.</p> <p></p> <p>Transformers ensure that data passing from one block to another is correctly formatted and structured, facilitating smooth data flow and bridging gaps between different data handling requirements.</p> <p>Understanding and manipulating data movement within your flows is essential for creating effective automations. It\u2019s not just about connecting blocks; it\u2019s about orchestrating a coherent and efficient flow of information that enhances your business operations. This chapter aims to equip you with the knowledge to navigate and optimize these data interactions, ensuring that each workflow component is purposeful and impactful.</p>"},{"location":"flow-editing/error-handling.html","title":"Error Handling","text":"<p>Errors are a natural part of workflow automation. Anticipating and managing them effectively ensures your automations remain reliable and resilient. FlowRunner\u2122 offers powerful error-handling tools to help your workflows recover gracefully from issues like failed service calls, database errors, or invalid input data.  </p>"},{"location":"flow-editing/error-handling.html#common-error-scenarios","title":"Common Error Scenarios","text":"<p>Errors in your workflows can arise from various sources, including:  </p> <ul> <li>External Services: Failures in API requests due to service downtime or error responses.  </li> <li>Database Queries: Issues like malformed queries or insufficient permissions.  </li> <li>Invalid Inputs: Actions failing because of incorrect or missing data.  </li> <li>File Uploads: Problems caused by network interruptions or file size limits.  </li> </ul>"},{"location":"flow-editing/error-handling.html#the-handle-error-block","title":"The <code>Handle Error</code> Block","text":"<p>The <code>Handle Error</code> block is a specialized mechanism for managing errors in your flows. Unlike action or trigger blocks, it acts as a fallback route for your flow when errors occur.  </p>"},{"location":"flow-editing/error-handling.html#how-it-works","title":"How It Works","text":"<p>When you connect a block to the <code>Handle Error</code> block, any errors in that block redirect the flow to the <code>Handle Error</code> block. From there, successors define how the error is handled. For example, you could log the error, notify an admin, or call another flow to recover from the issue.  </p> <p>In the example below, if the <code>Retrieve Orders</code> block encounters an error, control passes to the <code>Handle Error</code> block, which directs it to the <code>Log Error</code> block. If no error occurs, the flow continues to <code>Process Orders</code>: </p>"},{"location":"flow-editing/error-handling.html#error-types","title":"Error Types","text":"<p>Errors in FlowRunner\u2122 fall into two categories:  </p> <ul> <li>Handled Errors: These are errors connected to a <code>Handle Error</code> block. The flow knows how to respond and continues executing.  </li> <li>Unhandled Errors: These occur when no <code>Handle Error</code> block is connected. They cause the flow to stop unexpectedly.  </li> </ul>"},{"location":"flow-editing/error-handling.html#error-structure","title":"Error Structure","text":"<p>Errors are represented as a key/value structure with three main properties:  </p> <ul> <li><code>code</code>: A numeric identifier for the specific error type.  </li> <li><code>message</code>: A text description of the error, useful for troubleshooting.  </li> <li><code>source</code>: The name of the block where the error occurred, especially helpful when reusing a <code>Handle Error</code> block.  </li> </ul>"},{"location":"flow-editing/error-handling.html#accessing-error-information","title":"Accessing Error Information","text":"<p>When an error is handled, successors of the <code>Handle Error</code> block can access error details via the \"Handle Error Result\" in the Expression Editor. This information allows you to implement custom error-handling strategies based on the error\u2019s properties:  </p> <ul> <li>Use the <code>code</code> to classify the error type.  </li> <li>Log meaningful details from the <code>message</code>.  </li> <li>Trace the origin of the error using the <code>source</code>.  </li> </ul>"},{"location":"flow-editing/error-handling.html#conditional-error-handling-example","title":"Conditional Error Handling Example","text":"<p>Conditional logic can be used to respond differently based on the <code>code</code> or other error properties. For instance, you might:  </p> <ul> <li>Retry a failed action if the error code indicates a temporary issue.  </li> <li>Log and notify administrators for critical errors.  </li> <li>Redirect to a fallback process for non-recoverable errors.  </li> </ul> <p>The example below shows how to use a condition block to handle specific errors based on their <code>code</code>: </p> <p>This approach enables tailored responses to errors, ensuring your workflows remain resilient and adaptable.  </p>"},{"location":"flow-editing/error-handling.html#best-practices-for-error-handling","title":"Best Practices for Error Handling","text":"<ol> <li>Identify Error-Prone Blocks: Recognize which blocks may encounter errors, such as external service calls or database queries.  </li> <li>Use <code>Handle Error</code> Blocks: Connect these blocks to <code>Handle Error</code> blocks to ensure proper handling. You can centralize error handling or use multiple <code>Handle Error</code> blocks for different errors.  </li> <li> <p>Define Recovery Strategies: Plan how to respond to errors, such as:  </p> </li> <li> <p>Logging the error for analysis.  </p> </li> <li>Sending notifications to administrators.  </li> <li>Retrying the action after a delay (use the Wait Block).  </li> <li>Switching to fallback options, like an alternative service.  </li> <li>Calling another flow for advanced error handling (see Call Flow Action).  </li> </ol> <p>By following these best practices, you can create workflows that are resilient to unexpected issues and maintain operational stability.  </p>"},{"location":"flow-editing/expressioneditor.html","title":"Expression Editor","text":"<p>In your flow, individual blocks generate data that can be utilized throughout the workflow. Triggers receive and pass on information, actions and transformers create new data, and data buckets store various data elements under logical names. As discussed in the Data Movement in Flows section, a block's inputs can reference the results from other blocks, enabling dynamic and interconnected workflows. This result-to-input data referencing is made possible through the Expression Editor.</p>"},{"location":"flow-editing/expressioneditor.html#accessing-the-expression-editor","title":"Accessing the Expression Editor","text":"<p>You can open the Expression Editor from any block's input parameter that displays the specific icon:</p> <p></p>"},{"location":"flow-editing/expressioneditor.html#accessing-flow-data","title":"Accessing Flow Data","text":"<p>When you launch the Expression Editor, it presents a list of all data elements available to the block in the flow. The system composes the list based on the block's predecessors. Consider the screenshot of Expression Editor below:</p> <p></p> <p>The screenshot shows the following sections and elements:</p> <ul> <li>Block Results - <code>Customer Data</code>, <code>Order</code>, <code>Initial Form</code> - these are \"result\" blocks from the predecessor actions and triggers.</li> <li>Error Handler Results - <code>Handle Error Result</code> - contains a reference to an error channelled through the Error Handler block.</li> <li>User References - <code>Initial Form - User</code> - a reference to a Backendless user (if one is present) when the <code>Initial Form</code> trigger was activated.</li> <li>Data Transformation Results - <code>Customer Name</code> - a reference to a result from a Transformer predecessor block.</li> <li>Variables - <code>My Vars - New Order ID</code> - a reference to the <code>New Order ID</code> variable in the <code>My Vars</code> data bucket. </li> </ul>"},{"location":"flow-editing/expressioneditor.html#composing-an-expression","title":"Composing an Expression","text":"<p>To create an expression, you need to arrange one or more elements in the EXPRESSION field. There are several rules for working with the elements in the EXPRESSION field:</p> <ul> <li>To add an element to the field, either drag or double-click it. </li> <li>Elements added to the expression can be rearranged by dragging them into the new position.</li> <li>To remove an element from the field either drag it outside of the field or click to select it and then use the Backspace keyboard button.</li> <li>Use the parenthesis operators  and  to change the precedence of other operators in the expression evaluation. </li> <li>To copy your expression (so you can paste it elsewhere) use the  icon located to the right of the EXPRESSION field.</li> <li>To remove all elements and clear out an expression, click the  icon located to the right of the EXPRESSION field.</li> </ul>"},{"location":"flow-editing/expressioneditor.html#working-with-keyvalue-structures","title":"Working with Key/Value Structures","text":"<p>For the key/value structures, the Expression Editor implements a special \"shortcut\" for accessing values by key name. To access value for a key, double-click or drag an element into the EXPRESSION field. Click it and you will see an input field for the key/property name. Type in a key name and press <code>Enter</code>. The element is reconfigured to access value by key name.</p>"},{"location":"flow-editing/expressioneditor.html#scalarconstant-data","title":"Scalar/Constant Data","text":"<p>In addition to referencing flow data (actions/triggers/transformers results and variables), your expressions can include scalar numeric and text (string) data. This is possible with the <code>Text Input</code> and <code>Number Input</code> elements. These elements can be combined with other scalar or dynamic elements to create more complex expressions.</p>"},{"location":"flow-editing/expressioneditor.html#operators","title":"Operators","text":"<p>The Expression Editor is not just a gateway to access accumulated data but also a powerful tool for manipulating it. It supports basic arithmetic operations, logical comparisons, and string concatenation, allowing you to construct expressions that yield boolean, numeric, or string results. You can find all supported logical and arithmetic operators in the <code>OPERATORS</code> section.</p> <p>Here are some examples of what you can achieve with the Expression Editor:</p> <ul> <li> <p>Arithmetic Operations: You can perform calculations such as adding, subtracting, multiplying, or dividing numbers. For instance, if you have two numeric data elements representing quantities, you can create an expression to find their sum.</p> </li> <li> <p>Logical Comparisons: The Expression Editor enables you to create conditions using logical operators like <code>AND</code>, <code>OR</code>, <code>EQUALS</code>, <code>NOT EQUALS</code> and <code>GREATER</code>/<code>LESS THEN</code>. For example, you can compare two values and produce a boolean result that triggers subsequent actions based on the comparison.</p> </li> <li> <p>String Concatenation: Combine multiple string elements into a single string. This is useful for constructing messages, URLs, or any other text-based data that needs to include dynamic elements from your flow. String concatenation can be implicit by positioning two string elements adjacent to each other, or explicit by using the <code>+</code> operator.</p> </li> </ul>"},{"location":"flow-editing/expressioneditor.html#common-values","title":"Common Values","text":"<p>The Common Values section provides a set of built-in values that can be used to simplify the creation of expressions. These values are particularly useful for inserting common constants, placeholders, or system-generated data.  </p> <ul> <li>Null: Represents a null value, typically used to indicate the absence of a value or an undefined state.  </li> <li>Yes: A Boolean value representing <code>true</code>.  </li> <li>No: A Boolean value representing <code>false</code>.  </li> <li>Tab: Inserts a tab character (<code>\\t</code>), commonly used for formatting text or data.  </li> <li>Space: Represents a single space character, useful for text concatenation or formatting.  </li> <li>New Line: Inserts a newline character (<code>\\n</code>), used to move text to the next line.  </li> <li>Empty Text: Represents an empty string (<code>\"\"</code>), often used as a placeholder or to reset text values.  </li> <li>Empty List: A placeholder for an empty collection, useful for initializing lists without predefining elements.  </li> <li>Empty Object: Represents an empty object, often used for initializing object structures.  </li> <li>Carriage Return: Inserts a carriage return character (<code>\\r</code>), used in text formatting and some legacy systems.  </li> <li>Current Time: Returns the current system time, useful for timestamping or time-based logic in workflows.  </li> <li>Math PI: Represents the mathematical constant \u03c0 (approximately 3.14159), commonly used in calculations involving circles or angles.  </li> <li>Random Number: Generates a random number, useful for scenarios requiring randomization or uniqueness.  </li> <li>UUID: Produces a universally unique identifier, ideal for generating unique keys or identifiers for records and processes.  </li> </ul>"},{"location":"flow-editing/expressioneditor.html#flow-context","title":"Flow Context","text":"<p>In FlowRunner\u2122, every running flow instance is accompanied by a Flow Context - a specialized data collection that stores all information generated during the flow\u2019s execution. This concept is central to how FlowRunner\u2122 manages and organizes data for each flow instance, ensuring seamless automation and precise data tracking.  </p> <p>The Flow Context is a dynamic collection of data maintained by FlowRunner\u2122 for every running flow instance. It acts as a central repository where:  </p> <ul> <li>Block results are stored after each block\u2019s execution.  </li> <li>Variables defined within the flow are tracked.  </li> <li>Data transformation values processed during the flow are preserved.  </li> </ul> <p>Flow builders (developers) do not interact with the Flow Context directly. Instead, the Expression Editor provides a user-friendly interface to access all the data stored in the Flow Context.  </p> <p>In addition to block-specific results and variables, every Flow Context includes several special values that provide critical information about the flow instance. These values can be accessed exclusively through the Expression Editor:  </p> <p></p> <ul> <li> <p>Execution ID A unique identifier for the specific instance of the running flow. Use this ID for tracking or logging purposes, especially when troubleshooting or analyzing flow executions.  </p> </li> <li> <p>Flow ID A unique identifier for the flow itself. This value helps differentiate between multiple flows running in the same environment.  </p> </li> <li> <p>Initial Data A key/value structure containing any data sent to the flow when it was triggered using the CallFlow API. If no data was passed or if the flow was started on a schedule, this value will be empty.  </p> </li> <li> <p>Application ID The unique identifier of the Backendless application where the flow is running. This is particularly useful for multi-tenant environments or when integrating with external systems.  </p> </li> <li> <p>Initial User A key/value structure containing the properties and values of the user whose identity was used to create the flow instance. This value is available only for flows triggered via the CallFlow API and is empty for scheduled flows or flows triggered anonymously.  </p> </li> </ul> <p>By mastering the Expression Editor, you can enhance the functionality of your flows, ensuring that the data moves seamlessly and transforms as needed to meet your automation requirements. This chapter aims to provide you with the knowledge to effectively use the Expression Editor, empowering you to create more sophisticated and responsive workflows.</p>"},{"location":"flow-editing/floweditor.html","title":"Introduction to the Flow Editor","text":"<p>The Flow Editor is the centerpiece of FlowRunner\u2122, offering an intuitive, graphical environment to design and refine workflows. With its user-friendly interface and robust features, it caters to both beginners and experienced automation specialists. This chapter introduces the key elements of the Flow Editor and guides you through its layout and functionalities.  </p> <p>To access the Flow Editor, click the Edit Flow icon for the desired flow version in the Flow Manager:  </p> <p> </p> <p>Editing a Version with Analytics Data</p> <p>Editing a previously <code>LIVE</code> flow version will result in the deletion of its analytics data.  </p> <p> </p> <p>Analytics data becomes invalid when a flow\u2019s internal model changes during editing. FlowRunner\u2122 requires confirmation before proceeding, ensuring you understand the implications.  </p>"},{"location":"flow-editing/floweditor.html#editor-canvas","title":"Editor Canvas","text":"<p>The Editor Canvas is where workflows come to life. It provides a visual space to design your automation by arranging and connecting blocks such as Triggers, Actions, Conditions, Transformers, and Groups. This graphical representation makes workflows easy to understand and adjust.  </p> <p> </p> <p>The Canvas is highly flexible, allowing you to arrange components intuitively. You can drag, drop, and connect blocks to create a seamless flow, visually reflecting your automation logic.  </p>"},{"location":"flow-editing/floweditor.html#blocks-toolbox","title":"Blocks Toolbox","text":"<p>Located beside the Editor Canvas, the Blocks Toolbox contains all the building blocks needed to create workflows. Blocks are categorized into Triggers, Actions, Groups, and Utilities, making it easy to locate the functionality you need.  </p> <p> </p> <p>Features of the Blocks Toolbox include:  </p> <ul> <li>Search Bar: Quickly find blocks by name or functionality.  </li> <li>Marketplace Access: Click the Marketplace icon to the right of the search bar to access FlowRunner\u2122 Extensions in the Marketplace.</li> <li>Hover Descriptions: Hover over a block to view a detailed description of its purpose.  </li> </ul>"},{"location":"flow-editing/floweditor.html#control-bar","title":"Control Bar","text":"<p>The Control Bar is your command center, providing essential tools for workflow development.  </p> <p> </p> <p>Key functionalities include:  </p> <ul> <li>Back to Flows Manager: Return to the Flow Manager.  </li> <li>Start Flow: Launch the current version, moving it to the <code>LIVE</code> state.  </li> <li>Test Mode Toggle: Validate your workflow\u2019s logic and execution in a safe, controlled environment. Visit the Testing your Flows section of this guide for more information about the Test Mode. </li> <li>Auto Save Toggle: Ensure your changes are automatically saved.  </li> </ul>"},{"location":"flow-editing/grouping-actions.html","title":"Grouping Actions","text":"<p>Imagine you're managing a marketing campaign that needs to kick off across multiple channels simultaneously. You need to post updates on social media, send out an email newsletter, and publish a blog post on your website\u2014all at the same time. With FlowRunner\u2122, you can group these actions into a single step and execute them in parallel, significantly speeding up the process and ensuring everything launches together.</p> <p>This powerful feature allows you to run multiple actions at once, enhancing the efficiency and flexibility of your workflows. Instead of waiting for each task to finish before starting the next one, all actions within a grouped step start simultaneously. This is perfect for tasks that don\u2019t depend on a specific sequence and can benefit from concurrent execution.</p>"},{"location":"flow-editing/grouping-actions.html#creating-an-actions-group","title":"Creating an Actions Group","text":"<p>To create an Actions Group, use the <code>Actions Group</code> block located in the <code>GROUPS</code> section of the Blocks Toolbox.</p> <p></p> <p>Drag the <code>Actions Group</code> block into the Flow Editor Canvas. To edit the contents of the group, click the <code>expand</code> icon:</p> <p></p> <p>The Flow Editor canvas will open to show the contents of your group, which is empty by default. You can add multiple actions to the group in the same way blocks are added to a flow. The difference is that actions in a group are not sequenced; when the execution reaches the group, all actions run at once.</p> <p>To return to your flow, click the <code>Go Back</code> button in the top toolbar.</p>"},{"location":"flow-editing/grouping-actions.html#transition-modes","title":"Transition Modes","text":"<p>You have the option to choose how the workflow transitions to successor blocks. This is configured in the group's properties:</p> <p></p> <p>The first mode, <code>On Start</code>, allows the workflow to move on as soon as all actions in the current step have begun. This is particularly useful when the next tasks in the workflow can start as soon as they know the previous actions are underway, without waiting for their completion. Backendless visualizes this transition mode with a top-filled hourglass indicator on all transition lines. </p> <p></p> <p>The second mode, <code>On Completion</code>, ensures that the workflow only proceeds once all actions in the current step are finished. This mode is ideal when the subsequent steps rely on the completion of all parallel tasks, making sure nothing is left incomplete before moving forward. This transition mode is visualized with a bottom-filled hourglass indicator on all outgoing transition lines:</p> <p></p> <p>Consider a scenario where you're collecting data from various sources. You need to fetch sales data from a database, customer data from an API, and product data from a spreadsheet. With this feature, you can start all these data collection tasks simultaneously. Depending on your workflow requirements, you can either start processing the collected data as soon as all tasks have started (using the <code>On Start</code> transition mode) or wait until all data is gathered before proceeding (using the <code>On Completion</code> mode).</p>"},{"location":"flow-editing/grouping-actions.html#returned-values","title":"Returned Values","text":"<p>The <code>Actions Group</code> block does not have its own return value. However, the \"Result\" elements from the individual actions placed into the group are available.</p> Note <p>If the outgoing transition is set to <code>On Start</code>, data in an individual \"result\" element may not be available until the action completes its execution. Make sure to check for data availability before you use it in a successor block.</p>"},{"location":"flow-editing/grouping-actions.html#benefits-of-grouping-actions","title":"Benefits of Grouping Actions","text":"<p>Grouping actions for parallel execution offers significant benefits. By enabling parallel execution, you can reduce the overall execution time, making your workflows more efficient. The flexibility to choose the appropriate transition mode based on your needs ensures that your processes are both robust and streamlined. Additionally, this capability allows you to handle complex workflows with multiple parallel actions easily, scaling your automation to meet growing demands.</p> <p>In essence, Backendless Automation's ability to group actions into parallel execution steps, with flexible transition modes, enhances both efficiency and flexibility. Whether you're launching a marketing campaign, collecting data from various sources, or performing IT maintenance tasks, this feature ensures your workflows are effective, timely, and capable of managing complex tasks with precision.</p>"},{"location":"flow-editing/grouping-triggers.html","title":"Grouping Triggers","text":"<p>Imagine you are orchestrating a complex business workflow with multiple conditions that need to be met before proceeding to the next step. For instance, let's say you are managing an order processing system. You need to ensure that an order confirmation is received, payment is completed, and the inventory is updated before shipping the product. This is where FlowRunner's <code>Triggers Group</code> block comes into play.</p> <p></p> <p>In FlowRunner, the <code>Triggers Group</code> block allows you to pause the flow execution until specific conditions, represented by triggers, are met. This block can contain multiple trigger blocks, each representing a different condition. The triggers within this group are equal; there is no predefined order, and the flow will remain paused until the configured conditions are satisfied.</p>"},{"location":"flow-editing/grouping-triggers.html#creating-a-triggers-group","title":"Creating a Triggers Group","text":"<p>To configure the Triggers Group block, click the <code>Expand</code> icon. This action opens a special editing mode in the Flow Editor that allows you to add other triggers to the group. In this mode, you can add the necessary triggers without needing to connect them in a sequence, as all triggers in a group are equal and do not represent any specific order.</p> <p></p>"},{"location":"flow-editing/grouping-triggers.html#transition-modes","title":"Transition Modes","text":"<p>The Triggers Group block offers flexibility with two Outgoing Transition Modes. You can access the transition mode configuration by clicking the Triggers Group block in your flow to open its properties:</p> <p></p> <p>The first mode, \"When at least one trigger occurs,\" allows the flow to continue as soon as any one of the triggers in the group is activated. This is particularly useful in scenarios where you need to proceed as soon as any condition is met. For example, in our order processing system, you might want to start the shipping process as soon as either the order confirmation or the payment is completed, not necessarily waiting for both.</p> <p>The second mode, \"When all triggers start within the time set below,\" is designed for more complex scenarios where all conditions must be met within a certain timeframe before proceeding. In the same order processing example, you may want to ensure that both the order confirmation and payment completion happen within, say, 24 hours. If both triggers are activated within this period, the flow will continue to the next step, which might involve updating the inventory and preparing the product for shipment. If not, you might want to take a different action, such as notifying the customer or canceling the order.</p>"},{"location":"flow-editing/grouping-triggers.html#triggers-group-benefits","title":"Triggers Group Benefits","text":"<p>Using the <code>Triggers Group</code> block, FlowRunner empowers you to design workflows that can adapt to various conditions and requirements. Whether you need to proceed based on the first available trigger or wait for all conditions to be met within a specified timeframe, this feature offers the flexibility to handle both simple and complex scenarios with ease.</p> <p>In essence, the <code>Triggers Group</code> block in FlowRunner is a powerful tool for managing workflow conditions. By allowing multiple triggers to be grouped and providing flexible transition modes, it ensures that your workflows can pause and resume based on precise conditions, making your automation processes more robust and reliable.</p>"},{"location":"flow-editing/loops.html","title":"Repeated Behavior (Loops)","text":"<p>In programming and automation, a loop is a way to repeat a set of actions multiple times. Think of it like a washing machine that repeats the same washing cycle until your clothes are clean. Loops help automate repetitive tasks, making processes more efficient and less prone to errors.</p>"},{"location":"flow-editing/loops.html#what-is-a-loop","title":"What is a Loop?","text":"<p>A loop allows you to perform a series of steps over and over again until a specific condition is met. Each cycle in a loop is called an iteration. This is particularly useful when you need to process a large amount of data, check for updates regularly, or repeat an action until a desired result is achieved. For example, imagine you are managing an email marketing campaign. You want to send a reminder email to all customers who haven't opened your previous email. Instead of manually checking each customer and sending emails one by one, you can use a loop to automate this process:</p> <ol> <li>Check the Email Status - look at the status of each customer's email.</li> <li>Send Reminder Email - if the email is not opened, send a reminder.</li> <li>Repeat - continue this process for each customer in your list.</li> </ol> <p>This way, the loop will keep checking and sending emails until it has gone through the entire customer list.</p>"},{"location":"flow-editing/loops.html#loops-in-flowrunner","title":"Loops in FlowRunner","text":"<p>In FlowRunner, loops are implemented using the \"Repeat\" block. This block allows you to repeat a group of actions, known as a sub-flow, as many times as needed until a specified condition is met. </p> <p></p>"},{"location":"flow-editing/loops.html#repeast-block-properties","title":"Repeast Block Properties","text":"<p>The \"Repeat\" block has several unique qualities:</p> <ol> <li> <p>Grouping Blocks: The Repeat block acts like a container where you can place multiple blocks. These blocks form the sub-flow that will be repeated. For example, you might include blocks to check a condition, perform an action, and then wait for a specified time or a trigger event before checking again. To edit the sub-flow of the Repeat block, click the \"expand\" icon: </p> </li> <li> <p>Condition for Iterations: The Repeat block includes a condition that determines how many times the loop will run. As long as this condition is true, the Repeat block will keep running the sub-flow. Once the condition is false, the loop stops, and the flow continues to the next block outside the Repeat block.  When you click the Add a Condition button, you can add a condition the same way as in other parts where conditions are supported of FlowRunner. </p> </li> <li> <p>Current Iteration Number: FlowRunner maintains a special number called the <code>Current Iteration Number</code>, which starts at 0 for the first iteration and increments by 1 with each subsequent iteration. This number can be used within your flow to track or control the loop's progress. You can reference <code>Current Iteration Number</code> in the \"Repeat\" condition or in any block in the sub-flow. The <code>Current Iteration Number</code> element is available through the Expression Editor. </p> </li> <li> <p>Failsafe Protection Count: The Repeat block includes a special configuration property called \"Failsafe Protection Count\". This field allows you to set the maximum number of iterations before the loop stops. This feature is particularly useful during flow development to prevent infinite looping, which can result in an error due to flow execution timeout. It is recommended to set this number to the lowest value that is reasonably high enough for your needs.</p> <p></p> </li> </ol> <p>In summary, loops in FlowRunner, facilitated by the Repeat block, enable you to automate repetitive tasks effectively. This ensures your workflows are efficient, reliable, and can handle large-scale processes seamlessly.</p>"},{"location":"flow-editing/pdf-generator.html","title":"PDF Generator","text":"<p>In FlowRunner\u2122, the PDF generation process allows you to create customized PDF documents by dynamically incorporating data from your flow into predefined templates. Here's how it works in broad terms:</p> <p>As a flow developer, you first create a PDF template. This template defines specific dynamic areas, called fields, which will hold content like data tables, images, QR codes, and text. These fields act as placeholders that will later be populated with actual data during the flow execution.</p> <p>Once your template is set up, you add the PDF Generator action to your flow. This action links the flow to the template you\u2019ve created. At this stage, FlowRunner\u2122 will show you a list of the available fields in the template. You can then map each template field to specific data from your flow, establishing the relationship between your flow's data and how it will appear in the PDF.</p> <p>When the flow runs, the PDF Generator action processes the template with your data, creating the final document. The outcome is a URL to the generated PDF. You can use this URL later in your flow for various purposes, such as sending it by email or storing it for future use.</p>"},{"location":"flow-editing/pdf-generator.html#pdf-generator-components","title":"PDF Generator Components","text":"<p>There are three essential components involved in generating a PDF within FlowRunner\u2122:</p> <ul> <li>PDF Template: This defines the layout and structure of your PDF document. It includes placeholders (fields) for dynamic data such as images, text, or tables.</li> <li>PDF Generator Action: This action initiates the PDF creation process. It manages the mapping between template fields and the data from your flow.</li> <li>PDF Generator Result: Once the PDF is generated, the result is a URL that links to the created document. This PDF reflects the structure of the template combined with the data mappings you've assigned.</li> </ul>"},{"location":"flow-editing/pdf-generator.html#pdf-template-editor","title":"PDF Template Editor","text":"<p>The PDF Template Editor is a separate tool within the Backendless Console that helps you create PDF templates for dynamic content. To get started, follow these steps:</p> <ol> <li> <p>Open the Quick Access menu: Click the \"Quick Access\" button located in the upper left corner of the console.</p> <p></p> </li> <li> <p>Find the PDF Generator: Navigate to the \"Messaging\" section or simply type \"PDF\" in the search bar to quickly locate the tool.</p> <p></p> </li> <li> <p>Add to Favorites: If you use the PDF Generator often, you can click the  icon next to its name to add it to the Favorites bar for easier access.</p> </li> </ol> <p>The interface for the PDF Generator is designed to give you full control over your template creation and customization. Below are the key elements you\u2019ll work with:</p>"},{"location":"flow-editing/pdf-generator.html#templates-list","title":"Templates List","text":"<p>This is where you manage your PDF templates. You can:</p> <ul> <li>Add new templates.</li> <li>Delete templates you no longer need.</li> <li>Edit template properties, such as paper size, page dimensions, and document padding.</li> </ul> <p></p>"},{"location":"flow-editing/pdf-generator.html#document-editor","title":"Document Editor","text":"<p>The Document Editor allows you to design your PDF. It renders one or more pages that make up the template. A key feature of the editor is the ability to upload a base PDF. This base PDF could contain static elements like a corporate letterhead or any other design element that will stay the same across all generated documents. Use the Change Base PDF button to update base PDF. You can then overlay dynamic fields on top of this base PDF to create personalized documents.</p> <p></p> <p>Note</p> <p>When you set a base PDF for your template, it limits which template properties you can edit in the Templates List. If you click the \"pencil\" icon to open the \"Edit Template\" popup, you will only be able to change the template's name. </p> <p>All other properties - like page format, size, and paddings - are inherited from the base PDF. This means you cannot adjust these layout settings manually, as they are controlled by the structure of the base document itself.</p> <p>This is useful to keep in mind when working with static elements like corporate letterheads or certificates, as the base PDF sets the foundational design.</p>"},{"location":"flow-editing/pdf-generator.html#toolbar","title":"Toolbar","text":"<p>The toolbar provides a variety of components you can add to your template. Components include dynamic elements such as Table, Image, Text Input and QR Code. These components will later serve as fields where dynamic data is inserted when the flow runs. In addition, the toolbar includes decorative components, such as Geometric shapes and Read-only text. These are static elements used for visual purposes, and they do not change during the flow execution.</p> <p></p> <p>Note</p> <p>In the toolbar of the PDF Generator, hovering your mouse pointer over any icon will display a tooltip with the name of the component. This is a helpful way to quickly identify each component before adding it to your template, ensuring you choose the right tool for the job without needing to click through each option.</p> <p></p>"},{"location":"flow-editing/pdf-generator.html#field-properties","title":"Field Properties","text":"<p>When you select a field in the template, the Field Properties panel opens. Here, you can customize the visual appearance of the field, such as adjusting its size, position, or other styling options to match the document's needs.</p> <p></p> <p>Note</p> <p>When working in the Field Properties panel, it\u2019s recommended to update the default value in the Name field. This field holds the name assigned to the component or field, which is important for later stages.</p> <p>The name you assign will be used in FlowRunner\u2122 for data mapping purposes. To avoid confusion, it\u2019s best to choose a meaningful name that clearly and uniquely identifies the component. This makes it easier to manage and map your fields accurately when building flows, especially when you have multiple dynamic elements in your template.</p>"},{"location":"flow-editing/pdf-generator.html#field-list","title":"Field List","text":"<p>Once you add components to your template, they appear in the Field List. Each component added to the template becomes a field, which can be either static or dynamic. If a field has a  icon next to it, that means its value cannot be dynamically populated during the flow, meaning it's static.</p> <p></p> <p>Note</p> <p>To view the Field List in the PDF Generator, you have two options:</p> <ul> <li>Click on any blank area of your template.</li> <li>Use the \"burger\" icon located on the Field Properties panel.</li> </ul> <p>These actions will bring up the list of all fields (or components) that have been added to your template, making it easy to manage and review your dynamic and static elements.</p>"},{"location":"flow-editing/pdf-generator.html#remember-to-save-your-template","title":"Remember to Save Your Template!","text":"<p>A crucial step when working with the PDF Generator is to save your template. After making any changes, always click the \"Save Template\" button to ensure that your updates are not lost. If you forget this step, your work will not be preserved.</p> <p></p>"},{"location":"flow-editing/pdf-generator.html#pdf-generator-in-flowrunner","title":"PDF Generator in FlowRunner","text":"<p>To begin using the PDF Generator in your flow, the first step is to add the PDF Generator action block to your flow in FlowRunner\u2122. If there are any predecessor blocks in the flow, ensure they are connected to the PDF Generator action for seamless execution.</p> <p></p> <p>Once the action is placed, you will need to configure it. The first task is to select a PDF Template. In the properties panel of the action, you\u2019ll find the Template property, which displays a list of templates already configured in your application. </p> <p></p> <p>If you have multiple browser windows open (for instance, one where you're editing the template and another where you\u2019re creating the flow), you can click the refresh icon in the FlowRunner\u2122 window to update the list of available templates.</p> <p></p>"},{"location":"flow-editing/pdf-generator.html#fields-mapping","title":"Fields Mapping","text":"<p>Once you select a PDF Template, the properties panel will automatically update, showing the template fields you can map flow data to. Each field will appear with the name you assigned (or the default name if you didn\u2019t assign a specific one) and will also reference the component it represents. Consider the following sample PDF template, notice there are four \"editable\" fields: <code>image</code>, <code>qrField</code>, <code>tableData</code> and <code>textField</code>:</p> <p> </p> <p>When selecting that template in FlowRunner\u2122, it will render the following form for field mappings:</p> <p></p> <p>To map the flow data to these fields, you\u2019ll use FlowRunner\u2019s Expression Editor interface. Most mappings are quite straightforward. For instance, when mapping data to a text field or a QR Code, you simply need to specify the value that will be rendered in the PDF.</p> <p> </p> <p>Or alternatively, you can use a result of a previous block:</p> <p></p>"},{"location":"flow-editing/pdf-generator.html#tables-in-pdf","title":"Tables in PDF","text":"<p>Mapping data to a Table field in the PDF Template is a bit more complex. You need to map the data that will populate the table, and also assign data properties to the specific table columns. Fortunately, FlowRunner\u2019s interface simplifies this process.</p> <p>Let\u2019s look at an example:</p> <p>Suppose your PDF Template includes a table field with columns for Customer Name, Order Amount, and Segment. In the PDF Template editor, the field name is set to ordersData. </p> <p></p> <p>Note</p> <p>To edit the table column names, click directly on the header cell and modify the name using the inline content editing feature. Once you have made your changes, remember to click the Save Template button to ensure your updates are saved.</p> <p>When this template is used in FlowRunner\u2122, the properties panel for the PDF Generator action will look something like this:</p> <p></p> <p>As shown, FlowRunner\u2122 automatically recognizes the ordersData field and creates a mapping interface for both the data to populate the table and the data properties that correspond to the table columns.</p> <p>Now, let\u2019s assume the flow retrieves table data from the Backendless database, and the data looks like this:</p> <p></p> <p>You want to render the Customer Name, Sales, and Customer Segment in the PDF. To do so, you\u2019ll create a mapping between the data columns and the table columns, as shown below:</p> <p></p> <p>Make sure to set the ordersData field mapping to the result of your database query (from the \"Find Record(s) in Database\" action).</p> <p></p>"},{"location":"flow-editing/pdf-generator.html#testing-pdf-generation","title":"Testing PDF Generation","text":"<p>Before running the flow, it\u2019s recommended to use Test Mode to ensure everything is working as expected. When you test it, the PDF Generator action should produce the following result:</p> <p></p> <p>After the flow executes successfully, the final PDF Document will be generated and look like this:</p> <p></p>"},{"location":"flow-editing/return-result.html","title":"Return Result","text":"<p>The Return Result block defines the data returned from SubFlows and flows invoked via Call Flow. Use Return Result blocks to structure the output that subsequent workflow steps can access.</p>"},{"location":"flow-editing/return-result.html#how-return-result-works","title":"How Return Result Works","text":"<p>Return Result is a terminal block - it marks the end of an execution branch. When a flow reaches a Return Result block, that branch stops executing and the configured data becomes available as the result.</p> <p>Return Result blocks can be used in:</p> <ul> <li>SubFlows - Define data returned to the parent flow</li> <li>Flows invoked via Call Flow - Define data returned to the calling flow</li> </ul> <p>The block functions identically in both contexts.</p>"},{"location":"flow-editing/return-result.html#configuring-return-result","title":"Configuring Return Result","text":"<p>Configure the return structure in the Compose Result section of the block settings.</p> <p></p> <p>Each row in the Compose Result section consists of:</p> <p>Property The name of the property in the returned result object. This field supports Expression Editor, allowing dynamic property names based on workflow data. </p> <p>Value The data to return for this property. This field supports Expression Editor, enabling you to return values from previous blocks, variables, or computed expressions. Values can be static (entered directly) or dynamic (selected through Expression Editor). Click the Expression Editor icon in the field to open Expression Editor.</p> <p>Add additional properties by clicking the  icon. Remove properties by clicking the  icon next to the property row.</p>"},{"location":"flow-editing/return-result.html#result-structure","title":"Result Structure","text":"<p>The structure of returned data depends on how many Return Result blocks exist in the flow or SubFlow.</p>"},{"location":"flow-editing/return-result.html#single-return-result-block","title":"Single Return Result Block","text":"<p>When a flow or SubFlow has only one Return Result block, the result is an object containing the properties and values you configured.</p> <p>For example, if you configure these properties (see the screenshot above in the Configuring Return Result section):</p> <ul> <li><code>auditId</code> with value <code>\"12345\"</code></li> <li><code>timestamp</code> with value <code>\"2025-10-29T10:30:00Z\"</code></li> </ul> <p>The result structure is:</p> <pre><code>{\n  \"auditId\": \"12345\",\n  \"timestamp\": \"2025-10-29T10:30:00Z\"\n}\n</code></pre>"},{"location":"flow-editing/return-result.html#multiple-return-result-blocks","title":"Multiple Return Result Blocks","text":"<p>When a flow or SubFlow has multiple execution branches with Return Result blocks, the result structure includes both the first-reached result and a complete list of all results:</p> <pre><code>{\n  \"executionId\": \"BDE51159-E27C-431F-97DC-FEF5D8014481\",\n  \"result\": {\n    \"blockName\": \"Audit Success\",\n    \"data\": {\n      \"auditId\": \"12345\",\n      \"status\": \"completed\"\n    }\n  },\n  \"results\": [\n    {\n      \"blockName\": \"Audit Success\",\n      \"data\": {\n        \"auditId\": \"12345\",\n        \"status\": \"completed\"\n      }\n    },\n    {\n      \"blockName\": \"Audit Failed\",\n      \"data\": {\n        \"errorCode\": \"E401\",\n        \"errorMessage\": \"Validation failed\"\n      }\n    }\n  ],\n  \"status\": \"COMPLETED\"\n}\n</code></pre> <p>The <code>result</code> property contains the data from the Return Result block that was reached first. The <code>results</code> array contains data from all Return Result blocks across all branches. The flow waits until all branches complete before returning results.</p>"},{"location":"flow-editing/return-result.html#naming-return-result-blocks","title":"Naming Return Result Blocks","text":"<p>The <code>blockName</code> value in the result structure comes from the name you assign to the Return Result block. Use the Name field in the block settings to provide meaningful names.</p> <p>Good naming practices:</p> <ul> <li>Use names that describe what the result represents: \"Success Response\", \"Error Details\", \"Validation Result\"</li> <li>Avoid generic names like \"Return Result\" or \"Return Result (2)\"</li> <li>Use names that help identify which branch produced the result: \"Payment Approved\", \"Payment Declined\"</li> </ul> <p>Meaningful names make it easier to identify and access specific results when working with multiple Return Result blocks.</p>"},{"location":"flow-editing/return-result.html#using-expression-editor","title":"Using Expression Editor","text":"<p>Both the Property and Value fields support Expression Editor. You can use dynamic property names and compute values using any valid Expression Editor syntax, including data from previous blocks, variables, transformations, and conditional logic.</p>"},{"location":"flow-editing/return-result.html#data-types","title":"Data Types","text":"<p>Return Result blocks support all FlowRunner\u2122 data types. The data type is preserved when returned to the calling context.</p>"},{"location":"flow-editing/return-result.html#accessing-returned-data","title":"Accessing Returned Data","text":"<p>Access returned data in subsequent blocks using Expression Editor. The return structure is the same whether Return Result is used in a SubFlow or a flow invoked via Call Flow - only the block name differs.</p> <p>For single Return Result:</p> <pre><code>{{SubFlowBlockName Result-&gt;propertyName}}\n</code></pre> <p>For multiple Return Results:</p> <p>Access the first-reached result:</p> <pre><code>{{BlockName Result-&gt;data.propertyName}}\n</code></pre> <p>Access specific branches from the results array:</p> <pre><code>{{BlockName Result-&gt;[0].data.propertyName}}\n{{BlockName Result-&gt;[1].data.propertyName}}\n</code></pre> <p>Access execution metadata:</p> <pre><code>{{BlockName Result-&gt;executionId}}\n{{lockName Result-&gt;status}}\n</code></pre> <pre><code>{{BlockName Result-&gt;propertyName}}\n</code></pre> <p>Replace <code>BlockName</code> with either the SubFlow block name or the Call Flow block name depending on which invoked the flow containing the Return Result block.</p> <p>Best Practices</p> <p>Use Meaningful Property Names Choose property names that clearly describe the data they contain. Use <code>customerEmail</code> instead of <code>email</code>, or <code>orderTotal</code> instead of <code>total</code> when the context matters.</p> <p>Return Only Necessary Data Include only the data that calling flows or blocks actually need. Returning excessive data makes results harder to work with and can impact performance.</p> <p>Consistent Structure Across Branches When using multiple Return Result blocks, maintain consistent property names across branches where possible. This makes it easier to process results regardless of which branch executed.</p> <p>Document Complex Results Add comments in your flow to document the structure of returned data, especially when returning complex objects or arrays. Future users will appreciate understanding what each property represents.</p> <p>Test Return Result Configuration Use Test Mode to verify that Return Result blocks return the expected data structure and values. Check both single-path and multi-branch scenarios.</p>"},{"location":"flow-editing/subflows.html","title":"SubFlows","text":"<p>SubFlows are reusable workflow sequences that you define once and use multiple times within the same flow. Think of a SubFlow as a packaged set of steps you can place multiple times throughout your workflow.</p>"},{"location":"flow-editing/subflows.html#example-audit-tracking","title":"Example: Audit Tracking","text":"<p>Consider a workflow that processes financial transactions and must create audit records at multiple steps for compliance. Each audit record requires the same sequence - check configuration settings to determine what to log, format the audit data according to organizational standards, add a timestamp, and save the record to the audit database. Instead of rebuilding this sequence at each audit point, create a SubFlow called \"Create Audit Record\" and place it at different points in your transaction workflow:</p> <ul> <li>After transaction validation (audit the validation result)</li> <li>After payment authorization (audit the authorization response)</li> <li>After transaction completion (audit the final transaction state)</li> </ul> <p>Each time the SubFlow runs within the transaction workflow, it executes the same audit logic but receives different input values for the event type, transaction ID, and event details.</p>"},{"location":"flow-editing/subflows.html#why-use-subflows","title":"Why Use SubFlows","text":"<p>SubFlows help you:</p> <ul> <li>Avoid duplicating the same workflow logic in multiple places</li> <li>Simplify complex flows by breaking them into manageable pieces</li> <li>Update logic in one place and have changes apply everywhere the SubFlow is used</li> <li>Make workflows easier to read and maintain</li> </ul>"},{"location":"flow-editing/subflows.html#subflows-vs-call-flow-action","title":"SubFlows vs. Call Flow Action","text":"<p>FlowRunner\u2122 offers two ways to reuse workflow logic:</p> <p>SubFlows are workflow sequences that exist only within the current flow. Use SubFlows when you need to repeat a specific sequence multiple times in the same workflow. SubFlows cannot be called from other flows.</p> <p>Call Flow action invokes a complete, separate flow from within your current flow. Use the Call Flow action when you need to reuse an entire flow across multiple different flows.</p>"},{"location":"flow-editing/subflows.html#creating-a-subflow","title":"Creating a SubFlow","text":"<p>Locate the Create SubFlow button in the Block List panel. This button cannot be dragged to the canvas - click it to open the New SubFlow dialog.</p> <p></p> <p>The New SubFlow dialog requests:</p> <p>SubFlow Name Enter a descriptive name that indicates what the SubFlow does. This name appears in the Block List panel and helps you identify the SubFlow when building your workflow.</p> <p>Input Parameter Names Define the data the SubFlow needs to perform its task. For example, a \"Send Order Confirmation\" SubFlow might need parameters like <code>customerEmail</code>, <code>orderNumber</code>, and <code>orderTotal</code>. Add additional parameters by clicking the plus icon.</p> <p></p> <p>Click CREATE SUBFLOW to create the SubFlow. The new SubFlow appears in the SUBFLOWS group in the Block List panel.</p> <p></p>"},{"location":"flow-editing/subflows.html#using-subflows-in-your-workflow","title":"Using SubFlows in Your Workflow","text":"<p>Drag the SubFlow from the Block List panel to the Flow Editor canvas. The SubFlow functions like any other action block - connect it to predecessor blocks and add successor blocks after it.</p> <p>When you select a SubFlow block on the canvas, the settings panel displays input fields for any parameters you defined. Provide values for these parameters using Expression Editor for dynamic values or enter static values directly.</p> <p>Parameter configuration for SubFlows follows the same rules as other FlowRunner\u2122 blocks. You can reference results from previous blocks, use variables, or apply data transformations through Expression Editor.</p> <p></p>"},{"location":"flow-editing/subflows.html#defining-subflow-logic","title":"Defining SubFlow Logic","text":"<p>When you first create a SubFlow, it contains no logic. You must define what the SubFlow does by adding blocks inside it.</p> <p>To edit a SubFlow, click the expand icon in the lower right corner of the SubFlow block on the canvas. This navigates into the SubFlow editor.</p> <p></p> <p>When editing a SubFlow, the editor title bar displays the SubFlow name, indicating you are working inside that SubFlow. Build the SubFlow's logic the same way you build regular flows - drag blocks from the Block List, configure parameters, and connect blocks to define the execution sequence.</p> <p>Important limitation: SubFlows cannot contain other SubFlows. You can only use standard actions, triggers, conditions, and other flow control blocks inside a SubFlow.</p> <p>To return to the main flow, click the flow name in the breadcrumb navigation or use the back button in the editor.</p>"},{"location":"flow-editing/subflows.html#accessing-input-parameters","title":"Accessing Input Parameters","text":"<p>Inside a SubFlow, access input parameters through the Expression Editor using the Input Data pill. The Input Data pill provides a dropdown list of all declared input parameters for the SubFlow.</p> <p>To use an input parameter:</p> <ol> <li>Open Expression Editor for any parameter field in a block inside the SubFlow</li> <li>Locate the Input Data pill in the Expression Editor</li> <li>Click the dropdown on the Input Data pill to see available parameters</li> <li>Drag the Input Data pill into your expression</li> <li>Select the specific parameter from the dropdown</li> </ol> <p></p>"},{"location":"flow-editing/subflows.html#subflow-reusability","title":"SubFlow Reusability","text":"<p>You can place the same SubFlow multiple times in your workflow. Each instance executes the same logic but can receive different input parameters.</p> <p>For example, your order processing flow might use \"Send Order Confirmation\" in multiple places:</p> <ul> <li>After initial order placement (with customer order details)</li> <li>After successful payment processing (with payment confirmation details)</li> <li>After shipping dispatch (with tracking information)</li> </ul> <p>Each instance receives different input values but executes the same underlying logic.</p>"},{"location":"flow-editing/subflows.html#updating-subflow-logic","title":"Updating SubFlow Logic","text":"<p>When you modify a SubFlow's internal logic, all instances of that SubFlow in your workflow update automatically. If you have three instances of \"Send Order Confirmation\" and you change how the confirmation email is formatted, all three instances use the updated format immediately.</p> <p>This ensures consistency across your workflow and eliminates the need to update multiple copies of the same logic.</p>"},{"location":"flow-editing/subflows.html#subflow-results","title":"SubFlow Results","text":"<p>SubFlows return results that subsequent blocks in your workflow can use. The result structure depends on whether the SubFlow uses Return Result blocks and how many execution branches exist.</p>"},{"location":"flow-editing/subflows.html#single-return-result-block","title":"Single Return Result Block","text":"<p>When a SubFlow has only one Return Result block, the result is an object containing the properties and values defined in that Return Result block.</p> <p>For example, if your Return Result block defines <code>auditId</code> and <code>timestamp</code>:</p> <p></p> <p>the SubFlow result contains those properties directly: <pre><code>{\n  \"auditId\": \"12345\",\n  \"timestamp\": \"2025-10-29T10:30:00Z\"\n}\n</code></pre></p>"},{"location":"flow-editing/subflows.html#multiple-return-result-blocks","title":"Multiple Return Result Blocks","text":"<p>When a SubFlow has multiple Return Result blocks (meaning multiple execution branches), the result structure includes the result of the Return Result block that was reached first as well as a list of all Return Result objects. For example, suppose a SubFlow has two Return Result blocks, one shown above and the other shown in the screenshot below:</p> <p></p> <p>The result structure of the sublfow would look as shown below:</p> <pre><code>{\n  \"executionId\": \"BDE51159-E27C-431F-97DC-FEF5D8014481\",\n  \"result\": {\n    \"blockName\": \"Return Audit Result\",\n    \"data\": {\n      \"auditId\": \"12345\",\n      \"timestamp\": \"2025-10-29T10:30:00Z\"\n    }\n  },\n  \"results\": [\n    {\n      \"blockName\": \"Return Audit Result\",\n      \"data\": {\n         \"auditId\": \"12345\",\n          \"timestamp\": \"2025-10-29T10:30:00Z\"\n      }\n    },\n    {\n      \"blockName\": \"Return Log Status\",\n      \"data\": {\n        \"logCreated\": true\n      }\n    }\n  ],\n  \"status\": \"COMPLETED\"\n}\n</code></pre> <p>The <code>blockName</code> value is the actual name assigned to each Return Result block. It is recommended to assign meaningful names to Return Result blocks that represent the result they provide. For example, name blocks \"Audit Success\" or \"Audit Failed\" rather than using default names.</p>"},{"location":"flow-editing/subflows.html#without-return-result-blocks","title":"Without Return Result Blocks","text":"<p>If a SubFlow does not use Return Result blocks, the result object will not include any data from the SubFlow.</p>"},{"location":"flow-editing/subflows.html#accessing-subflow-results","title":"Accessing SubFlow Results","text":"<p>Reference SubFlow results in subsequent blocks using Expression Editor.</p> <p>For single Return Result: <pre><code>{{SubFlowBlockName Result-&gt;propertyName}}\n</code></pre></p> <p>For multiple Return Results:</p> <p>Access the <code>result</code> property for the first branch: <pre><code>{{SubFlowBlockName Result-&gt;data.propertyName}}\n</code></pre></p> <p>Access specific branches from the <code>results</code> array: <pre><code>{{SubFlowBlockName Result-&gt;[0].data.propertyName}}\n{{SubFlowBlockName Result-&gt;[1].data.propertyName}}\n</code></pre></p> <p>Access execution metadata: <pre><code>{{SubFlowBlockName Result-&gt;executionId}}\n{{SubFlowBlockName Result-&gt;status}}\n</code></pre></p> <p>For detailed information about configuring Return Result blocks, see the Return Result documentation.</p>"},{"location":"flow-editing/subflows.html#when-to-use-subflows","title":"When to Use SubFlows","text":"<p>Use SubFlows when:</p> <ul> <li>You repeat the same sequence of actions multiple times in a workflow</li> <li>You want to organize complex workflows into logical sections</li> <li>Changes to repeated logic should apply consistently everywhere</li> <li>The reusable logic is specific to the current workflow</li> </ul> <p>Use the Call Flow action when:</p> <ul> <li>You need to reuse complete workflows across multiple different flows</li> <li>The logic represents a standalone process</li> <li>Multiple teams or projects need access to the same workflow</li> </ul> <p>Best Practices</p> <p>Naming SubFlows Use descriptive names that explain what the SubFlow does. Good names include \"Validate Customer Data\", \"Calculate Shipping Cost\", or \"Send Notification\". Avoid generic names like \"SubFlow1\" or \"Process Data\".</p> <p>Parameter Design Define only the parameters the SubFlow actually needs. Too many parameters make SubFlows harder to configure and maintain. If a SubFlow needs many parameters, consider whether it should be broken into smaller SubFlows.</p> <p>Single Responsibility Each SubFlow should perform one clear task. SubFlows that try to do too many things become difficult to reuse and maintain. If a SubFlow becomes complex, consider splitting it into multiple smaller SubFlows.</p> <p>Documentation Add comments or notes inside SubFlows to explain complex logic. Future users (including yourself) will appreciate clear explanations of what the SubFlow does and why certain steps are necessary.</p> <p>Testing Test SubFlows thoroughly before using them in multiple places in your workflow. Bugs in a SubFlow affect every instance where it appears. Use Test Mode to validate SubFlow behavior with different input parameters.</p>"},{"location":"flow-editing/transformer.html","title":"Data Transformations","text":"<p>Data transformations in FlowRunner\u2122 are handled by the versatile Transform Data block. This block offers various data transformation operations that can manipulate key/value structures, arrays/lists, strings, dates, and perform logical operations. When setting up a transformation, you select the desired operation and configure its input parameters, if any. When the Transform Data block executes, it performs the selected operation. For a complete list of supported operations, see the Transform Data block in the Block Reference guide. </p> <p>For example, the <code>Contains</code> operation checks if a given <code>Search String</code> is present within a <code>Text</code> input. The operation has two parameters: <code>Text</code> and <code>Search String</code>. Input parameter values for Transformer operations are set using the Expression Editor.</p> <p></p>"},{"location":"flow-editing/transformer.html#using-transformer-results","title":"Using Transformer Results","text":"<p>The outcome of a Transformer block operation is available as a <code>result</code> element for all subsequent blocks. You can access it in the Expression Editor under the <code>DATA TRANSFORMATION RESULTS</code> section. For instance, consider a flow that includes two transformers:</p> <p></p> <p>In the Expression Editor popup, you can see the results produced by these transformers:</p> <p></p> <p>These transformer results can be incorporated into expressions used by any other block in your flow, adding a layer of flexibility and dynamism to your automation.</p> <p>For a complete list of all supported operations, refer to the Transformer block reference. Below are a few examples demonstrating the usage of some data transformation operations:</p>"},{"location":"flow-editing/transformer.html#data-mapper-example","title":"Data Mapper Example","text":"<p>Using the <code>Switch</code> operation, the transformer evaluates a value (or an expression) and returns a specific value for each configured case:</p> <p></p>"},{"location":"flow-editing/transformer.html#find-max-value-example","title":"Find Max Value Example","text":"<p>The <code>Max</code> operation in the transformer identifies the maximum number among the provided values:</p> <p></p>"},{"location":"flow-editing/transformer.html#extracting-a-substring-example","title":"Extracting a Substring Example","text":"<p>With the <code>Substring</code> operation, the transformer extracts a portion of a string from the provided text. The substring is determined by the <code>Start</code> and <code>End</code> indexes:</p> <p></p> <p>By understanding and utilizing these data transformation operations, you can enhance the functionality and efficiency of your automation flows, ensuring that your data is precisely manipulated to meet your business needs.</p>"},{"location":"flow-editing/using-ai.html","title":"AI Integration","text":"<p>FlowRunner\u2122 offers powerful AI capabilities that can enhance your applications and workflows. By integrating AI into your flows, you can add intelligent decision-making, automation, and enhanced functionality. This chapter provides an overview of the key AI-powered features in FlowRunner\u2122, each offering unique ways to bring artificial intelligence into your logic.</p>"},{"location":"flow-editing/using-ai.html#ai-router","title":"AI Router","text":"<p>The AI Router allows you to route flows dynamically based on the results of AI-powered analysis. It acts as a decision-making tool that uses AI to evaluate input data and decide which path a flow should follow. For example, the AI Router can be used for natural language processing (NLP) to understand and classify user input, route requests to appropriate services, or perform sentiment analysis to tailor responses in customer interactions.</p> <p>With AI Router, your flows can make smarter decisions based on patterns, trends, or natural language inputs, ensuring that your application can adapt in real-time to different situations or data inputs. </p> <p>For more information about the functionality, to learn how to configure and use AI Routers, visit the AI Router section of this guide.</p> <p></p>"},{"location":"flow-editing/using-ai.html#ai-assistants","title":"AI Assistants","text":"<p>AI Assistants bring automation and intelligent behavior to your applications. They work as virtual agents, capable of handling tasks such as processing text, making recommendations, or even performing interactive conversations with users. AI Assistants can be embedded directly into flows, helping you automate complex processes that require understanding, learning, and decision-making.</p> <p>These assistants can be trained to handle specific tasks like customer support, data extraction, or even more advanced AI-driven workflows. By integrating AI Assistants into FlowRunner\u2122, you can make your applications more interactive, responsive, and automated.</p> <p>For more information about API Assistants, visit the AI Assistants section of this guide.</p> <p></p>"},{"location":"flow-editing/using-ai.html#ai-image-analysis-in-conditions","title":"AI Image Analysis in Conditions","text":"<p>The AI Image Check in Conditions feature allows you to use AI to analyze images and make decisions based on the results. This capability can be embedded into flow conditions, enabling your application to trigger actions based on image recognition or analysis.</p> <p>For instance, you could use this feature to verify if an uploaded image meets certain criteria, detect objects within an image, or check for specific visual content. This AI-driven image analysis opens up possibilities for intelligent image processing, security checks, or even quality control workflows within your applications.</p> <p></p> <p>The integration of AI in FlowRunner\u2122 allows you to create smarter, more dynamic workflows. With the AI Router, AI Assistants, and AI Image Check in Conditions, you can bring intelligent automation, decision-making, and image recognition to your applications. Each of these capabilities is covered in more detail in the corresponding sections of this guide, where you\u2019ll learn how to use them to enhance your workflows and unlock new potential for your applications.</p>"},{"location":"flow-editing/valuerouter.html","title":"Value Routing","text":"<p>The Value Router block is a versatile routing utility in FlowRunner that allows you to dynamically direct flow execution based on evaluated values. By defining multiple branches with flexible matching criteria, it enables you to split workflows into precise execution paths based on data content, user inputs, or computed results. The block provides sophisticated routing logic while maintaining clean, readable workflow designs.</p> <p>The Value Router block evaluates a single input value against multiple branch conditions and routes execution to the appropriate path. Whether you need simple equality matching, collection-based routing, or range-based decisions, this block provides the flexibility to handle complex routing scenarios with precision and clarity.</p> <p>Common use cases include routing based on user roles or permissions, directing workflows based on data categories or types, implementing approval workflows with different paths for various scenarios, handling API responses with multiple possible outcomes, and creating dynamic workflows that adapt to changing business rules or thresholds.</p> <p></p>"},{"location":"flow-editing/valuerouter.html#block-configuration","title":"Block Configuration","text":"<p>The Value Router block consists of a primary evaluation field and multiple branch configurations that define the routing logic.</p>"},{"location":"flow-editing/valuerouter.html#value-to-evaluate","title":"Value to Evaluate","text":"<p>The \"Value to Evaluate\" field specifies the data that will be compared against branch conditions to determine routing. This field supports the Expression Editor, allowing you to select values from previous blocks, trigger data, or computed expressions.</p> <p></p> <p>Common Evaluation Sources</p> <ul> <li>User attributes: <code>User.role</code>, <code>User.department</code>, <code>User.accountType</code></li> <li>API response data: <code>APIResponse.status</code>, <code>APIResponse.category</code></li> <li>Computed values: <code>OrderTotal.amount</code>, <code>ProcessingResult.score</code></li> <li>Trigger data: <code>WebhookData.eventType</code>, <code>FormSubmission.priority</code></li> </ul> <p>The value you specify here becomes the basis for all branch matching logic, so choose data that provides meaningful differentiation for your workflow routing needs.</p>"},{"location":"flow-editing/valuerouter.html#branch-configuration","title":"Branch Configuration","text":"<p>The Value Router block allows you to create multiple branches, each representing a different execution path based on specific matching criteria. You can add as many branches as needed to handle your routing scenarios, with each branch configured independently.</p> <p>Available Branch Types:</p> <ul> <li>Single Value Matching: Route when the evaluated value exactly equals one specific value</li> <li>Collection Matching: Route when the evaluated value matches any value from a specified list</li> <li>Range Matching: Route when the evaluated value falls within a numeric range</li> </ul> <p>Each branch operates independently, and the Value Router will route to the first branch whose conditions are met, making branch order important for overlapping conditions.</p> <p></p> <p>Each branch in the Value Router represents a potential execution path with its own matching criteria. You can create multiple branches to handle different scenarios and values.</p>"},{"location":"flow-editing/valuerouter.html#branch-name","title":"Branch Name","text":"<p>The Branch Name field assigns a descriptive label to each routing path. This name becomes the connector label on the block, making your workflow more readable and self-documenting.</p> <p>Naming Best Practices</p> <ul> <li>Use descriptive names that clearly indicate the routing purpose</li> <li>Examples: \"Admin Users\", \"High Priority Orders\", \"Approved Status\", \"Weekend Processing\"</li> <li>Avoid generic names like \"Branch 1\" or \"Option A\"</li> <li>Consider using business terminology that stakeholders will understand</li> </ul>"},{"location":"flow-editing/valuerouter.html#value-mode-options","title":"Value Mode Options","text":"<p>The Value Mode dropdown determines how the branch matching logic operates, providing three distinct matching patterns for different use cases.</p>"},{"location":"flow-editing/valuerouter.html#single-value","title":"Single Value","text":"<p>When \"Single Value\" is selected, the branch matches when the \"Value to Evaluate\" exactly equals the specified value. This mode is ideal for precise matching scenarios.</p> <p>Single Value Configuration:</p> <ul> <li>Value Field: Input field supporting Expression Editor for dynamic values</li> <li>Matching Logic: Exact equality comparison</li> <li>Use Cases: User roles, status codes, specific categories, boolean flags</li> </ul> <p>Example Configuration</p> Field Value Branch Name Admin Access Value Mode Single Value Value \"administrator\" <p>This branch activates when <code>Value to Evaluate</code> equals exactly \"administrator\".</p>"},{"location":"flow-editing/valuerouter.html#collection-of-values","title":"Collection of Values","text":"<p>The \"Collection of Values\" mode allows you to specify multiple values that can trigger the same branch. If the \"Value to Evaluate\" matches any value in the collection, the branch is selected.</p> <p>Collection Configuration:</p> <ul> <li>Multiple Value Fields: Add values using the \"+\" button</li> <li>Expression Editor Support: Each field supports dynamic values</li> <li>Matching Logic: OR logic - matches if evaluation equals any specified value</li> <li>Use Cases: Multiple user roles, various status categories, different product types</li> </ul> <p>Example Configuration</p> Field Value Branch Name Management Access Value Mode Collection of Values Value 1 \"manager\" Value 2 \"supervisor\" Value 3 \"director\" <p>This branch activates when <code>Value to Evaluate</code> equals \"manager\", \"supervisor\", or \"director\".</p>"},{"location":"flow-editing/valuerouter.html#range-of-values","title":"Range of Values","text":"<p>The \"Range of Values\" mode enables numeric range matching, routing execution when the evaluated value falls within specified boundaries.</p> <p>Range Configuration:</p> <ul> <li>From Field: Lower boundary (inclusive)</li> <li>To Field: Upper boundary (inclusive)</li> <li>Expression Editor Support: Both fields support dynamic values</li> <li>Matching Logic: Inclusive range check (From \u2264 value \u2264 To)</li> <li>Use Cases: Order amounts, user ages, scores, quantities, time periods</li> </ul> <p>Example Configuration</p> Field Value Branch Name High Value Orders Value Mode Range of Values From 1000 To 5000 <p>This branch activates when <code>Value to Evaluate</code> is between 1000 and 5000 (inclusive).</p>"},{"location":"flow-editing/valuerouter.html#default-routing-with-everything-else","title":"Default Routing with Everything Else","text":"<p>The Value Router automatically includes an \"Everything Else\" branch that handles cases where the evaluated value doesn't match any configured branch criteria. This ensures robust workflow execution even with unexpected data.</p> <p>Everything Else Branch Features</p> <ul> <li>Automatic Inclusion: Always present, no configuration required</li> <li>Fallback Logic: Activates when no other branches match</li> <li>Error Prevention: Prevents workflow failures from unmatched values</li> <li>Debugging Aid: Useful for logging unexpected values or implementing fallback actions</li> </ul> Common Everything Else Uses <ul> <li>Error logging and notification</li> <li>Default processing paths</li> <li>Fallback business logic</li> <li>Data validation and quality checks</li> </ul>"},{"location":"flow-editing/valuerouter.html#execution-flow-and-branch-selection","title":"Execution Flow and Branch Selection","text":"<p>The Value Router evaluates branches in the order they are configured and routes to the first matching branch. Understanding this evaluation order helps you design effective routing logic.</p>"},{"location":"flow-editing/valuerouter.html#evaluation-process","title":"Evaluation Process","text":"<ol> <li>Value Assessment: The \"Value to Evaluate\" is computed using current workflow context</li> <li>Branch Testing: Each branch is tested in configuration order</li> <li>First Match Selection: The first branch meeting its criteria is selected for execution</li> <li>Everything Else Fallback: If no branches match, the Everything Else path is taken</li> </ol>"},{"location":"flow-editing/valuerouter.html#branch-priority-considerations","title":"Branch Priority Considerations","text":"<p>Since evaluation stops at the first match, arrange branches strategically:</p> <ul> <li>Place more specific conditions before general ones</li> <li>Order range conditions to avoid overlap conflicts</li> <li>Consider the likelihood of different values when ordering branches</li> </ul>"},{"location":"flow-editing/variables.html","title":"Variables and Data Buckets","text":"<p>Variables in FlowRunner\u2122 are a method for storing and accessing data in your flow\u2019s actions, transformers, and conditions. Think of each variable as a drawer with a label. You can store any type of data in these drawers, such as string literals, numbers, dates, boolean values, data collections, or key/value structures. By naming these drawers, you can easily recall and use the data whenever needed.</p> <p>To further organize your variables, FlowRunner\u2122 supports a concept called Data Buckets. A data bucket is like a collection of drawers, grouped under a single name. This helps in logically organizing and managing your variables. For instance, if you have variables containing configuration parameters that apply to the entire flow, you might place them in a data bucket named <code>Global Config Params</code>.</p>"},{"location":"flow-editing/variables.html#set-variables-block","title":"Set Variables Block","text":"<p>To set or change a variable, you use the <code>Set Variables</code> block.</p> <p></p> <p>Before you assign any variable values, make sure to specify a data bucket where the changes will occur. In the screenshot below the selected data bucket is called <code>My Flow Vars</code>:</p> <p></p> <p>It is easy to create new data buckets - simply type in a name for your data bucket and select the option below to create it:</p> <p></p>"},{"location":"flow-editing/variables.html#setting-and-changing-variables","title":"Setting and Changing Variables","text":"<p>The process involves identifying a variable name and assigning a value to it, both done using the Expression Editor. This method allows the variable name and value to be dynamically calculated, providing great flexibility. </p> <p>Consider the following example - it creates a variable called <code>has phone number</code>. The value assigned to the variable is dynamic. Using the Expression Editor, you can create an expression that sets the value of <code>has phone number</code> based on data available within the current flow.</p> <p></p> <p>When you build an expression to calculate a value for your variable, you can reference other variables. This means that the new variable\u2019s value can be composite, drawing from any data available in the current <code>Set Variables</code> block. Below is a screenshot of the Expression Editor showing how the expression for the <code>has phone number</code> variable is composed:</p> <p></p>"},{"location":"flow-editing/variables.html#accessing-variables","title":"Accessing Variables","text":"<p>To access your variables, you use the Expression Editor. This tool includes a dedicated section that lists all variables available for the current block. For example, in the screenshot below, you can see there is one variable in the <code>My Flow Vars</code> data bucket, named <code>has phone number</code>.</p> <p></p> <p>By understanding how to effectively set, change, and access variables, you can build more dynamic and responsive automation flows. Variables help you manage data efficiently, ensuring that your workflows are both flexible and powerful.</p>"},{"location":"flow-editing/waitblock.html","title":"Implementing Delays","text":"<p>Introducing pauses or delays in your automation flows can be crucial for timing certain actions perfectly. Imagine you want to send a welcome email to a new user after they register for your service. To avoid sending it instantly and to make the process feel more personalized, you might decide to delay the email delivery. Backendless makes this easy with the <code>Wait</code> block, allowing you to incorporate such pauses seamlessly into your flows.</p>"},{"location":"flow-editing/waitblock.html#why-wait","title":"Why <code>Wait</code>?","text":"<p>The <code>Wait</code> block serves a simple yet powerful purpose: it pauses the flow of actions for a specified period. This feature can be handy in various scenarios, such as delaying notifications, emails, or any other actions, to ensure they occur at the most opportune moment.</p>"},{"location":"flow-editing/waitblock.html#setting-up-delays","title":"Setting Up Delays","text":"<p>The <code>Wait</code> block offers two approaches for injecting a delay in the flow execution. Each approach is designed to meet different needs:</p>"},{"location":"flow-editing/waitblock.html#simple-mode","title":"Simple Mode","text":"<p>For direct and uncomplicated delays, the Simple Mode lets you specify a fixed delay in days, hours, minutes, or seconds. This mode is ideal when you need a consistent pause in your flow. The requirement is to set at least one of these time units to a non-zero value. </p>"},{"location":"flow-editing/waitblock.html#advanced-mode","title":"Advanced Mode","text":"<p>For scenarios where the delay needs to be more flexible, the Advanced Mode comes into play. This mode utilizes the Expression Editor, which allows you to calculate the delay period dynamically. Whether through a variable, a property, or a custom expression, the resulting value determines the length of the pause, measured in seconds. </p> <p>Implementing delays in Backendless automation flows offers a straightforward method to time your actions precisely, enhancing the overall effectiveness and personalization. Whether you're aiming for simplicity with a fixed delay or seeking flexibility with dynamic calculation, the <code>Wait</code> block provides the necessary functionality to integrate these pauses into your flows effortlessly.</p>"},{"location":"flow-editing/workingwithblocks.html","title":"Working with Blocks","text":"<p>Blocks are the core components of your workflows in FlowRunner\u2122, each offering distinct functionality to automate tasks and processes. While individual blocks have unique capabilities, the principles for adding, connecting, and editing them remain consistent. This chapter provides an overview of these principles to help you efficiently build and refine workflows in the Flow Editor.  </p>"},{"location":"flow-editing/workingwithblocks.html#the-basics-of-blocks","title":"The Basics of Blocks","text":"<ul> <li> <p>Starting Point: Every flow begins with a <code>Start</code> marker, which designates the starting point of your workflow. This marker is a fixed reference for your automation's entry point. </p> Changing the Starting Point <p>To change the starting block, follow the steps outlined in the interactive tutorial below: </p> </li> <li> <p>Adding Blocks: Drag blocks from the Blocks Toolbox onto the Editor Canvas to build your workflow. Each block adds new capabilities to your automation.  </p> </li> <li> <p>Initiating Flows: A flow can start with various blocks, including triggers, actions, or groups. For example, triggers wait for specific events to activate the subsequent blocks in your workflow.  </p> </li> </ul>"},{"location":"flow-editing/workingwithblocks.html#connecting-blocks","title":"Connecting Blocks","text":"<ul> <li> <p>Flow Transitions: Blocks are connected by lines that represent the execution flow, guiding the logic from one block to the next.  To remove a transition, hover the mouse over the connecting line and click the Remove Connection icon.</p> <p></p> </li> <li> <p>Multiple Successors: A block can lead to multiple successors, enabling parallel execution. For example, in the image below, the <code>Callback from CRM</code> trigger activates two successors, both executed when the trigger fires: </p> </li> <li> <p>Multiple Predecessors: Similarly, a block can have multiple predecessors, allowing different triggers or conditions to converge. In the image below, the <code>Send SMS</code> block has two predecessors, executing immediately after each: </p> <p>Handling Concurrency with Multiple Predecessors</p> <p>Use Action Groups or Trigger Groups to manage concurrency effectively.  </p> </li> </ul>"},{"location":"flow-editing/workingwithblocks.html#editing-and-viewing-properties","title":"Editing and Viewing Properties","text":"<p>Clicking a block opens its properties in the Property Editor, where you can customize its settings to fit your automation needs. </p> <p>The properties displayed vary depending on the block. For detailed information about specific blocks, refer to the relevant sections in the documentation.  </p>"},{"location":"flow-execution/analytics.html","title":"Analytics","text":""},{"location":"flow-execution/analytics.html#blockers","title":"Blockers","text":"<ul> <li>https://backendless.atlassian.net/browse/AUTO-497</li> </ul>"},{"location":"flow-execution/overview.html","title":"Running Flows","text":"<p>\"Running a flow\" means executing its sequence of actions, triggers, conditions, and transformations. How a flow runs depends on its structure and configuration. This section explains the different ways you can launch flows in FlowRunner\u2122.</p>"},{"location":"flow-execution/overview.html#basic-rules-for-launching-flows","title":"Basic Rules for Launching Flows","text":"<p>To ensure your flows start smoothly, follow these basic rules:</p> <ol> <li>Enable the Flow: A flow must be in the <code>LIVE</code> state to run:    </li> <li> <p>Starting Without a Schedule: If a flow doesn\u2019t have a schedule, it must be started with a special command called <code>CallFlow</code>.</p> <p>Note</p> <p>There is an exception to this rule for flows that start with a trigger. In this case, the <code>CallFlow</code> command is optional. The flow can begin with the activation of the first trigger. However, initiating the flow with the <code>CallFlow</code> command can be beneficial. See the section on the <code>CallFlow</code> API for more details.</p> </li> <li> <p>Scheduled Flows: When a flow has a schedule, it will automatically run according to that schedule. The <code>CallFlow</code> command is not needed as the scheduler handles the execution.    </p> </li> <li>Multiple Executions: A single flow can have multiple executions, some running in parallel.</li> <li>Unique Identifiers: Every execution of a flow has a unique identifier called <code>executionId</code>.</li> </ol> <p>Below is a diagram illustrating the \"launch rules\":</p> <pre><code>flowchart TD\n    GOLIVE(Flow is LIVE) --&gt; STARTS_WITH_ACTION\n    STARTS_WITH_ACTION{Does the Flow start with an Action?} --&gt;|YES|HASSCHEDULE \n    STARTS_WITH_ACTION --&gt; |No, starts with a Trigger|START_TRIGGER\n    HASSCHEDULE{Has a Schedule?} --&gt;|YES|FLOW_STARTS\n    HASSCHEDULE --&gt;|NO|NEEDS_CALL_FLOW\n    NEEDS_CALL_FLOW --&gt; FLOW_STARTS\n    START_TRIGGER --&gt; FLOW_STARTS\n    NEEDS_CALL_FLOW(\"`Use *CallFlow*`\")\n    START_TRIGGER(\"`Activate Trigger.\n    ...\n    May optionally \n    use *CallFlow*`\")\n    FLOW_STARTS(Flow Instance is Started)</code></pre> <p>Don't worry if this sounds complex. We'll break down this information further.</p>"},{"location":"flow-execution/overview.html#flow-without-a-schedule","title":"Flow without a Schedule","text":"<p>For a flow without a schedule, once you enable it (putting it in the <code>LIVE</code> state), it won\u2019t run automatically. If the flow starts with a trigger, the trigger needs to be activated for the flow to run. If the flow starts with an action, it must be started using the <code>CallFlow</code> command/API.</p>"},{"location":"flow-execution/overview.html#flow-with-a-schedule","title":"Flow with a Schedule","text":"<p>For a scheduled flow that is in the <code>LIVE</code> state, the scheduler starts new executions automatically. The <code>CallFlow</code> command/API is not needed in this case. If the flow starts with an action, the action block will execute with each new iteration of the schedule. If the flow starts with a trigger, each new execution will wait for the trigger to be activated.</p>"},{"location":"flow-execution/overview.html#callflow-commandapi","title":"CallFlow Command/API","text":"<p>The <code>CallFlow</code> command creates a new execution of a flow. This command identifies the flow to execute and can optionally accept a key/value structure (object) to pass into the executed flow. The <code>CallFlow</code> command is available in several formats:</p> <ol> <li>FlowRunner\u2122 Action: Execute a flow from another flow.     </li> <li>Codeless block: Execute a flow from your UI application created with UI Builder or from Backendless Cloud Code. You can find the <code>Call Flow</code> Codeless block in the Codeless <code>Logic Editor</code>. Every flow you create will have a dedicated menu item in the <code>FLOWRUNNER</code> section:      The <code>Call Flow</code> Codeless block returns an object which contains the <code>executionId</code> property. The value of the property can be used later on to activate a trigger in the same flow execution. Below is an example of how to obtain the <code>executionId</code> value from the <code>Call Flow</code> response:     </li> <li> <p>REST API endpoint: Execute a flow from any third-party system.</p> <p>Endpoint:  <pre><code>POST https://xxxx.backendless.app/api/automation/flow/activate-by-name\n</code></pre></p> <p>HTTP Headers: <pre><code>Content-Type: application/json\nuser-token: value \n</code></pre> The <code>user-token</code> header is optional. When it is used, the activated flow receives the identity of the user represented by the token.</p> <p>Request Body: <pre><code>{\n  \"name\": \"Flow name. Required Value\",\n  \"initialData\": {\n    \"A valid JSON object containing initial flow data. Optional\"\n  }\n}\n</code></pre> The <code>initialData</code> property in the request body is optional. When provided, the value is passed into the flow execution. It will be available through the Expression Editor interface.</p> <p>Response Body <pre><code>{\n  \"executionId\": \"String\"\n}\n</code></pre></p> </li> </ol> <p>The return value from the <code>CallFlow</code> operation is an <code>executionId</code> assigned to the created flow execution. This ID is important if you need to \"target\" triggers from that specific execution. When calling a trigger, you can pass the <code>executionId</code> parameter to activate the trigger in a specific execution.</p>"},{"location":"flow-management/bestpractices.html","title":"Automations Best Practices","text":"<p>Building efficient, reliable, and scalable workflows in FlowRunner\u2122 requires thoughtful planning and smart design choices. These best practices will help you create automations that are robust, maintainable, and aligned with your goals.  </p>"},{"location":"flow-management/bestpractices.html#start-with-a-clear-objective","title":"Start with a Clear Objective","text":"<p>Define the purpose of your automation. Understand the task or business process it addresses and identify the desired outcomes. Clear objectives keep your workflows focused and effective.  </p>"},{"location":"flow-management/bestpractices.html#plan-before-you-build","title":"Plan Before You Build","text":"<p>Sketch out your workflow before jumping into the Flow Editor. Identify triggers, actions, conditions, and data transformations. For complex workflows, create a flowchart or diagram to visualize the process and spot potential bottlenecks.  </p>"},{"location":"flow-management/bestpractices.html#keep-it-simple","title":"Keep It Simple","text":"<p>Start with the simplest possible design. Simplicity minimizes errors and makes workflows easier to maintain. You can always add complexity later as your needs evolve.  </p>"},{"location":"flow-management/bestpractices.html#embrace-modular-design","title":"Embrace Modular Design","text":"<p>Break large workflows into smaller, reusable components. This modular approach improves readability and simplifies maintenance and scaling.  </p>"},{"location":"flow-management/bestpractices.html#use-descriptive-names","title":"Use Descriptive Names","text":"<p>Name flows, blocks, and versions clearly and consistently. Descriptive names make workflows easier to understand and manage, especially for collaborators.  </p>"},{"location":"flow-management/bestpractices.html#test-frequently","title":"Test Frequently","text":"<p>Use Test Mode often to verify the logic and execution of your flows. Testing individual components during development helps catch issues early.  </p>"},{"location":"flow-management/bestpractices.html#document-your-workflows","title":"Document Your Workflows","text":"<p>Include detailed descriptions of flows and versions to explain their purpose and functionality. Documentation is invaluable for future reference, especially in collaborative projects.  </p>"},{"location":"flow-management/bestpractices.html#design-for-scalability","title":"Design for Scalability","text":"<p>Anticipate future growth in data volume or user activity. Structure your workflows to handle increased demands without major rework.  </p>"},{"location":"flow-management/bestpractices.html#review-and-refine-regularly","title":"Review and Refine Regularly","text":"<p>Periodically evaluate your workflows to ensure they\u2019re performing as intended. Update them based on feedback and changing requirements to maintain efficiency and relevance.  </p>"},{"location":"flow-management/bestpractices.html#stay-updated","title":"Stay Updated","text":"<p>Keep up with FlowRunner\u2122 updates and new features. Leveraging the latest tools can significantly enhance your workflows and expand their capabilities.  </p>"},{"location":"flow-management/bestpractices.html#prioritize-security","title":"Prioritize Security","text":"<p>Set and review execution permissions carefully. Limit access to sensitive flows and regularly update permissions to protect your data and processes.  </p>"},{"location":"flow-management/bestpractices.html#conclusion","title":"Conclusion","text":"<p>By following these best practices, you\u2019ll create workflows that are not just functional but also scalable, maintainable, and secure. As you grow more familiar with FlowRunner\u2122, these principles will help you engineer automation solutions that deliver exceptional results.  </p>"},{"location":"flow-management/callflowpermission.html","title":"Flow Permissions","text":"<p>Controlling who can activate your automation flows is essential for maintaining security and ensuring smooth operations in FlowRunner\u2122. Execution permissions let you define the identities or security roles that can activate your flows. This applies to human users as well as service accounts.</p> <p>This feature allows you to grant access to specific individuals or groups via roles and enable integration with external systems, ensuring they can invoke flows securely.</p> <p>By setting clear permissions, you safeguard your automation while giving authorized entities the access they need.</p> <p>Note</p> <p>This section uses the term activate when it refers to the concept of starting a flow. To activate a flow, it must have the <code>LIVE</code> status. To activate the flow, use the <code>Call Flow</code> API or the Call Flow action block. (both are documented here).</p> <p>You can access flow permissions by selecting a flow version and clicking the PERMISSIONS tab:</p> <p></p>"},{"location":"flow-management/callflowpermission.html#execution-permissions","title":"Execution Permissions","text":"<p>Execution permissions allow you to control launch access to your flows, determining which users, roles, or systems can activate them. These permissions apply to all versions of a flow, ensuring consistent access management across your automation. </p> <p>Flows can be triggered in two primary ways:  </p> <ul> <li><code>Call Flow</code> API: External systems or services can trigger flows via API, enabling integration with tools and platforms outside your FlowRunner\u2122 automation.</li> <li>The <code>Call Flow</code> Action Block: Use this to chain flows together, creating complex and efficient automation systems.  </li> </ul>"},{"location":"flow-management/callflowpermission.html#granting-or-denying-permissions","title":"Granting or Denying Permissions","text":"<p>Each flow in FlowRunner\u2122 can have a custom set of permissions. You can assign these permissions to:  </p> <ul> <li>Individual Users: Grant or deny access directly to specific user accounts, controlling who can activate the flow.  </li> <li>Security Roles: Assign permissions to roles to efficiently manage access for groups of users.  </li> </ul>"},{"location":"flow-management/callflowpermission.html#system-level-roles","title":"System-Level Roles","text":"<p>System-level roles, such as <code>NonAuthenticatedUser</code> and <code>AuthenticatedUser</code>, allow you to manage access based on user authentication. For instance, denying permission to the <code>NonAuthenticatedUser</code> role ensures only logged-in users can activate the flow.  </p>"},{"location":"flow-management/callflowpermission.html#default-permissions","title":"Default Permissions","text":"<p>By default, all users and roles have permission granted to activate flows. This setup simplifies testing and integration during development. Once your flows are ready for production, you can restrict permissions in the UI to meet your app\u2019s security needs.  </p>"},{"location":"flow-management/callflowpermission.html#changing-permissions-in-the-ui","title":"Changing Permissions in the UI","text":"<p>Configuring execution permissions is straightforward. Here\u2019s how to manage access for your flows:  </p> <ol> <li>Navigate to the Flow Manager and locate the flow you want to configure.  </li> <li>Click the PERMISSIONS tab.  </li> <li>The interface consists of two tabs:  <ul> <li>USER PERMISSIONS: Manage access for individual users.  </li> <li>ROLES PERMISSIONS: Set permissions for user roles.  </li> </ul> </li> <li>Adjust permissions by toggling the icons next to each user or role:  <ul> <li>Gray Checkmark: Permission is inherited from app-wide settings.  </li> <li>Green Checkmark: Permission is explicitly granted for this flow.  </li> <li>Red X: Permission is explicitly denied for this flow.  </li> </ul> </li> </ol> <p>Execution permissions are critical to securing your FlowRunner\u2122 automations. By tailoring access for users, roles, and external systems, you can maintain both efficiency and control. Backendless makes this process intuitive, so you can focus on building great applications while ensuring your automations remain secure.  </p>"},{"location":"flow-management/createflow.html","title":"Creating New Flows","text":"<p>Embarking on your journey with FlowRunner\u2122 begins with creating new flows. Flows are the essence of automation, enabling you to streamline complex processes into efficient, automated sequences. This chapter focuses on the initial steps of setting up a flow: crafting its identity with a name and enriching it with a description. Here, we'll guide you through the straightforward process of bringing a new flow to life.</p>"},{"location":"flow-management/createflow.html#creating-a-flow","title":"Creating a Flow","text":"<p>The creation of a new flow in FlowRunner\u2122 is both a simple and significant first step toward automating your business processes. Follow these steps to create your flow:</p> <ol> <li> <p>Navigate to Flow Manager: Your adventure starts in the Flow Manager, the control center for all your automation activities. Here, you'll find the tools and options to manage your flows.</p> </li> <li> <p>Create New Flow: Look for the <code>CREATE A NEW FLOW</code> button. This is your gateway to initiating a new automation. Clicking this button brings you to the first step of flow creation.</p> <p></p> </li> <li> <p>Enter Flow Name: Upon initiating a new flow, you\u2019ll be prompted to give it a name. This name is how you'll identify your flow within the FlowRunner\u2122 platform, so choose something descriptive and meaningful.</p> </li> <li> <p>Add a Description (Optional): While optional, adding a description is highly recommended. This is where you outline the flow's purpose and any other important notes that will guide you or your collaborators in understanding its function.</p> </li> <li> <p>Confirm Creation: With a name and an optional description in place, confirm the creation of your new flow by clicking the <code>CREATE</code> button. This action generates the flow and its first editable version within the system.</p> </li> </ol>"},{"location":"flow-management/createflow.html#flow-name","title":"Flow Name","text":"<p>The name you choose for your flow serves as its primary identifier and should succinctly convey its purpose. Here are some tips for naming your flow:</p> <ul> <li> <p>Be Descriptive and Specific: Use names that clearly indicate what the flow does, such as \u201cCustomer Onboarding Process\u201d or \u201cWeekly Sales Report Generator.\u201d</p> </li> <li> <p>Consistency is Key: If your organization has existing naming conventions, stick to them. Consistency helps with organization and ease of finding specific flows later.</p> </li> </ul>"},{"location":"flow-management/createflow.html#flow-description","title":"Flow Description","text":"<p>Though optional, a well-crafted description is invaluable. It provides context and clarifies the flow\u2019s intent and mechanics, especially for collaborative projects. When adding a description, consider the following:</p> <ul> <li> <p>Outline the Flow\u2019s Purpose: Explain what the flow is designed to achieve. This overview helps anyone working with or reviewing the flow to understand its objectives quickly.</p> </li> <li> <p>Include Key Details: Mention any important triggers, actions, or conditions that are central to the flow\u2019s operation. This information can be crucial for maintenance or future modifications.</p> </li> <li> <p>Keep it Clear and Concise: While being thorough, aim for clarity and brevity. The goal is to communicate effectively, not to overwhelm with details.</p> </li> </ul> <p>Once created, your new flow and its first version are ready for further development. At this stage, you can begin the creative process of structuring your automation by planning and eventually implementing the flow\u2019s components and logic. This initial step of naming and describing your flow lays the groundwork for the automation magic that follows.</p>"},{"location":"flow-management/deleteflow.html","title":"Deleting Flows","text":"<p>Deleting flows helps keep your automation workspace organized by removing flows that are no longer needed. Whether created for testing or no longer relevant, deleting flows is straightforward in FlowRunner\u2122.  </p>"},{"location":"flow-management/deleteflow.html#how-to-delete-a-flow","title":"How to Delete a Flow","text":"<ol> <li>Open the Flow Manager and select the flow you want to delete.  </li> <li>Click the  icon to open the Flow admin menu.</li> <li>Click the Delete* Flow option.  </li> <li>Confirm the deletion in the popup. Deleting a flow will permanently remove all its versions and associated analytics.  </li> </ol>"},{"location":"flow-management/deleteflow.html#key-considerations","title":"Key Considerations","text":"<ul> <li>Active Flows: You cannot delete a flow with a <code>LIVE</code> version. Stop any running versions before proceeding.  </li> <li>Permanent Action: Deleting a flow is irreversible. All data, including versions and analytics, will be permanently removed.  </li> <li>Dependencies: Ensure the flow isn\u2019t part of other workflows or dependencies that could disrupt your automation.  </li> </ul> <p>By carefully managing deletions, you can keep your FlowRunner\u2122 environment clean, efficient, and focused on the flows that matter.  </p>"},{"location":"flow-management/flowappearance.html","title":"Customizing Flow Appearance","text":"<p>Customizing the appearance of your flows helps you stay organized and improves visual clarity, especially as your workflows grow in number. FlowRunner\u2122 allows you to change the color of a flow's title bar, making it easier to identify and categorize your flows at a glance.  </p>"},{"location":"flow-management/flowappearance.html#how-to-change-a-flows-color","title":"How to Change a Flow\u2019s Color","text":"<p>To change the color of a flow\u2019s title bar:  </p> <ol> <li>Locate the flow whose title bar color you want to change.</li> <li>Find the Change Color icon on the right side of the flow\u2019s title bar and click it.</li> <li>Use the color picker to select your preferred color. The title bar will update instantly.</li> </ol>"},{"location":"flow-management/flowappearance.html#a-look-ahead","title":"A Look Ahead","text":"<p>While the current customization options focus on title bar colors, more features are in development to enhance the way you personalize your workflows. For now, this straightforward feature is a powerful way to organize your flows and bring a touch of personality to your automation processes.  </p>"},{"location":"flow-management/import-export.html","title":"Import/Export","text":"<p>The Import/Export feature in FlowRunner\u2122 makes it easy to back up and share your automation flows. By exporting a flow version, you create a file containing everything needed to replicate or migrate the version, including its automation logic, schedule (if any), and SLA goals (if any). This file can later be used to recreate the version within the same app or in another Backendless environment.  </p>"},{"location":"flow-management/import-export.html#exporting-a-flow-version","title":"Exporting a Flow Version","text":"<p>Exporting a flow version is quick and simple:  </p> <ol> <li>Locate the version you want to export in the Flow Manager.  </li> <li>Navigate to the VERSION ADMIN tab.</li> <li> <p>Click the START EXPORT button.  </p> <p></p> </li> </ol> <p>FlowRunner\u2122 will generate an export file that includes:  </p> <ul> <li>The version\u2019s automation flow and logic.  </li> <li>Any associated schedule.  </li> <li>Any defined SLA goals.  </li> </ul> <p>The file is then available for download and can be stored or shared as needed.  </p>"},{"location":"flow-management/import-export.html#importing-a-flow-version","title":"Importing a Flow Version","text":"<p>FlowRunner\u2122 offers two ways to import a flow version from an export file:  </p>"},{"location":"flow-management/import-export.html#import-into-an-existing-flow","title":"Import into an Existing Flow","text":"<p>To add a version to an existing flow:  </p> <ol> <li>Open the Flow Manager and locate the target flow (the flow where you would like to import a version to).  </li> <li>Click the hamburger icon (\u2630) located next to the flow name.</li> <li>Click the Import Flow icon in the flow\u2019s title bar.  </li> <li> <p>Use the file browser to select the export file.  </p> <p></p> </li> </ol> <p>Once imported, the flow will include a new version that is an exact replica of the exported version.  </p>"},{"location":"flow-management/import-export.html#create-a-new-flow-from-an-export","title":"Create a New Flow from an Export","text":"<p>To create a brand-new flow using an export file:  </p> <ol> <li>Click the Create a New Flow button in the Flow Manager.  </li> <li>In the Create a New Flow popup, click the Browse\u2026 button.  </li> <li> <p>Select the export file from your local machine and confirm.  </p> <p></p> </li> </ol> <p>A new flow will be created, with its first version being an identical copy of the original exported version.  </p> <p>This feature is invaluable for migrating, replicating, or sharing flows while ensuring all associated settings and configurations are preserved.  </p>"},{"location":"flow-management/renameflow.html","title":"Renaming Flows","text":"<p>Renaming flows helps keep your workflows organized and easy to identify. Whether updating a flow\u2019s name to reflect its current purpose or aligning with naming conventions, the process is quick and straightforward in Flow Manager.  </p>"},{"location":"flow-management/renameflow.html#how-to-rename-a-flow","title":"How to Rename a Flow","text":"<ol> <li>Open the Flow Manager interface.  </li> <li>Locate the flow you want to rename and click the hanburger icon \u2630 next to the flow name.</li> <li>Click the Rename Flow menu option.  </li> <li>Enter the new name in the Rename Flow popup and ensure it\u2019s unique within your workspace. Flow Manager will notify you if there\u2019s a conflict.  </li> <li>Save your changes, and the new name will update instantly.  </li> </ol>"},{"location":"flow-management/renameflow.html#tips-for-naming-flows","title":"Tips for Naming Flows","text":"<ul> <li>Be Descriptive: Use names that clearly reflect the flow\u2019s purpose or functionality.  </li> <li>Keep it Consistent: Follow any naming conventions your team or project uses.  </li> <li>Include Versioning: If applicable, add version information to differentiate iterations.  </li> <li>Keep it Concise: Avoid overly long names for better readability.  </li> </ul> <p>By keeping your flow names clear and organized, you make it easier to manage workflows and collaborate effectively in FlowRunner\u2122.  </p>"},{"location":"flow-management/scheduledflows.html","title":"Scheduled Flows","text":"<p>Scheduled Flows in FlowRunner\u2122 let you automate business processes by defining when and how often a flow should execute. Whether generating weekly reports, running maintenance tasks, or processing recurring updates, scheduled flows ensure automation runs seamlessly at the times you specify.  </p>"},{"location":"flow-management/scheduledflows.html#creating-a-schedule","title":"Creating a Schedule","text":"<p>To set up a schedule for a flow version:  </p> <ol> <li>Open the Flow Manager, select your flow/version and navigate to the VERSION ADMIN tab.</li> <li> <p>Click the CONFIGURE SCHEDULE button in the Flow Schedule section: </p> </li> <li> <p>In the <code>Configure Flow Schedule</code> popup, define the schedule\u2019s parameters, including:  </p> </li> <li>Start Time: When the flow should first execute.  </li> <li>Frequency: How often the flow should run.  </li> <li>Expiration (optional): The date/time when the schedule should stop automatically.  </li> </ol> <p></p> <p>Schedules are activated when the flow version is started, either through the FlowRunner\u2122 user interface or programmatically via the API. Note that each flow version can have its own unique schedule.  </p>"},{"location":"flow-management/scheduledflows.html#flow-execution-policy","title":"Flow Execution Policy","text":"<p>The Flow Execution Policy section in the <code>Configure Flow Schedule</code> popup provides additional control over how your flows are triggered:  </p> <ul> <li>Allow only scheduled flow instances: Enabling this option ensures that new flow instances are created exclusively by the scheduler. If disabled, and the flow begins with a trigger, instances can also be created by events generated by the trigger. Use this option to guarantee that scheduling remains the sole mechanism for starting new instances when enabled.  </li> <li>Allow flow instantiation via API when the schedule expires: This option is available only when an expiration date/time is set. When enabled, new flow instances can be created via the Call Flow API after the schedule has expired.  </li> </ul> <p>These options give you fine-grained control over how and when flows can be executed, ensuring alignment with your automation strategy.  </p>"},{"location":"flow-management/scheduledflows.html#start-times-and-expiration","title":"Start Times and Expiration","text":"<p>The start time determines when a schedule first triggers and sets the timing for recurring executions. Adding an expiration date ensures the schedule stops after a specific period, preventing unnecessary resource usage and providing better control over long-running processes.  </p>"},{"location":"flow-management/scheduledflows.html#frequency-options","title":"Frequency Options","text":"<p>FlowRunner\u2122 offers flexible frequency settings to match various automation needs:  </p> <p> </p> <ul> <li>Once: Execute the flow at a specific time.  </li> <li>Every X seconds: Repeat execution at intervals of 60 seconds or longer.  </li> <li>Daily: Run the flow every day or at custom intervals.  </li> <li>Weekly: Execute on specific days each week, ideal for tasks like reporting.  </li> <li>Monthly: Schedule execution on specific days or recurring weekdays each month.  </li> <li>Cron: Use a cron expression for advanced scheduling.  </li> </ul>"},{"location":"flow-management/scheduledflows.html#schedule-indicator","title":"Schedule Indicator","text":"<p>When a flow version has a schedule, you will see an icon indicating it:</p> <p></p>"},{"location":"flow-management/scheduledflows.html#removing-a-schedule","title":"Removing a Schedule","text":"<p>To stop a scheduled flow: 1. Open the Configure Flow Schedule popup. 2. Click the REMOVE SCHEDULING button located in the lower-right corner of the interface.</p> <p>This action deactivates the schedule, preventing future executions. Active instances of the flow that were triggered before removal will continue to run until completed.  </p>"},{"location":"flow-management/sla.html","title":"Service Level Agreements","text":"<p>// coming soon!</p>"},{"location":"flow-management/sla.html#-configure-sla-goals","title":"- Configure SLA goals","text":"<p>The Configure SLA Goals action takes you to a section of FlowRunner\u2122 where you can define service level agreement (SLA) goals for your flow. These goals help you measure and monitor compliance by evaluating whether specific outcomes or states are achieved within defined timeframes.  </p> <p>SLA goals are closely tied to business calendars, which determine your organization\u2019s operating hours. From the same section, you can manage these calendars to ensure SLA measurements accurately reflect your business\u2019s time-based expectations.  </p> <p>By setting SLA goals and linking them to operating hours, you can track performance against critical business objectives and ensure your automation processes stay on target.  </p>"},{"location":"flow-management/versionmanagement.html","title":"Version Management","text":"<p>Version management in FlowRunner\u2122 is central to keeping your workflows adaptable, organized, and reliable. A Flow Version represents a specific iteration of a workflow, capturing its configuration, functionality, and operational settings at a given point in time. Versions allow you to refine and enhance workflows while keeping the current version running smoothly.  </p>"},{"location":"flow-management/versionmanagement.html#the-purpose-of-flow-versions","title":"The Purpose of Flow Versions","text":"<p>Flow versions serve multiple purposes beyond simply enabling updates:  </p> <ul> <li>Single Active Version: Only one version of a flow can be active at any time, known as the <code>LIVE</code> state. This ensures changes can be tested and refined in separate versions without impacting the live version.  </li> <li>Dedicated Analytics: Each version maintains its own analytics data, giving you insights into its performance once it goes live and runs automation tasks. This separation makes it easy to track the success of changes or compare different iterations.  </li> <li>SLA Goals: Service Level Agreement (SLA) goals can be defined per version, ensuring each iteration aligns with your operational requirements.  </li> <li>Version-Specific Schedules: Each version can operate on its own schedule, providing flexibility in automation timing and execution.  </li> </ul>"},{"location":"flow-management/versionmanagement.html#version-statuses","title":"Version Statuses","text":"<p>Every flow version has a status that reflects its readiness and role within your automation processes. These statuses help you understand where a version stands in its lifecycle:  </p> <ul> <li>\ud83d\udd35 READY: This status means the version has successfully passed all Backendless validations. It\u2019s error-free and ready to go live at your command.  </li> <li>\ud83d\udd34 NOT READY: A version with this status contains one or more errors. Hovering over the status tag reveals a tooltip with details about the validation errors, helping you identify and resolve the issues.  </li> <li>\ud83d\udfe2 LIVE: This status indicates the version is actively running and automating the tasks it was designed for. Only one version of a flow can have this status at any time.  </li> </ul>"},{"location":"flow-management/versionmanagement.html#version-editing","title":"Version Editing","text":"<p>You can edit any flow version that is not in the <code>LIVE</code> status. Click the \"EDIT FLOW\" button to open the Flow Editor interface, where you can modify the version\u2019s automation logic. The Flow Editor provides all the tools you need to adjust workflows, implement updates, and refine functionality.</p> <p></p>"},{"location":"flow-management/versionmanagement.html#starting-a-version","title":"Starting a Version","text":"<p>The START FLOW button activates a flow version, making it the current <code>LIVE</code> version. Only one version of a flow can be <code>LIVE</code> at any time, ensuring your automation processes remain focused and orderly.  </p> <p>When a version is <code>LIVE</code>, additional controls become available:  </p> <ul> <li> PAUSE Temporarily halts new executions while allowing ongoing processes to finish.  </li> <li> STOP: Fully halts all executions, taking the version offline.  </li> </ul> <p></p>"},{"location":"flow-management/versionmanagement.html#version-administration-functions","title":"Version Administration Functions","text":"<p>All version management functions are available on the <code>VERSION ADMIN</code> tab:</p> <p></p>"},{"location":"flow-management/versionmanagement.html#-clone-version","title":"- Clone version","text":"<p>Cloning a version is an essential tool for experimentation and iteration. It allows you to explore new ideas or make changes without disrupting the current <code>LIVE</code> version. When you clone a version, an identical copy of the selected version is created, providing a safe space to test updates or refine functionality.  </p> <p></p> <p>The cloned version includes everything from the original, ensuring consistency and a complete starting point for modifications. This includes:  </p> <ul> <li>The schedule, if one is defined.  </li> <li>Any SLA goals associated with the original version.  </li> <li>The full configuration of all flow blocks, preserving the workflow\u2019s logic and design.  </li> </ul> <p>Cloning is particularly useful for maintaining operational continuity while developing improvements, letting you seamlessly transition updates when ready.  </p>"},{"location":"flow-management/versionmanagement.html#-configure-version-schedule","title":"- Configure version schedule","text":"<p>The Configure Schedule button opens a popup where you can set a schedule for the flow version. </p> <p></p> <p>The scheduling functionality is highly flexible, supporting a wide range of options:  </p> <ul> <li>A one-time execution.  </li> <li>Recurring schedules such as hourly, daily, or weekly.  </li> <li>Advanced configurations using cron expressions for complete customization.  </li> </ul> <p>With these options, you can tailor the flow\u2019s execution timing to fit your specific automation needs. For more information, visit the Schedule Flows section of this guide.</p>"},{"location":"flow-management/versionmanagement.html#-export-version","title":"- Export version","text":"<p>Clicking the Start Export button generates a single export file containing all the key details of the flow. The file includes:  </p> <ul> <li>The flow\u2019s automation steps.  </li> <li>The flow schedule, if one is defined.  </li> <li>SLA goals, if any are set.  </li> </ul> <p></p> <p>This export file allows you to back up your flow or transfer it to another environment while preserving all its critical configurations.  For more information, visit the Import/Export section of this guide.</p>"},{"location":"flow-management/versionmanagement.html#-delete-version","title":"- Delete version","text":"<p>If a flow version is no longer needed, you can delete it. To prevent accidental removal, this action requires confirmation before the version is permanently deleted.  For more information, see the Deleting FLows section of this guide.</p> <p></p>"},{"location":"flow-testing/action-skipping.html","title":"Skipping Actions","text":"<p>The Skip Block functionality in FlowRunner\u2122 allows flow developers to bypass the execution of an action block without disrupting the flow. This feature is particularly useful during development, debugging, or testing, enabling developers to simulate results for skipped blocks and continue building and refining workflows seamlessly.  </p> <p></p> <p>Every action block in FlowRunner\u2122 includes a Skip Block toggle. When enabled:  </p> <ol> <li>The block does not execute its intended action.  </li> <li>Developers can specify a Simulated Result, which will be treated as if the block had executed successfully.  </li> <li>The simulated result is passed to the block\u2019s successors, ensuring that the flow continues without errors or interruptions.  </li> </ol> <p>When an action block is skipped, it is visually rendered in grayscale in the Flow Editor, providing a clear indicator that the block is not active during execution.</p> <p></p>"},{"location":"flow-testing/action-skipping.html#use-cases-for-block-skipping","title":"Use Cases for Block Skipping","text":"<p>The Skip Block toggle is ideal for situations where executing an action block is temporary, unnecessary, or undesired. Examples include:  </p> <ul> <li>Debugging: Temporarily skip certain actions (e.g. sending emails, making API calls) while debugging other parts of the flow.  </li> <li>Testing: Simulate block outputs to test downstream logic without relying on live systems or data.  </li> <li>Logging: Exclude logging actions while preserving the structure of the flow for production.  </li> <li>Flow Development: Placeholder actions can be skipped during the initial development phase while designing the broader workflow logic.  </li> <li>Performance Optimization: Disable non-critical actions to test the performance of a flow with fewer processes running.  </li> </ul>"},{"location":"flow-testing/action-skipping.html#best-practices","title":"Best Practices","text":"<ol> <li>Use Realistic Simulated Results: Ensure the simulated result closely mimics the actual output of the block to avoid unexpected issues in successors.  </li> <li>Document Skipped Blocks: Add comments or notes in the flow to explain why the Skip Block toggle is enabled and what the simulated result represents.  </li> <li>Re-enable Actions When Needed: Disable the Skip Block toggle once debugging or testing is complete to restore the block\u2019s intended functionality.  </li> <li>Test Successor Logic: After skipping a block, validate that its successors behave correctly with the simulated result.  </li> </ol> <p>The Skip Block functionality is a powerful tool for flow developers, enabling greater flexibility and control during the design, testing, and debugging of workflows. By leveraging this feature, you can streamline the development process while maintaining a robust automation environment.  </p>"},{"location":"flow-testing/debugging.html","title":"Flow Debugging","text":"<p>Debugging is a crucial part of the development and testing process in FlowRunner\u2122. It allows you to identify, analyze, and resolve issues in your workflows to ensure they perform as expected. While testing validates the overall functionality of your flows (see the Test Mode chapter for details), debugging focuses on pinpointing and addressing specific problems within the flow.</p> <p>To support effective debugging, FlowRunner\u2122 provides integration with the FlowLogger\u2122, a powerful web-based tool designed for real-time log monitoring and message analysis. Whether you\u2019re tracking specific data points or troubleshooting errors, the FlowLogger\u2122 gives you immediate feedback, simplifying the debugging process and helping you refine your flows more effectively. </p>"},{"location":"flow-testing/debugging.html#flowloggertm-web-app","title":"FlowLogger\u2122 Web App","text":"<p>The FlowLogger\u2122 is a web application available at https://logger.flowrunner.ai. When you open the logger, it generates a five-digit debugging session code. This code links your flow to the logger and enables it to receive log messages during execution. </p> <p></p>"},{"location":"flow-testing/debugging.html#flowrunnertm-logger-action","title":"FlowRunner\u2122 Logger Action","text":"<p>Before you can use the FlowLogger\u2122, you need to install its extension. Begin by opening the Marketplace in FlowRunner\u2122\u2122:</p> <p></p> <p>Search for the FlowRunner\u2122 Logger extension. Click the <code>GET</code> button to install it in your application. </p> <p></p> <p>Note</p> <p>Extentions installed from the marketplace will be available for all flows in your app.</p> <p>Once installed, the extension will appear in the CUSTOM ACTIONS category to your Blocks Toolbox. This is where the Log Message block resides. </p> <p></p> <p>To start using the Log Message block, drag it into your flow and select it to open its properties. In the Property Editor, click the Configure button. </p> <p></p> <p>A popup window will appear, prompting you to enter the five-digit Session Code from the FlowLogger\u2122 web application. After entering the Session Code, save your changes. This step will connect the block to the logger upon sending the very first log message.</p>"},{"location":"flow-testing/debugging.html#using-the-log-message-block","title":"Using the Log Message Block","text":"<p>The Log Message block allows you to transmit data from your flow to the FlowLogger\u2122. It accepts a single input parameter, Message, which can contain any type of data, including strings, numbers, lists, or key/value structures.  </p> <p>When the block executes, the message you specify is sent to the logge web app, where it appears in real-time. This makes the Log Message block an invaluable tool for understanding what\u2019s happening inside your flow. You can use it to verify data, track execution paths, or identify errors. For example, you might log the results of a calculation, the contents of a variable, or the outcome of a database query.  </p>"},{"location":"flow-testing/debugging.html#monitoring-logs-in-real-time","title":"Monitoring Logs in Real-Time","text":"<p>Once your flow is linked to the FlowLogger\u2122 web app, you can monitor its behavior as it runs. Messages sent by the Log Message block are displayed instantly, providing an up-to-the-moment view of your flow\u2019s activity.  </p> <p>To fully utilize the FlowLogger\u2122, try running the Log Message block in Test Mode. This lets you experiment with your flow in a safe environment, where you can observe how data is logged and troubleshoot issues without affecting live workflows.  </p> <p></p> <p>FlowLogger\u2122 includes several features to enhance your debugging experience. If the log output becomes cluttered, you can clear all messages with the Clear all logs icon-button. For readability, you can adjust the text size of log entries using the  and  icon-buttons. </p> <p></p> <p>When the logged data includes lists or key/value structures, the logger allows you to expand or collapse sections, making it easy to explore nested information.  </p> <p>If you need to start a new session, click the START NEW SESSION button in the bottom bar of the FlowLogger\u2122 window.</p>"},{"location":"flow-testing/debugging.html#best-practices-for-debugging","title":"Best Practices for Debugging","text":"<ol> <li>Place Log Message blocks strategically at key points in your flow to track important data or monitor execution paths.  </li> <li>Use meaningful and descriptive messages to provide clear context for each log entry.  </li> <li>Clear the logger between tests to avoid confusion and ensure you\u2019re viewing only the latest messages.  </li> <li>Combine FlowLogger\u2122 with Test Mode for a controlled debugging environment where you can isolate and resolve issues efficiently.  </li> <li>Take advantage of the logger\u2019s collapsible structures to navigate complex data more easily.  </li> </ol>"},{"location":"flow-testing/testing.html","title":"Testing Your Flows","text":"<p>FlowRunner\u2122's Test Mode is designed to help you efficiently test and debug your flows. This mode allows you to simulate the flow execution, monitor its behavior, and ensure everything works as expected before launching the flow. Testing is crucial because many parts of the flows run \"silently\" and execute business rules and logic behind the scenes. By testing, you gain visibility into how this execution works, identify potential issues, and verify that your automation behaves as intended. This process helps you catch and resolve errors early, leading to more reliable and robust workflows.</p> <p>You can activate Test Mode directly within the Flow Editor by toggling the \"Test Mode\" toggle. </p> <p></p> <p>Once enabled, the interface adapts to support testing and debugging activities. You will observe the following changes in the interface:</p> <ol> <li> <p>The Test Monitor panel, the crucial element of the test mode appears at the bottom of the Flow Editor interface.     </p> </li> <li> <p>Blocks in your flow get the \"play\" icon that let's you perform a test run of the block.    </p> </li> <li> <p>When you select a block, the configuration properties that impact block's execution (usually these are the properties that define the input parameter(s)) are displayed with the special \"debug\" annotation. Additionally, notice the Test button, it performs the same action as the red \"play\" icon on the selected block:    </p> </li> </ol>"},{"location":"flow-testing/testing.html#test-monitor-panel","title":"Test Monitor Panel","text":"<p>Test Monitor helps you inspect the results of test invocations and check the Global Flow Context values. When you execute a test run for a block, the Test Monitor panel will display the blovk's result:</p> <p></p> <p>When you select a block in the flow, the panel will show the result from the most recent test run. The result value can be edited (or created if you need to set up a mocked data).</p>"},{"location":"flow-testing/testing.html#invocation-history","title":"Invocation History","text":"<p>Every time a block is executed in Test Mode, an entry is added to the Invocation History panel. The panel is accessible by clicking the Invocation History icon located in the same toolbar as the \"Test Mode\" toggle: </p> <p>For every test invocation, the panel displays the time of the call, the block's name, and the call status (Success or Error).  </p>"},{"location":"flow-testing/testing.html#test-parameters","title":"Test Parameters","text":"<p>In Test Mode, every block in your flow gets a special \"play\" icon. Clicking this icon will execute the block with the test input parameters. These parameters are initially copied from the \"production\" mode (the normal design mode of your flow), but you can modify them as needed for testing purposes. The test input parameters always have a red border and a red \"bug\" icon in the upper right corner. Clicking the \"bug\" icon will show the non-test (production) data. Use the double arrows icon button to transfer test data to the production properties and vice versa:  </p> Warning <p>While in Test Mode, if you modify a test input parameter, its value does not immediately propagate to the non-test values. To update the non-test values, make sure to click the \"double arrow\" icon.</p>"},{"location":"flow-testing/testing.html#editing-test-data","title":"Editing Test Data","text":"<p>The Block Result Inspector section of the Test Monitor panel lets you override or enter new data for any item in your flow. If a block's result is used as an input parameter, you can specify the value using the editor in Block Result Inspector. Consider the following example - the Retrieve Orders block is a Find Record(s) in Database action. It uses the <code>condition</code> property from App Logic Trigger Data for the Where Clause parameter: </p> <p>Since the App Logic Trigger block is a trigger, when you run it in the Test Mode, it does not produce any results. In order to prepare the Retrieve Orders block for a test run, you need to make sure its input parameter has data. This means, you need to set up a value for the <code>condition</code> property in the data provided by the App Logic Trigger. To do that select App Logic Trigger block and click the \"+\" (Add Row) button in the Block Result Inspector:  Type in <code>condition</code> in the Property Names column and a valid where clause for your time, for example <code>Profit &gt; 100</code>:  Run a test execution of the \"Retrieve Orders\" block, it will use the specifed value of the <code>condition</code> property. You can see the result in the Block Result Inspector panel: </p>"},{"location":"flow-testing/testing.html#step-by-step-testing","title":"Step-by-Step Testing","text":"<p>Test Mode allows you to execute blocks step-by-step, giving you a granular view of how data flows through your automation. By examining the Invocation History and block results sections, you can understand how each block processes data and identify any issues or errors. This detailed inspection helps ensure that your flow operates correctly and efficiently in production.</p> <p>FlowRunner\u2019s Test Mode is a powerful tool for testing and debugging your flows. By enabling Test Mode, utilizing the Test Monitor, and executing blocks step-by-step, you can thoroughly validate your flows, ensuring they are ready for production. This proactive approach to testing helps you catch and resolve issues early, leading to more reliable and robust automations.</p>"},{"location":"reference/actions-group.html","title":"Actions Group","text":"<p>Imagine you're managing a marketing campaign that needs to kick off across multiple channels simultaneously. You need to post updates on social media, send out an email newsletter, and publish a blog post on your website\u2014all at the same time. With FlowRunner\u2122, you can group these actions into a single step and execute them in parallel, significantly speeding up the process and ensuring everything launches together.</p> <p>This powerful feature allows you to run multiple actions at once, enhancing the efficiency and flexibility of your workflows. Instead of waiting for each task to finish before starting the next one, all actions within a grouped step start simultaneously. This is perfect for tasks that don\u2019t depend on a specific sequence and can benefit from concurrent execution.</p>"},{"location":"reference/actions-group.html#creating-an-actions-group","title":"Creating an Actions Group","text":"<p>To create an Actions Group, use the <code>Actions Group</code> block located in the <code>GROUPS</code> section of the Blocks Toolbox.</p> <p></p> <p>Drag the <code>Actions Group</code> block into the Flow Editor Canvas. To edit the contents of the group, click the <code>expand</code> icon:</p> <p></p> <p>The Flow Editor canvas will open to show the contents of your group, which is empty by default. You can add multiple actions to the group in the same way blocks are added to a flow. The difference is that actions in a group are not sequenced; when the execution reaches the group, all actions run at once.</p> <p>To return to your flow, click the <code>Go Back</code> button in the top toolbar.</p>"},{"location":"reference/actions-group.html#transition-modes","title":"Transition Modes","text":"<p>You have the option to choose how the workflow transitions to successor blocks. This is configured in the group's properties:</p> <p></p> <p>The first mode, <code>On Start</code>, allows the workflow to move on as soon as all actions in the current step have begun. This is particularly useful when the next tasks in the workflow can start as soon as they know the previous actions are underway, without waiting for their completion. Backendless visualizes this transition mode with a top-filled hourglass indicator on all transition lines. </p> <p></p> <p>The second mode, <code>On Completion</code>, ensures that the workflow only proceeds once all actions in the current step are finished. This mode is ideal when the subsequent steps rely on the completion of all parallel tasks, making sure nothing is left incomplete before moving forward. This transition mode is visualized with a bottom-filled hourglass indicator on all outgoing transition lines:</p> <p></p> <p>Consider a scenario where you're collecting data from various sources. You need to fetch sales data from a database, customer data from an API, and product data from a spreadsheet. With this feature, you can start all these data collection tasks simultaneously. Depending on your workflow requirements, you can either start processing the collected data as soon as all tasks have started (using the <code>On Start</code> transition mode) or wait until all data is gathered before proceeding (using the <code>On Completion</code> mode).</p>"},{"location":"reference/actions-group.html#returned-values","title":"Returned Values","text":"<p>The <code>Actions Group</code> block does not have its own return value. However, the \"Result\" elements from the individual actions placed into the group are available.</p> Note <p>If the outgoing transition is set to <code>On Start</code>, data in an individual \"result\" element may not be available until the action completes its execution. Make sure to check for data availability before you use it in a successor block.</p>"},{"location":"reference/actions-group.html#benefits-of-grouping-actions","title":"Benefits of Grouping Actions","text":"<p>Grouping actions for parallel execution offers significant benefits. By enabling parallel execution, you can reduce the overall execution time, making your workflows more efficient. The flexibility to choose the appropriate transition mode based on your needs ensures that your processes are both robust and streamlined. Additionally, this capability allows you to handle complex workflows with multiple parallel actions easily, scaling your automation to meet growing demands.</p> <p>In essence, Backendless Automation's ability to group actions into parallel execution steps, with flexible transition modes, enhances both efficiency and flexibility. Whether you're launching a marketing campaign, collecting data from various sources, or performing IT maintenance tasks, this feature ensures your workflows are effective, timely, and capable of managing complex tasks with precision.</p>"},{"location":"reference/ai-agent.html","title":"AI Agent in FlowRunner","text":"<p>The AI Agent block brings artificial intelligence into your FlowRunner\u2122 workflows. Unlike regular automation blocks that always follow the same sequence, the AI Agent can read your instructions, pick the best tools, and decide how to use them. This gives your flows flexibility to handle complex scenarios with very little setup.</p> <p>Think of the AI Agent as a smart teammate inside your flow. You provide it with prompts and tools, and it figures out the best way to complete the task.</p> <p>Why AI Agents Feel Smarter</p> <p>Regular blocks run step by step in a fixed order. AI Agents are different because they can:</p> <ul> <li>Choose which tools to use  </li> <li>Decide the order of actions  </li> <li>Remember past interactions  </li> <li>Adapt based on results  </li> </ul>"},{"location":"reference/ai-agent.html#how-the-ai-agent-works","title":"How the AI Agent Works","text":"<p>When you add an AI Agent to your flow, you are giving it the role of a decision-maker. It receives instructions through prompts, looks at the tools you connected, and decides how to use them. By default, the agent can choose the order of tool execution and adapt as it goes.</p> <p>If you prefer more control, you can also specify the order of tool usage yourself. In that case, the agent will follow the procedure you outline instead of deciding on its own.</p> <p>In short, the AI Agent reads your prompt, understands the goal, and either orchestrates the tools dynamically or executes them in the order you defined.</p>"},{"location":"reference/ai-agent.html#configuring-the-ai-agent-block","title":"Configuring the AI Agent Block","text":"<p>Before your AI Agent can run, you need to configure its main properties. These settings define which model the agent uses, what instructions it follows, and whether it remembers past interactions.</p> <p>The configuration includes:</p> <ul> <li>AI Provider \u2014 the large language model service to use. FlowRunner\u2122 supports OpenAI, Anthropic, Mistral, Cohere, Groq, DeepSeek, and Google Gemini.</li> <li>AI Model \u2014 the specific model from the chosen provider.</li> <li>API Key \u2014 the provider\u2019s API key, required for authentication.</li> <li>System Prompt \u2014 defines the agent\u2019s role, rules, and overall behavior.</li> <li>User Prompt \u2014 defines the task or question for the current run.</li> <li>Memory (Message History) \u2014 controls how many past messages the agent remembers. By default, memory is enabled and set to 15 messages.</li> </ul> <p></p> <p>The next sections explain prompts and memory in more detail.</p>"},{"location":"reference/ai-agent.html#writing-prompts","title":"Writing Prompts","text":"<p>Prompts are the instructions that drive the AI Agent\u2019s behavior. You use two types of prompts: system prompts and user prompts. Both can use the Expression Editor to pull in dynamic data from your flow.</p>"},{"location":"reference/ai-agent.html#system-prompt","title":"System Prompt","text":"<p>The system prompt defines the agent\u2019s role and rules. Here you describe what the agent is, what it can do, how it should use tools, what output format to follow, and any limits it must respect. You can keep the prompt fixed or make it dynamic with the Expression Editor.</p>"},{"location":"reference/ai-agent.html#user-prompt","title":"User Prompt","text":"<p>The user prompt describes the task for the current run. This usually includes the immediate goal, data from earlier flow blocks, and any special instructions. With the Expression Editor, you can insert context such as trigger data, variables, or results from previous steps.</p>"},{"location":"reference/ai-agent.html#memory-and-context","title":"Memory and Context","text":"<p>The AI Agent automatically keeps track of context during execution. By default, memory is enabled and stores up to 15 messages in the run history. This allows the agent to build on past interactions instead of starting fresh every time.</p>"},{"location":"reference/ai-agent.html#adjusting-memory","title":"Adjusting Memory","text":"<p>If you want to change this behavior:</p> <ol> <li>Open the AI Agent properties.</li> <li>Look for the Messages History setting.</li> <li>Change the number of past messages to keep (up to 15) or turn the setting off completely if you do not want the agent to remember context.</li> </ol> <p></p> <p>Memory Persistence</p> <p>Memory is shared across different runs of the same flow version. This means multiple executions can use the same context, which is helpful for multi-interaction workflows.</p>"},{"location":"reference/ai-agent.html#when-memory-helps","title":"When Memory Helps","text":"<p>Since memory is on by default, your agent will usually remember the last 15 messages. This is useful for conversational chatbots, multi-step approvals, customer support systems, or data processes that build on previous results. You can reduce the number of stored messages or disable memory if your flow doesn\u2019t need history.</p>"},{"location":"reference/ai-agent.html#giving-your-agent-tools","title":"Giving Your Agent Tools","text":"<p>Tools are what make the AI Agent powerful. Each tool you add gives the agent new abilities, so it can handle a wider range of tasks.</p> <p>At the same time, adding too many tools can sometimes reduce accuracy. Current AI models may struggle to choose efficiently when faced with a very large toolset. For best results, start with only the tools the agent truly needs. You can always add more as you refine your flow.</p>"},{"location":"reference/ai-agent.html#what-counts-as-a-tool","title":"What Counts as a Tool","text":"<p>Any FlowRunner\u2122 action can be a tool. That includes built-in actions like Send Email or HTTP Request, integrations like Gmail, Slack, or Airtable, and even custom extensions you create.</p>"},{"location":"reference/ai-agent.html#adding-tools","title":"Adding Tools","text":"<p>To add tools to your AI Agent:</p> <ol> <li>Select the AI Agent block in your flow.</li> <li> <p>Click Manage Tools in the properties panel or the Add Tools icon in the AI Agent block itself:</p> <p></p> </li> <li> <p>Pick from the list of available actions.</p> </li> <li>Repeat the process to add as many tools as you need.</li> </ol> <p></p> <p>Each tool you connect expands what the agent can do.</p>"},{"location":"reference/ai-agent.html#configuring-tools","title":"Configuring Tools","text":"<p>When you add a tool, you can decide how its fields should be set. Some fields can use fixed values that you enter directly. Others can pull in dynamic values from another part of the flow, such as a trigger, an action, a transformer, a variable, or a placeholder. If you leave a field empty, the AI Agent will decide what to put there during execution.</p> <p>To configure a tool:</p> <ol> <li>Click on the tool inside the AI Agent.  </li> <li>Set it up as you would configure a standalone action.  </li> <li>Fill in any fields you want fixed or linked to data from elsewhere in the flow.  </li> <li>Leave fields empty if you want the AI to determine them dynamically.</li> </ol> <p></p> <p>Flexible Tool Configuration</p> <p>Tool fields can be set in different ways. You can enter a fixed value, or you can link the field to data coming from another block in your flow, such as a trigger, an action, a transformer, a variable, or a placeholder. If you leave a field empty, the AI Agent will decide what value to provide during execution. Fields you configure will always use the values you defined, while empty fields let the agent act on its own. This balance gives you both control and flexibility.</p>"},{"location":"reference/ai-agent.html#monitoring-with-langsmith","title":"Monitoring with LangSmith","text":"<p>For deeper insight into how your AI Agent makes decisions, you can connect FlowRunner\u2122 with LangSmith from LangChain. This integration shows you what the agent understood, which tools it used, and how it responded.</p> <p>To enable LangSmith monitoring:</p> <ol> <li>In the AI Agent properties, open LangSmith Settings.</li> <li>Toggle on Enable LangSmith.</li> <li>Enter your API key, project name, and account cluster.</li> <li>Optionally, add a trace label for organization.</li> </ol> <p></p> <p>LangSmith helps you debug agent behavior, analyze why it chose certain tools, check token usage, and compare different prompts or setups. It is also helpful for performance tuning, since you can see how long each step takes.</p>"},{"location":"reference/ai-agent.html#best-practices","title":"Best Practices","text":"<p>Follow these tips to get the most out of AI Agents.</p> <ul> <li> <p>Write Clear Prompts: Make system prompts specific and give examples if formatting is important. Define boundaries for what the agent should and should not do. Test and refine as needed.</p> </li> <li> <p>Pick the Right Tools:  Only add tools that are relevant to the task. While each tool you add expands the agent\u2019s abilities, adding too many can sometimes have the opposite effect. Current AI models may struggle to pick the best option when faced with an overly large toolset, which can reduce accuracy or efficiency.</p> <p>A good approach is to start with just the essential tools, test the flow, and then add more only if the agent needs them. Pre-configure common values to ensure consistency, and group related tools so the agent better understands how they connect.</p> </li> <li> <p>Keep It Fast: Keep message history as short as possible for quicker execution. Use LangSmith to spot slow steps and manage token costs.</p> </li> <li> <p>Plan for Mistakes: Add error handler blocks after AI Agents. Include fallback instructions in prompts. Log agent decisions for debugging and test with varied inputs to ensure reliability.</p> </li> </ul>"},{"location":"reference/ai-agent.html#common-uses","title":"Common Uses","text":"<p>AI Agents are great in many scenarios. You can use them for customer service routing, document classification, content moderation, approval workflows, data analysis, or orchestrating tasks across multiple systems.</p>"},{"location":"reference/ai-agent.html#troubleshooting","title":"Troubleshooting","text":"<p>If your AI Agent doesn\u2019t behave as expected:</p> <ol> <li>Check your prompts for clarity.</li> <li>Review tool setup and required fields.</li> <li>Turn on LangSmith for detailed logs.</li> <li>Test tools independently of the AI Agent.</li> <li>Start simple, then add complexity.</li> </ol> <p>Testing AI Agents</p> <p>Use FlowRunner\u2019s test mode to experiment with prompts and tool setups before running them in production.</p>"},{"location":"reference/ai-assistant.html","title":"AI Assistants in FlowRunner","text":"<p>FlowRunner\u2019s AI Assistants bring the immense power of AI's advanced intelligence directly into your workflows, making virtually any task imaginable, from in-depth data analysis to creative content generation, a seamless part of your automation. This feature opens up new possibilities for processing documents, generating reports, visualizing data, and much more, all as integral parts of your flow. The AI Assistants\u2019 results can also be further leveraged throughout your automation. For instance, you might connect an assistant to interpret a database query result, create visualizations, and then embed those visualizations into a dynamically generated PDF report using FlowRunner\u2019s PDF Generator action.</p> <p>In FlowRunner\u2122, each AI Assistant appears as an action block within a flow. You may have multiple AI Assistants tailored for different tasks, each with specific configurations and capabilities. To add an AI Assistant to your flow, start by creating an AI Assistant block using the Create AI Assistant option.</p> <p></p> <p>IMPORTANT</p> <p>It\u2019s important to remember that FlowRunner\u2122 defaults to using a shared \"demo\" OpenAI account, which is ideal for testing but has limited functionality. For sustained and definitely production use, we recommend updating your FlowRunner\u2122 setup with your personal OpenAI API key.</p> <p>To add your API key, go to the OpenAI API Keys page, generate a new key, and then paste it into the Third Party API Keys section under the Manage screen in the Backendless Console. This way, you retain access to any assistants you create or configure directly in your OpenAI account, allowing for broader usage outside FlowRunner\u2122.</p>"},{"location":"reference/ai-assistant.html#creating-a-new-ai-assistant","title":"Creating a New AI Assistant","text":"<p>When you select the Create AI Assistant option, the New AI Assistant popup appears. Here, you can either create a new assistant or import an existing one from your OpenAI account. </p> <p>When creating a new AI Assistant, you can choose from two setup methods:</p> <ol> <li> <p>Express Registration: </p> <p>For this option, simply enter the Assistant ID from your OpenAI account.</p> <p></p> <p>To retrieve the Assistant ID, ensure your API key is entered in the Backendless Console (see the IMPORTANT note above), then go to OpenAI Assistants, copy the assistant ID, and paste it into the Assistant ID field in the New AI Assistant popup shown above. </p> <p></p> <p>By clicking the REGISTER ASSISTANT button, FlowRunner\u2122 imports the assistant details, creating a dedicated assistant action in the toolbar.</p> </li> <li> <p>Detailed Configuration:      This option lets you fully configure a new AI Assistant directly in FlowRunner\u2122, defining specific capabilities and settings to customize its functions in your workflows.</p> </li> </ol>"},{"location":"reference/ai-assistant.html#configuring-an-ai-assistant","title":"Configuring an AI Assistant","text":"<p>When using the Detailed Configuration option, FlowRunner\u2122 offers a range of settings to help you tailor the assistant\u2019s behavior.</p>"},{"location":"reference/ai-assistant.html#basic-assistant-details","title":"Basic Assistant Details","text":"<p>Define essential information about the assistant\u2019s purpose and capabilities.</p> <p></p> <ul> <li>Assistant Name: Choose a short, descriptive name indicating the tasks this assistant will handle.</li> <li> <p>Assistant Capabilities: You can select one or both of the following options:</p> <ul> <li>Data Analyzer: Ideal for assistants performing data processing or analysis on provided files. This allows the assistant to write and execute code tailored to the files\u2019 content.</li> <li>Data Search in Files: Designed for extracting data from files, this is useful when specific information needs to be located within the files provided.</li> </ul> <p>When configuring capabilities, you can also upload files to equip the assistant with any specific knowledge, data structures, or sample data it might need. If both capabilities are selected, assign each file to the appropriate capability.</p> </li> <li> <p>Instructions: Use this field to outline general guidance for the assistant. Avoid specific requests here, as you will provide specific instructions at runtime based on your flow\u2019s needs.</p> </li> </ul>"},{"location":"reference/ai-assistant.html#advanced-configuration","title":"Advanced Configuration","text":"<p>These additional settings offer control over how the assistant responds:</p> <p></p> <ul> <li>Response Format: Choose from <code>AUTO</code>, <code>TEXT</code>, or <code>JSON OBJECT</code>. When an assistant has \"Data Analyzer\" or \"Data Search in Files\" enabled, only <code>TEXT</code> is available.</li> <li>Model: Specify the preferred language model (LLM), which will impact both the assistant\u2019s response quality and your OpenAI usage costs.</li> <li>Temperature: Adjusts how deterministic the assistant\u2019s responses are. Lower temperatures yield more consistent responses, while higher temperatures encourage variety.</li> <li>Top P: Controls the assistant\u2019s creativity level by determining the range of word choices. A lower setting restricts to straightforward responses, while higher values make responses more imaginative.</li> </ul> <p>If you have configured the assistant through your OpenAI account (with your API key), you can also access and test it independently in the OpenAI Playground, which is helpful for diagnostics.</p>"},{"location":"reference/ai-assistant.html#adding-ai-assistants-to-a-flow","title":"Adding AI Assistants to a Flow","text":"<p>Once configured, your assistant will appear in the AI ASSISTANTS section of the FlowRunner\u2122 toolbar. To add it to your flow, simply drag it into the editor.</p> <p>For example, the screenshot below shows an assistant named CSV Processor added to a flow. Notice that the assistant\u2019s properties include a Data Analyzer Additional Files field. This field appears when you have enabled the Data Analyzer capability during setup, allowing you to specify extra files for analysis as part of the flow.</p> <p></p> <p>To tailor your assistant\u2019s tasks, use the Message to Assistant property to set specific prompts for each flow step. This prompt can reference data generated by previous actions in the flow. Use the Expression Editor to help compose this prompt by linking it to other flow components.</p>"},{"location":"reference/ai-assistant.html#handling-ai-assistant-responses","title":"Handling AI Assistant Responses","text":"<p>Once an AI Assistant completes its task, the response follows this format:</p> <pre><code>{\n  \"decision\": \"text response from the assistant\"\n}\n</code></pre> <p>If the assistant generates a file, the response expands to include the file\u2019s URL:</p> <pre><code>{\n  \"decision\": \"text response from the assistant\",\n  \"fileURL\": \"absolute URL to a file generated by the assistant\"\n}\n</code></pre> <p>For multiple files, the response includes each file URL within a list:</p> <pre><code>{\n  \"decision\": \"text response from the assistant\",\n  \"files\": [\n    { \"fileURL\": \"absolute URL to a file generated by the assistant\" },\n    { \"fileURL\": \"absolute URL to a file generated by the assistant\" }\n  ]\n}\n</code></pre> <p>These responses integrate seamlessly into FlowRunner\u2122, enabling your automation to continue processing AI Assistant outputs, whether for report generation, data visualization, or further analysis.</p>"},{"location":"reference/ai-content-moderation.html","title":"Moderate Content Block","text":"<p>The Moderate Content block uses AI-powered analysis to detect potentially harmful or inappropriate content in both text and images. This block leverages OpenAI's moderation technology to identify content violations across multiple categories including harassment, hate speech, violence, self-harm, sexual content, and illicit activities. This capability is essential for applications that handle user-generated content and need to maintain community standards or comply with platform policies.</p> <p>Common use cases include moderating user posts on social platforms, filtering uploaded images before publication, reviewing comments and messages, and ensuring content compliance in educational or professional environments. The block provides detailed analysis results that help you make informed decisions about content approval, rejection, or escalation to human reviewers.</p>"},{"location":"reference/ai-content-moderation.html#input-configuration","title":"Input Configuration","text":"<p>The Moderate Content block accepts two types of input that can be used independently or in combination to analyze different forms of content.</p> <p></p>"},{"location":"reference/ai-content-moderation.html#text-content","title":"Text Content","text":"<p>The Text Content field accepts string input through the Expression Editor, allowing you to analyze written content from any previous block in your workflow. You can add multiple text inputs by clicking the \"+\" button, enabling batch analysis of several text pieces in a single operation.</p> <p></p> <p>Examples of text content you might analyze include:</p> <ul> <li>User comments and forum posts</li> <li>Social media captions and descriptions  </li> <li>Chat messages and direct communications</li> <li>Product reviews and feedback submissions</li> <li>Any user-generated text content requiring moderation</li> </ul>"},{"location":"reference/ai-content-moderation.html#images","title":"Images","text":"<p>The Images field accepts publicly accessible URLs pointing to image files. Like text content, you can add multiple image URLs using the \"+\" button to analyze several images simultaneously. </p> <p>Important Requirements: </p> <ul> <li>Image URLs must be publicly accessible without authentication</li> <li>Images should be in standard web formats (JPEG, PNG, GIF, etc.)</li> <li>Keep the number of images reasonable to maintain good flow performance</li> </ul> <p>Examples of image content you might analyze include:</p> <ul> <li>Profile pictures and avatars</li> <li>User-uploaded photos and graphics</li> <li>Memes and social media images</li> <li>Product images in marketplace applications</li> <li>Any visual content requiring safety review</li> </ul>"},{"location":"reference/ai-content-moderation.html#combining-text-and-images","title":"Combining Text and Images","text":"<p>The moderation system analyzes text and images independently, then provides combined results. This approach allows you to moderate complex content like social media posts that include both captions and images, or product listings with descriptions and photos. The result object will indicate which content types triggered each category, helping you understand the source of any moderation flags.</p>"},{"location":"reference/ai-content-moderation.html#understanding-the-results","title":"Understanding the Results","text":"<p>The Moderate Content block returns a comprehensive analysis in JSON format. Here's exactly what you'll receive when analyzing content that violates policies:</p> <p>Example Input: Text saying: </p> <pre><code>\"I'm going to find you and hurt you badly\"\n</code></pre> <p>Complete JSON Response: <pre><code>{\n  \"flagged\": true,\n  \"categories\": {\n    \"harassment\": true,\n    \"harassment/threatening\": true,\n    \"sexual\": false,\n    \"hate\": false,\n    \"hate/threatening\": false,\n    \"illicit\": false,\n    \"illicit/violent\": false,\n    \"self-harm/intent\": false,\n    \"self-harm/instructions\": false,\n    \"self-harm\": false,\n    \"sexual/minors\": false,\n    \"violence\": true,\n    \"violence/graphic\": false\n  },\n  \"flaggedCategories\": \"harassment, harassment/threatening, violence\",\n  \"category_scores\": {\n    \"harassment\": 0.647809720240366,\n    \"harassment/threatening\": 0.5313221067020961,\n    \"sexual\": 0.0007433895060961777,\n    \"hate\": 0.00009110511944006454,\n    \"hate/threatening\": 0.003340422246702904,\n    \"illicit\": 0.028423221440453627,\n    \"illicit/violent\": 0.0022345969479810506,\n    \"self-harm/intent\": 0.00027414735167209615,\n    \"self-harm/instructions\": 0.00000453978687024344,\n    \"self-harm\": 0.0005122131122536138,\n    \"sexual/minors\": 0.000013765463368900109,\n    \"violence\": 0.9533639418815286,\n    \"violence/graphic\": 0.00002234163601827719\n  },\n  \"category_applied_input_types\": {\n    \"harassment\": [\"text\"],\n    \"harassment/threatening\": [\"text\"],\n    \"sexual\": [\"text\", \"image\"],\n    \"hate\": [\"text\"],\n    \"hate/threatening\": [\"text\"],\n    \"illicit\": [\"text\"],\n    \"illicit/violent\": [\"text\"],\n    \"self-harm/intent\": [\"text\", \"image\"],\n    \"self-harm/instructions\": [\"text\", \"image\"],\n    \"self-harm\": [\"text\", \"image\"],\n    \"sexual/minors\": [\"text\"],\n    \"violence\": [\"text\", \"image\"],\n    \"violence/graphic\": [\"text\", \"image\"]\n  }\n}\n</code></pre></p> <p>For comparison, here's what clean content looks like:</p> <p>Example Input: Text saying:</p> <pre><code>\"Thanks for the great customer service!\"\n</code></pre> <p>Complete JSON Response: <pre><code>{\n  \"flagged\": false,\n  \"categories\": {\n    \"harassment\": false,\n    \"harassment/threatening\": false,\n    \"sexual\": false,\n    \"hate\": false,\n    \"hate/threatening\": false,\n    \"illicit\": false,\n    \"illicit/violent\": false,\n    \"self-harm/intent\": false,\n    \"self-harm/instructions\": false,\n    \"self-harm\": false,\n    \"sexual/minors\": false,\n    \"violence\": false,\n    \"violence/graphic\": false\n  },\n  \"flaggedCategories\": \"\",\n  \"category_scores\": {\n    \"harassment\": 0.00001234567890123456,\n    \"harassment/threatening\": 0.000008765432109876543,\n    \"sexual\": 0.00003456789012345678,\n    \"hate\": 0.000001234567890123456,\n    \"hate/threatening\": 0.000002345678901234567,\n    \"illicit\": 0.00000987654321098765,\n    \"illicit/violent\": 0.000001098765432109876,\n    \"self-harm/intent\": 0.000000234567890123456,\n    \"self-harm/instructions\": 0.00000012345678901234,\n    \"self-harm\": 0.000000345678901234567,\n    \"sexual/minors\": 0.000000098765432109876,\n    \"violence\": 0.000002109876543210987,\n    \"violence/graphic\": 0.000000876543210987654\n  },\n  \"category_applied_input_types\": {\n    \"harassment\": [\"text\"],\n    \"harassment/threatening\": [\"text\"],\n    \"sexual\": [\"text\"],\n    \"hate\": [\"text\"],\n    \"hate/threatening\": [\"text\"],\n    \"illicit\": [\"text\"],\n    \"illicit/violent\": [\"text\"],\n    \"self-harm/intent\": [\"text\"],\n    \"self-harm/instructions\": [\"text\"],\n    \"self-harm\": [\"text\"],\n    \"sexual/minors\": [\"text\"],\n    \"violence\": [\"text\"],\n    \"violence/graphic\": [\"text\"]\n  }\n}\n</code></pre></p>"},{"location":"reference/ai-content-moderation.html#what-each-field-means","title":"What Each Field Means","text":"<p><code>flagged</code>: Boolean indicating if any content violated policies (<code>true</code> = violations detected)</p> <p><code>categories</code>: Binary flags for each violation type. In the first example, <code>harassment</code>, <code>harassment/threatening</code>, and <code>violence</code> are <code>true</code></p> <p><code>flaggedCategories</code>: Comma-separated list of violated categories for easy parsing</p> <p><code>category_scores</code>: Confidence levels (0-1) for each category. Higher = more confident. Note the violence score of 0.95 in the first example vs 0.000002 in the clean example</p> <p><code>category_applied_input_types</code>: Shows whether violations came from <code>text</code>, <code>image</code>, or both</p>"},{"location":"reference/ai-content-moderation.html#configuring-the-block","title":"Configuring the Block","text":"<p>Like all FlowRunner\u2122 blocks, you can customize how the Moderate Content block appears in your workflow and how its results are referenced by subsequent blocks.</p>"},{"location":"reference/ai-content-moderation.html#block-naming","title":"Block Naming","text":"<p>Use the \"Name\" field to assign a descriptive name that reflects the block's purpose in your specific workflow. For example, you might use names like \"User Post Moderation,\" \"Profile Image Check,\" or \"Comment Safety Review\" to make your workflow more readable and maintainable.</p>"},{"location":"reference/ai-content-moderation.html#result-reference","title":"Result Reference","text":"<p>The \"Reference Result Data As\" field determines how other blocks in your workflow will access the moderation results. Choose a clear, descriptive name that makes sense when building expressions in subsequent blocks. For instance, naming it \"ModerationResult\" allows you to reference <code>ModerationResult.flagged</code> or <code>ModerationResult.flaggedCategories</code> in your workflow logic.</p> <p></p>"},{"location":"reference/ai-content-moderation.html#implementation-strategies","title":"Implementation Strategies","text":""},{"location":"reference/ai-content-moderation.html#threshold-based-moderation","title":"Threshold-Based Moderation","text":"<p>Rather than treating all flagged content equally, consider implementing threshold-based decisions using the confidence scores. For example, you might automatically reject content with violence scores above 0.8, queue content with scores between 0.5-0.8 for human review, and approve content with lower scores.</p>"},{"location":"reference/ai-content-moderation.html#category-specific-handling","title":"Category-Specific Handling","text":"<p>Different content categories may require different responses in your application. Educational platforms might be more tolerant of violence discussions in historical contexts but have zero tolerance for harassment. Design your workflow logic to handle each category appropriately for your use case.</p>"},{"location":"reference/ai-content-moderation.html#batch-processing-efficiency","title":"Batch Processing Efficiency","text":"<p>When moderating multiple pieces of content, use the block's ability to process multiple texts and images simultaneously rather than creating separate moderation blocks. This approach improves performance and simplifies your workflow design.</p>"},{"location":"reference/ai-content-moderation.html#human-review-integration","title":"Human Review Integration","text":"<p>For content that falls into gray areas or requires nuanced judgment, design your workflow to route flagged content to human moderators while automatically handling clear-cut cases. The detailed category information and confidence scores help human reviewers understand what to focus on during their review process.</p>"},{"location":"reference/ai-router-action.html","title":"AI Router","text":"<p>The AI Router block in Backendless Flow Runner helps you make AI-powered decisions within your app. You send a custom prompt to the AI, and based on that, it returns one of the preconfigured outcomes, called Expected Decisions. Each Expected Decision represents a possible response from the AI, and each one leads to a different branch in your flow, allowing you to route the logic of your app based on the AI's answer.</p> <p>In addition to the prompt, you can provide Decision Data - larger sets of information such as database query results. While smaller pieces of data (like flow variables) can be included directly in the prompt, using Decision Data helps when dealing with larger or more complex data. This ensures the AI has all the context it needs without cluttering the prompt itself.</p> <p>For every Expected Decision, the AI Router block creates a block connector. Each connector links to a different branch of your flow, which allows you to control what happens next based on the AI\u2019s response. This makes the AI Router block a flexible tool for building intelligent workflows that respond dynamically to the data your app processes.</p> AI Router and OpenAI Integration <p>The AI Router block in Backendless uses the OpenAI API to process prompts and make decisions. By default, FlowRunner\u2122 comes with a built-in API key that allows you to experiment with the AI functionality. However, this key is provided for demonstration purposes only and has a limited number of requests.</p> <p>If you plan to use the AI Router in production or require a higher request limit, it\u2019s recommended that you configure the system with your own OpenAI API key. This ensures you have full control over the number of API calls and can use the AI functionality without restrictions.</p> <p>Setting Your OpenAI API Key</p> <p>To configure the AI Router with your own OpenAI API key:</p> <ol> <li>In the Backendless Console, navigate to the Manage section.</li> <li>Select Third Party API Keys from the menu.</li> <li>Enter your API key and the name of the model in the provided fields.</li> </ol> <p>Once your key is set, all AI-related requests in your flows will use your OpenAI API account, allowing for a more seamless and scalable integration.</p> <p>By using your own API key, you gain access to OpenAI's full set of features and request limits, making it suitable for apps that rely heavily on AI-driven decision-making.</p>"},{"location":"reference/ai-router-action.html#ai-router-in-action","title":"AI Router in Action","text":"<p>Consider the example below, where the AI Router is used to analyze sales data. Several key actions are happening here:</p> <ol> <li> <p>The AI Decision Request (or the AI prompt) contains the following static text: <pre><code>Determine the average Sales amount of the orders  \ncoming from Michigan (based on the zip code).  \n</code></pre></p> </li> <li> <p>The Decision Data includes the result of a previous action (<code>Get Orders</code>), which retrieves order data from the database.</p> </li> <li> <p>There are three Expected Decisions defined for the AI to choose from:  </p> <ul> <li><code>More than 1000</code> </li> <li><code>Less than 1000</code> </li> <li><code>Everything Else</code> (you will learn about this option later in the chapter).</li> </ul> </li> </ol> <p></p> <p>To better understand the AI\u2019s work in this example, take a look at the data it processes: </p> <p>Notice the \"Postal Code\" column in the dataset. Although the prompt only references \"zip code\" without explicitly naming the column, the AI understands that \"Postal Code\" column values refer to zip codes and is able to identify which of those belong to Michigan. Additionally, the AI processes the sales data and calculates the average Sales amount (as requested in the prompt) for orders from that region. Based on this calculation, the AI produces a response that matches one of the Expected Decisions.</p>"},{"location":"reference/ai-router-action.html#constructing-prompts","title":"Constructing Prompts","text":"<p>When working with the AI Router block, constructing an effective prompt is key to guiding the AI in making accurate decisions. You can create either static or dynamic prompts, depending on the data and context of your flow. Regardless of which type you use, you'll build the prompt using the Expression Editor, which allows you to reference various data elements from your flow.</p>"},{"location":"reference/ai-router-action.html#static-vs-dynamic-prompts","title":"Static vs. Dynamic Prompts","text":"<ul> <li> <p>Static Prompts are fixed and do not change. These prompts contain predefined text that the AI will always receive in the same form, regardless of the flow\u2019s state or any actions that occurred previously. For example: </p> </li> <li> <p>Dynamic Prompts adapt based on the flow\u2019s data. These prompts can reference variables, action results, or transformers, making them flexible and able to respond to real-time information. For example, you can include the results of previous actions like database queries, or data triggered by an event, to adjust the prompt accordingly. An example of a dynamic prompt might look like: </p> <p>In this case, <code>Default - selected regiion</code> variable would dynamically change based on user input or previous flow steps.</p> </li> </ul>"},{"location":"reference/ai-router-action.html#using-the-expression-editor","title":"Using the Expression Editor","text":"<p>Both static and dynamic prompts are constructed using the Expression Editor, a tool that allows you to reference data from your flow. For dynamic prompts, this is where the true flexibility lies \u2014 you can pull in:</p> <ul> <li> <p>Results of Previous Actions or Transformers: Use outputs from earlier steps in the flow to provide the AI with context that changes dynamically. For example, you could reference the result of a transformer that calculates a total, or the result of a database query.</p> </li> <li> <p>Trigger Event Data: If your flow is triggered by an external event, such as user input or an API call, you can reference that event data in your prompt.</p> </li> <li> <p>Variables: Any variables you've defined in the flow can be inserted into the prompt to further customize it based on real-time data.</p> </li> </ul>"},{"location":"reference/ai-router-action.html#best-practices","title":"Best Practices","text":"<p>To ensure that the AI makes decisions efficiently and accurately, follow these recommendations when constructing your prompt:</p> <ul> <li> <p>Avoid Including Large Data Items in the Prompt: For large data elements, such as the results of database queries or large lists, it's best to avoid embedding them directly in the prompt. Instead, attach them separately using the Decision Data section. This ensures the prompt remains concise while still providing the AI with all the context it needs to make an informed decision.</p> </li> <li> <p>Start the Prompt with \"Determine\": It's recommended to begin your prompt with the word \"Determine.\" This sets a clear expectation for the AI to analyze the provided information and make a decision that aligns with one of the predefined Expected Decisions. For example, your prompt might look like: <pre><code>Determine if the total sales exceed $10,000 for the attached orders\n</code></pre></p> </li> </ul> <p>By following these guidelines, you ensure that your prompts are both efficient and clear, helping the AI deliver accurate responses that can be routed through your flow based on the Expected Decisions.</p>"},{"location":"reference/ai-router-action.html#decision-data","title":"Decision Data","text":"<p>The Decision Data section in the AI Router block is an optional yet powerful tool that allows you to send additional data to the AI. This data provides the AI with the context it needs to make more informed decisions based on your prompt. Each Decision Data element has two key components: a name (or label) and the actual data. These elements help ensure that the AI has access to all the relevant information without overloading the prompt itself.</p>"},{"location":"reference/ai-router-action.html#structuring-decision-data","title":"Structuring Decision Data","text":"<p>When using Decision Data, each element is defined with a name and the corresponding data. The name acts as a reference label that you can use in the prompt to ensure the AI knows which data to work with. For example, if you're asking the AI to process sales orders, you might create a Decision Data element with the name \"Orders\" and assign it the result of a previous database query that fetched the sales data.</p> <p>It is recommended to reference the Decision Data elements by their name in the prompt. For instance, if you include sales data under the name \"Orders,\" your prompt might look like this: \"Determine the total sales from the attached Orders.\"</p> <p>By keeping the data separate from the prompt, you avoid overloading the prompt with large datasets, while still providing the AI with all the information it needs to make a decision.</p> <p></p>"},{"location":"reference/ai-router-action.html#data-and-expression-editor","title":"Data and Expression Editor","text":"<p>You can define the actual data for each Decision Data element using the Expression Editor. This gives you flexibility to dynamically compose data from multiple sources or actions within the flow. For example, the data provided to the AI might come from:</p> <ul> <li>The result of a database query that retrieves relevant records.</li> <li>The output of an API service call, like an external system's response.</li> <li>A response from another AI assistant or an earlier action in your flow.</li> </ul> <p>The Expression Editor allows you to pull in data from various parts of your flow, combine it as needed, and assign it to the appropriate Decision Data element. This dynamic approach makes your AI Router setup highly adaptable to real-time data and changes within the app.</p>"},{"location":"reference/ai-router-action.html#best-practices_1","title":"Best Practices","text":"<ul> <li> <p>Label Your Data Clearly: The name of each Decision Data element should match how it\u2019s referenced in the prompt. This helps ensure clarity and consistency between the data and the task you're asking the AI to complete. For example, if the prompt mentions \"Orders,\" the Decision Data element should also be named \"Orders.\"</p> </li> <li> <p>Avoid Overloading the Prompt: Use Decision Data for larger or more complex datasets like database query results or API responses. This keeps the prompt concise while ensuring the AI has all the context it needs. The Decision Data section is designed to handle large data elements efficiently.</p> </li> <li> <p>Dynamic Data Composition: Since the Expression Editor allows for dynamic data input, you can compose Decision Data from various sources in real time, ensuring the AI receives the most relevant and up-to-date information for each task.</p> </li> </ul>"},{"location":"reference/ai-router-action.html#expected-decisions","title":"Expected Decisions","text":"<p>Expected Decisions are predefined outcomes that you set up for the AI to choose from when it processes the prompt and any Decision Data. These are the possible results the AI can return, and each decision directs the flow down a specific path in your app. Defining clear and meaningful Expected Decisions is crucial because they guide how the AI interacts with the data and how your flow responds.</p>"},{"location":"reference/ai-router-action.html#defining-expected-decisions","title":"Defining Expected Decisions","text":"<p>When creating Expected Decisions, it\u2019s important to ensure that each option is relevant to the context of your prompt and any data shared with the AI. For example, if your Decision Data includes a list of sales orders and your prompt asks the AI to calculate total sales, Expected Decisions like <code>A</code>, <code>B</code>, and <code>C</code> would not make sense because they don't directly relate to the task or data (unless the data explicitely references <code>A</code>, <code>B</code>, and <code>C</code>). Instead, decisions such as <code>More than $10,000</code> or <code>Less than $10,000</code> would be far more informative and aligned with the prompt.</p> <p>The key is to make sure that each Expected Decision is understandable and specific based on the data the AI is analyzing. This makes the AI\u2019s choice more accurate and predictable.</p> <p></p>"},{"location":"reference/ai-router-action.html#decision-handling","title":"Decision Handling","text":"<p>For every Expected Decision you define, the AI Router block creates a connector. Each connector represents a different possible outcome, meaning that every Expected Decision must be accounted for. You will need to connect each Expected Decision to a successor block in your flow, which defines the next action to take based on that decision.</p> <p>For instance, if your Expected Decisions are <code>Positive</code>,  <code>Negative</code>, and <code>Neutral</code> (as shown in the image above), you will have three connectors for these decision from the AI Router block. You will need to attach a block to handle each of these outcomes \u2014 perhaps one that triggers a notification for asking the user for a review, and another alerts the account manager to schedule a follow-up.</p>"},{"location":"reference/ai-router-action.html#the-everything-else-decision","title":"The \"Everything Else\" Decision","text":"<p>The AI Router block also includes a predefined decision called \"Everything Else\". This is a special catch-all decision that the flow uses if the AI doesn\u2019t select any of the Expected Decisions you've defined. This can be helpful as a fallback option, ensuring that your flow doesn\u2019t break if the AI\u2019s response doesn\u2019t match any specific outcome. You can use \"Everything Else\" to handle unexpected or unanticipated results, allowing you to log the outcome or take a default action.</p>"},{"location":"reference/ai-router-action.html#key-considerations","title":"Key Considerations","text":"<ul> <li> <p>Relevant and Informative Decisions: Ensure that your Expected Decisions are closely tied to the context of the prompt and Decision Data to ensure meaningful AI responses.</p> </li> <li> <p>Connector Creation: Each Expected Decision will generate a connector in the AI Router block, and each connector must have a corresponding successor block to handle the AI\u2019s decision.</p> </li> <li> <p>Fallback with \"Everything Else\": Always account for the \"Everything Else\" decision, which handles cases where the AI\u2019s response doesn\u2019t match any of the predefined Expected Decisions.</p> </li> </ul> <p>By setting up thoughtful Expected Decisions, you give the AI a clear range of outcomes to choose from, ensuring your app's flow runs smoothly and logically no matter what the AI decides.</p>"},{"location":"reference/ai-speech-to-text.html","title":"Speech to Text Block","text":"<p>The Speech to Text block converts audio recordings into written text using OpenAI's advanced Whisper models. This block provides accurate transcription capabilities for over 90 languages, making it ideal for applications that need to process spoken content such as meeting recordings, voice messages, podcasts, interviews, and multimedia content.</p> <p>The block leverages OpenAI's state-of-the-art speech recognition technology, which excels at handling challenging audio conditions including background noise, accents, and technical language. Whether you're building accessibility tools, content moderation workflows, or voice-driven applications, this block provides reliable speech-to-text conversion with flexible configuration options.</p> <p>Common use cases include transcribing customer support calls, generating subtitles for video content, processing voice notes and recordings, creating searchable text from audio archives, and enabling voice input for form submissions or content creation workflows.</p>"},{"location":"reference/ai-speech-to-text.html#input-configuration","title":"Input Configuration","text":"<p>The Speech to Text block requires audio input and offers several configuration options to optimize transcription results for your specific needs.</p> <p></p>"},{"location":"reference/ai-speech-to-text.html#model-selection","title":"Model Selection","text":"<p>The Model selection is optional. The dropdown allows you to choose which Whisper model to use for transcription. Different models offer various trade-offs between speed, accuracy, and computational requirements. Available models typically include options like <code>whisper-1</code> for general use, with newer models like <code>gpt-4o-transcribe</code> offering improved accuracy and language recognition. Choose models based on your requirements for speed versus accuracy.</p>"},{"location":"reference/ai-speech-to-text.html#file-url","title":"File URL","text":"<p>The File URL field accepts a publicly accessible URL pointing to your audio file. This field supports the Expression Editor, allowing you to reference audio URLs from previous blocks in your workflow, such as file upload results or audio processing outputs.</p> <p>Supported Audio Formats: The block accepts common audio formats including MP3, MP4, MPEG, MPGA, M4A, WAV, and WebM files. Audio files must be accessible via public URLs without requiring authentication.</p> <p>File Size Limitations: Audio files are limited to 25MB in size. For larger files, consider splitting them into smaller segments or re-encoding at lower bitrates while maintaining acceptable audio quality for transcription.</p>"},{"location":"reference/ai-speech-to-text.html#language","title":"Language","text":"<p>The Language field allows you to specify the language of the audio content. While Whisper can automatically detect languages, explicitly specifying the language often improves transcription accuracy, especially for shorter audio segments or when dealing with accents. Use standard language codes (e.g., \"en\" for English, \"es\" for Spanish, \"fr\" for French). The field supports the Expression Editor, enabling dynamic language selection based on previous workflow steps or user inputs. When left empty, the model will attempt automatic language detection.</p>"},{"location":"reference/ai-speech-to-text.html#prompt","title":"Prompt","text":"<p>The Prompt field provides context to help guide the transcription process. This optional parameter is particularly useful for maintaining consistency across multiple audio segments or when dealing with specialized terminology, proper nouns, or specific formatting requirements. Effective prompts include relevant context about the audio content, proper spellings of names or technical terms, and examples of the desired transcription style. For example: \"This is a medical consultation discussing patient symptoms and treatment options. Key terms include hypertension, diabetes, and cardiovascular health.\"</p> <p>Longer prompts (approaching the 224-token limit) tend to be more reliable at steering the model's output style and terminology choices.</p>"},{"location":"reference/ai-speech-to-text.html#temperature","title":"Temperature","text":"<p>The Temperature parameter controls the randomness and creativity of the transcription output. This numeric value ranges from 0 to 1, where lower values produce more deterministic and focused results, while higher values introduce more variability. For most transcription tasks, use low temperature values (0.0 to 0.2) to ensure the most accurate and consistent results. Higher temperatures might be useful in creative contexts where you want slight variations in phrasing, but they can also introduce transcription errors. A temperature of 0 forces the model to use deterministic decoding for maximum consistency.</p>"},{"location":"reference/ai-speech-to-text.html#understanding-the-results","title":"Understanding the Results","text":"<p>The Speech to Text block returns the transcribed text as a string that can be used by subsequent blocks in your workflow. The response format structure is shown below - it consists of the <code>text</code> property that contains the text of the transcription:</p> <p>Example Input: Audio file containing: \"Hello, welcome to our company meeting. Today we'll discuss quarterly results and future planning.\"</p> <p>Example Output: <pre><code>{\n  \"text\": \"Hello, welcome to our company meeting. Today we'll discuss quarterly results and future planning.\"\n}\n</code></pre></p>"},{"location":"reference/ai-speech-to-text.html#accessing-transcription-results","title":"Accessing Transcription Results","text":"<p>The transcribed text becomes available to subsequent workflow blocks through the Expression Editor. You can reference the complete transcription or use it as input for further processing such as content analysis, sentiment detection, or text summarization.</p> <p></p>"},{"location":"reference/ai-speech-to-text.html#quality-considerations","title":"Quality Considerations","text":"<p>Transcription accuracy depends on several factors including audio quality, speaker clarity, background noise levels, and language complexity. The Whisper models perform well with:</p> <ul> <li>Clear speech at normal speaking pace</li> <li>Minimal background noise</li> <li>Standard accents and pronunciation</li> <li>Audio recorded at adequate volume levels</li> </ul> <p>For optimal results, ensure audio files have good signal-to-noise ratios and avoid heavily compressed or distorted recordings when possible.</p>"},{"location":"reference/ai-speech-to-text.html#configuring-the-block","title":"Configuring the Block","text":"<p>Like all FlowRunner\u2122 blocks, you can customize how the Speech to Text block appears in your workflow and how its results are referenced by subsequent blocks.</p>"},{"location":"reference/ai-speech-to-text.html#block-naming","title":"Block Naming","text":"<p>Use the \"Name\" field to assign a descriptive name that reflects the block's purpose in your workflow. Examples include \"Customer Call Transcription,\" \"Meeting Notes Generation,\" or \"Voice Message Processing\" to make your workflow more readable and maintainable.</p>"},{"location":"reference/ai-speech-to-text.html#result-reference","title":"Result Reference","text":"<p>The \"Reference Result Data As\" field determines how other blocks in your workflow access the transcription results. Choose clear, descriptive names like \"TranscriptionResult\" or \"AudioText\" that make sense when building expressions in subsequent blocks.</p>"},{"location":"reference/ai-speech-to-text.html#implementation-strategies","title":"Implementation Strategies","text":""},{"location":"reference/ai-speech-to-text.html#multi-language-workflows","title":"Multi-Language Workflows","text":"<p>For applications handling multiple languages, combine language detection with conditional logic to route transcriptions appropriately. You can use the language parameter dynamically based on user selections or automatic detection from previous workflow steps.</p>"},{"location":"reference/ai-speech-to-text.html#large-file-processing","title":"Large File Processing","text":"<p>When working with audio files larger than 25MB, implement file splitting strategies in your workflow. Process audio in segments and combine the resulting transcriptions, using prompts to maintain context between segments.</p>"},{"location":"reference/ai-speech-to-text.html#quality-control-and-validation","title":"Quality Control and Validation","text":"<p>Consider implementing validation steps after transcription to check for common issues like very short outputs (indicating potential silence or processing errors) or unusually long outputs (indicating potential repeated content or hallucinations).</p>"},{"location":"reference/ai-speech-to-text.html#integration-with-content-moderation","title":"Integration with Content Moderation","text":"<p>Combine speech-to-text processing with content moderation blocks to automatically review transcribed content for policy violations, creating comprehensive audio content review workflows.</p>"},{"location":"reference/ai-speech-to-text.html#cost-optimization","title":"Cost Optimization","text":"<p>For high-volume transcription needs, consider using appropriate model sizes based on your accuracy requirements. Smaller models process faster and cost less, while larger models provide better accuracy for challenging audio conditions.</p>"},{"location":"reference/ai-text-to-speech.html","title":"Text to Speech Block","text":"<p>The Text to Speech block converts text into natural-sounding spoken audio using OpenAI's advanced TTS models. This block provides high-quality voice synthesis with multiple voice options, making it ideal for creating voiceovers, audio content, accessibility features, and interactive voice applications.</p> <p>The block leverages OpenAI's state-of-the-art text-to-speech technology, which produces human-like speech with natural intonation, rhythm, and pronunciation. Whether you're building educational content, narrating blog posts, creating audio books, or adding voice capabilities to applications, this block delivers professional-quality speech synthesis.</p> <p>Common use cases include generating voiceovers for multimedia content, creating audio versions of written articles, building voice assistants and chatbots, producing educational narrations, and enhancing accessibility by providing audio alternatives to text content.</p>"},{"location":"reference/ai-text-to-speech.html#input-configuration","title":"Input Configuration","text":"<p>The Text to Speech block offers comprehensive configuration options to customize the voice output according to your specific requirements.</p> <p></p>"},{"location":"reference/ai-text-to-speech.html#input-text","title":"Input Text","text":"<p>The Input field accepts the text content you want to convert to speech. This field supports the Expression Editor, allowing you to reference text from previous blocks in your workflow such as document processing results, user inputs, or dynamically generated content.</p> <p>Text Limitations: The input text is limited to 4,096 characters per request, which equals approximately 5 minutes of audio at normal speaking speed. For longer content, consider splitting the text across multiple Text to Speech blocks or implementing text chunking in your workflow.</p> <p>Text Formatting Tips: The models handle punctuation naturally to create appropriate pauses and intonation. Use standard punctuation marks for natural speech flow, and consider breaking long sentences into shorter ones for better pronunciation and pacing.</p>"},{"location":"reference/ai-text-to-speech.html#model-selection","title":"Model Selection","text":"<p>The Model dropdown allows you to choose between different TTS models that offer varying levels of quality and processing speed.</p> <p>Available Models:</p> <ul> <li>tts-1: Optimized for real-time applications with faster processing speed</li> <li>tts-1-hd: Higher quality model optimized for best audio fidelity</li> <li>gpt-4o-mini-tts: Newer model variant with enhanced capabilities</li> </ul> <p>Choose <code>tts-1</code> for applications requiring quick response times, such as real-time voice assistants. Select <code>tts-1-hd</code> when audio quality is the primary concern, such as for professional narrations or content creation.</p>"},{"location":"reference/ai-text-to-speech.html#voice-selection","title":"Voice Selection","text":"<p>The Voice dropdown provides access to multiple preset voices, each with distinct characteristics and personality traits.</p> <p>Available Voices:</p> <ul> <li>alloy: Neutral voice that works well for general applications</li> <li>echo: Clear, professional tone suitable for business content</li> <li>fable: Warm, storytelling voice ideal for narratives</li> <li>onyx: Deep, authoritative voice for formal content</li> <li>nova: Bright, engaging voice perfect for educational content</li> <li>shimmer: Expressive voice with dynamic range</li> </ul> <p>Recent Voice Additions: Newer models may include additional voices such as ash, ballad, coral, sage, and verse. Voice availability depends on the selected model.</p> <p>Voice characteristics can vary based on language and content type. Consider testing different voices with your specific content to find the best match for your application's tone and audience.</p>"},{"location":"reference/ai-text-to-speech.html#response-format","title":"Response Format","text":"<p>The Response Format dropdown determines the audio file format for the generated speech, allowing you to choose the most appropriate format for your use case.</p> <p>Available Formats:</p> <ul> <li>mp3: Compressed format ideal for web applications and streaming (default)</li> <li>opus: Efficient compression, excellent for real-time applications</li> <li>aac: High-quality compression, widely supported across platforms</li> <li>flac: Lossless compression for highest audio quality</li> <li>wav: Uncompressed format for professional audio production</li> <li>pcm: Raw audio data for custom processing applications</li> </ul> <p>Choose compressed formats (mp3, opus, aac) for web applications and mobile use. Select lossless formats (flac, wav) when audio quality is critical or when further audio processing is required.</p>"},{"location":"reference/ai-text-to-speech.html#speed-control","title":"Speed Control","text":"<p>The Speed field allows you to adjust the playback speed of the generated speech. This numeric field accepts decimal values to fine-tune the speaking rate.</p> <p>Speed Range: Values between 0.25 and 4.0 are supported</p> <ul> <li>0.25: Very slow, useful for learning applications or detailed explanations</li> <li>1.0: Normal speaking speed (default)</li> <li>1.5: Slightly faster, good for efficient content consumption</li> <li>2.0: Fast pace, suitable for quick information delivery</li> <li>4.0: Very fast, primarily for rapid content review</li> </ul> <p>Higher speeds can affect pronunciation quality, especially for complex words or technical terms. Test different speeds with your content to find the optimal balance between pace and clarity.</p>"},{"location":"reference/ai-text-to-speech.html#understanding-the-results","title":"Understanding the Results","text":""},{"location":"reference/ai-text-to-speech.html#accessing-audio-results","title":"Accessing Audio Results","text":"<p>The generated audio becomes available through the <code>fileURL</code> property of the block's response structure. You can access the property in subsequent workflow blocks through the Expression Editor. Depending on your workflow design, you can save the audio to storage, stream it directly to users, or combine it with other media content.</p> <p></p>"},{"location":"reference/ai-text-to-speech.html#quality-considerations","title":"Quality Considerations","text":"<p>Audio quality depends on several factors:</p> <p>Model Selection: The <code>tts-1-hd</code> model generally produces higher quality output compared to <code>tts-1</code>, but with longer processing times.</p> <p>Voice Compatibility: Different voices perform better with different types of content. Formal content often works well with <code>echo</code> or <code>onyx</code>, while storytelling benefits from <code>fable</code> or <code>nova</code>.</p> <p>Text Preparation: Well-structured text with proper punctuation produces more natural speech patterns. Consider adding pauses with punctuation and breaking complex sentences into shorter segments.</p> <p>Language Support: While the models support multiple languages, performance may vary. The voices are optimized for English but can handle other languages with varying degrees of effectiveness.</p>"},{"location":"reference/ai-text-to-speech.html#configuring-the-block","title":"Configuring the Block","text":""},{"location":"reference/ai-text-to-speech.html#block-naming","title":"Block Naming","text":"<p>Use the \"Name\" field to assign a descriptive name that reflects the block's purpose in your workflow. Examples include \"Article Narration,\" \"Customer Greeting Voice,\" or \"Educational Content Audio\" to make your workflow more readable and maintainable.</p>"},{"location":"reference/ai-text-to-speech.html#result-reference","title":"Result Reference","text":"<p>The \"Reference Result Data As\" field determines how other blocks in your workflow access the generated audio. Choose clear, descriptive names like \"AudioOutput\" or \"SpeechResult\" that make sense when building expressions in subsequent blocks.</p>"},{"location":"reference/ai-text-to-speech.html#implementation-strategies","title":"Implementation Strategies","text":""},{"location":"reference/ai-text-to-speech.html#content-segmentation","title":"Content Segmentation","text":"<p>For content longer than 4,096 characters, implement text chunking strategies. Split content at natural break points such as paragraph boundaries or sentence endings to maintain speech flow continuity across segments.</p>"},{"location":"reference/ai-text-to-speech.html#voice-consistency","title":"Voice Consistency","text":"<p>When using multiple Text to Speech blocks in a single workflow, maintain voice consistency by using the same voice and model settings throughout the process, unless intentional voice changes are desired for different speakers or content types.</p>"},{"location":"reference/ai-text-to-speech.html#performance-optimization","title":"Performance Optimization","text":"<p>For applications requiring real-time response, use the <code>tts-1</code> model with compressed audio formats like <code>opus</code> or <code>mp3</code>. For content creation or archival purposes, prioritize quality with <code>tts-1-hd</code> and lossless formats.</p>"},{"location":"reference/ai-text-to-speech.html#accessibility-enhancement","title":"Accessibility Enhancement","text":"<p>Combine text-to-speech with content moderation and text processing blocks to create comprehensive accessibility solutions. Ensure audio content includes appropriate pauses and emphasis for screen reader compatibility.</p>"},{"location":"reference/ai-text-to-speech.html#multi-language-support","title":"Multi-language Support","text":"<p>While the models support multiple languages, consider implementing language detection and voice selection logic to optimize speech quality for different languages in international applications.</p>"},{"location":"reference/ai-text-to-speech.html#cost-management","title":"Cost Management","text":"<p>Monitor usage carefully as text-to-speech processing incurs costs based on character count. Implement caching strategies for frequently requested content and consider text preprocessing to remove unnecessary characters or formatting.</p>"},{"location":"reference/applogic-trigger.html","title":"App Logic Trigger","text":"<p>The \"App Logic Trigger\" is a powerful trigger block integrated with the Backendless Codeless system. When a flow instance reaches this trigger, it goes into the waiting mode, nothing in the flow is executed until the trigger is activated. You can customize the trigger by assigning a name to the block that reflects the event that activates the trigger:</p> <p></p>"},{"location":"reference/applogic-trigger.html#integration-with-codeless","title":"Integration with Codeless","text":"<p>When you add an \"App Logic Trigger\" to a flow, the Codeless toolbar will automatically display a menu item for the flow with the \"Run App Logic Trigger\" block in it.</p> <p></p>"},{"location":"reference/applogic-trigger.html#understanding-trigger-activation","title":"Understanding Trigger Activation","text":"<p>Trigger activation is a crucial concept in FlowRunner\u2122, and with its various options, it can become quite complex. Understanding all possibilities is essential for efficient flow management.</p> <p>A general rule to keep in mind is that a flow must be started with the Call Flow request. If your flow has a schedule, the FlowRunner\u2122 scheduler will automatically use the Call Flow request to initiate your flow. Using the Call Flow creates a new instance of your flow, which means you could have multiple instances running simultaneously.</p> <p>When your flow includes an \"App Logic Trigger,\" some or all instances may reach this trigger and wait for activation. There are three trigger activation modes described further in this chapter: 1. The <code>Activate All</code> option will activate all waiting flow instances, causing all of them to run again.  2. The <code>Activate Any</code> option will activate a random flow instance.  3. Tthe <code>Activate Specific</code> option will activate a specific instance identified by the provided <code>executionId</code> value.</p>"},{"location":"reference/applogic-trigger.html#activation-modes","title":"Activation Modes","text":"<p>The Codeless block for activating the trigger includes an \"Activation Mode\" option with three supported modes:</p> <p></p> <ol> <li> <p>Activate Any: If multiple instances of the flow are waiting on the same \"App Logic Trigger\", this will activate a random flow instance. If the flow starts with an \"App Logic Trigger\", a new instance will be created.</p> <p>Note</p> <p>If a flow starts with an \"App Logic Trigger\" and you activate it with the <code>Activate Any</code> option, it is the only case when a new instance of a flow is created without a prior <code>Call Flow</code> request.</p> </li> <li> <p>Activate All: If multiple instances of the flow are waiting on the same \"App Logic Trigger\", this will activate all of them. If no flows are waiting on the trigger, the request will return an error.</p> </li> <li> <p>Activate Specific: Activates a specific flow instance identified by its <code>executionId</code>. The <code>executionId</code> for this option can be obtained from the result of the Call Flow request. For example, the Codeless logic below uses the Call Flow request, stores the <code>executionId</code> value in <code>Page Data</code> and then activates an \"App Logic Trigger\" with it.</p> <p></p> <p>If a flow instance was started by a scheduler, the flow developer must ensure that the <code>executionId</code> value is passed to the application that needs to use it. </p> </li> </ol>"},{"location":"reference/applogic-trigger.html#passing-data-to-the-trigger","title":"Passing Data to the Trigger","text":"<p>You can pass data to an \"App Logic Trigger\" through the \"Body\" connector on the Codeless block. This connector expects an object and is optional:</p> <p></p> <p>Any data passed to the trigger will be available through the Expression Editor as an element with the name assigned to the \"App Logic Trigger\" block:</p> <p></p>"},{"location":"reference/applogic-trigger.html#additional-configurations","title":"Additional Configurations","text":"<p>Similar to other trigger blocks, the \"App Logic Trigger\" can be configured with an activation condition and user authorization constraints. For more information, see the Required Authentication and Conditional Trigger Activation chapters in the External Callback section of this guide.</p>"},{"location":"reference/assign-instance-name.html","title":"Assign Instance Name","text":"<p>The Assign Instance Name action in FlowRunner\u2122 enables flow designers to dynamically assign a unique and descriptive name to each flow instance. This name acts as a visual identifier in the analytics interface, enhancing traceability and making it easier to interpret execution data.  </p> <p>Every flow instance operates in its own isolated context, managing the data specific to that instance. Assigning an instance name provides a meaningful label in analytics, allowing flow designers to quickly identify and analyze individual runs, especially when multiple instances execute concurrently.  </p>"},{"location":"reference/assign-instance-name.html#how-it-works","title":"How It Works","text":"<p>Flow designers use the Expression Editor to define the name for an instance. This name can be dynamically generated using: </p> <ul> <li>Data from trigger events.  </li> <li>Outputs from actions and transformations.  </li> <li>Static text combined with dynamic values.  </li> </ul> <p>For example, a flow processing customer feedback might use the following name: <pre><code>User: {{User Name}}, Email: {{Email Address}}\n</code></pre> where <code>User Name</code> and <code>Email Address</code> are values retrieved earlier in the flow.  </p>"},{"location":"reference/assign-instance-name.html#timing-of-name-assignment","title":"Timing of Name Assignment","text":"<p>It is recommended to assign the instance name early in the flow's runtime. Analytics will display the name only after it has been assigned. If the flow runs for an extended period before the name is set, its analytics entry will show a unique identifier assigned buy the system. Assigning the name at the start (or right after start) ensures visibility throughout the entire lifecycle of the flow instance.  </p>"},{"location":"reference/assign-instance-name.html#setting-up","title":"Setting Up","text":"<p>To configure the Assign Instance Name action:  </p> <ol> <li>Add the Action: Place the Assign Instance Name block in the flow at the point where the name should be assigned. Ideally, this should be near the beginning of the flow.  </li> <li> <p>Define the Name: Use the Expression Editor to create a meaningful name. You can use:  </p> <ul> <li>A single dynamic value, such as <code>{{UserEmail}}</code>.  </li> <li>A composite value, such as <code>Feedback Submission - {{FeedbackID}}</code>.  </li> <li>A combination of multiple data points to provide detailed context.  </li> </ul> </li> <li> <p>Save the Configuration: Once the configuration is complete, the action will assign the specified name to the flow instance when executed.  </p> </li> </ol>"},{"location":"reference/assign-instance-name.html#best-practices","title":"Best Practices","text":"<ul> <li>Leverage Dynamic Names: Use the flexibility of the Expression Editor to create meaningful and unique names that reflect the flow\u2019s context.  </li> <li>Assign Early: Place the Assign Instance Name block early in the flow to ensure the instance is identified in analytics from the start.  </li> <li>Be Descriptive: Choose names that provide insight into the instance's purpose or key data to simplify monitoring and debugging.  </li> </ul> <p>By using the Assign Instance Name action effectively, flow designers can enhance the transparency and manageability of their flows while improving the usefulness of analytics.  </p>"},{"location":"reference/call-flow-action.html","title":"Call Flow Block","text":"<p>The Call Flow block enables your workflow to execute other flows within your FlowRunner\u2122 workspace, creating modular and reusable automation patterns. This block acts as a bridge between flows, allowing you to break complex processes into smaller, manageable components that can be called from multiple workflows.</p> <p>This capability is essential for building scalable automation architectures where common functionality can be centralized and reused across different workflows. Whether you need to perform standard data validation, execute shared business logic, or trigger related processes, the Call Flow block provides the flexibility to compose sophisticated workflows from reusable building blocks.</p> <p>Common use cases include calling data processing flows from multiple entry points, executing validation routines across different workflows, triggering notification flows from various business processes, implementing shared calculation logic, and creating modular approval workflows that can be invoked from different contexts.</p>"},{"location":"reference/call-flow-action.html#input-configuration","title":"Input Configuration","text":"<p>The Call Flow block offers comprehensive configuration options to control how flows are called, what data is passed between them, and how execution is managed.</p> <p></p>"},{"location":"reference/call-flow-action.html#flow-selection","title":"Flow Selection","text":"<p>The Flow dropdown lists all available flows in your current workspace. </p> <p>Called Flow Requirement</p> <p>Only flows that have been started and are in the <code>LIVE</code> state can be called from other workflows.</p> <p>The dropdown includes a refresh icon that allows you to update the list of available flows without leaving the current workflow editor. This is particularly useful when collaborating with team members or when you've created new flows in separate browser windows.</p> <p>Flow Selection Guidelines:</p> <ul> <li>All flows appear in the dropdown, but only flows in <code>LIVE</code> state can be executed/called using the Call Flow block </li> <li>All flows within your workspace/account are available for selection</li> <li>Use the refresh icon to update the list after creating new flows</li> <li>Choose flows that are designed to be called by other workflows for best results</li> </ul>"},{"location":"reference/call-flow-action.html#initial-parameters","title":"Initial Parameters","text":"<p>The Initial Params section allows you to pass data from the current workflow to the called flow. This composite element consists of Property and Value field pairs that can be added using the \"+\" button.</p> <p>Property Field: A simple text input where you specify the parameter name. This name will be used to access the data in the called flow through the Expression Editor's \"Initial Data\" element.</p> <p>Value Field: Supports the Expression Editor, allowing you to pass dynamic data from previous blocks in your current workflow. You can pass any data type including strings, numbers, objects, and arrays.</p> <p>Parameter Configuration Examples:</p> <ul> <li>Property: <code>userId</code>, Value: <code>${UserRegistration.id}</code></li> <li>Property: <code>orderData</code>, Value: <code>${OrderProcessing.orderDetails}</code></li> <li>Property: <code>validationRules</code>, Value: <code>{\"minAge\": 18, \"requiredFields\": [\"email\", \"name\"]}</code></li> </ul> <p>The parameters you define here become available in the called flow through the Expression Editor as <code>Initial Data.userId</code>, <code>Initial Data.orderData</code>, etc.</p>"},{"location":"reference/call-flow-action.html#execution-control","title":"Execution Control","text":"<p>The \"Wait for Execution\" toggle determines whether the current flow waits for the called flow to complete before proceeding to the next block.</p> <p>Synchronous Execution (Toggle Enabled):</p> <ul> <li>Current flow pauses until called flow completes</li> <li>If the called flow uses a \"Return Result\" block, that returned value becomes the result of the Call Flow block</li> <li>Best for scenarios where you need the called flow's output before proceeding</li> <li>Useful for validation flows, calculation flows, or data transformation flows</li> </ul> <p>Asynchronous Execution (Toggle Disabled):</p> <ul> <li>Current flow continues immediately after initiating the call</li> <li>Call Flow block returns an <code>executionId</code> for the started flow</li> <li>Best for triggering independent processes like notifications, logging, or parallel workflows</li> <li>Useful for fire-and-forget scenarios where the calling flow doesn't need to wait</li> </ul>"},{"location":"reference/call-flow-action.html#user-session-management","title":"User Session Management","text":"<p>The User Session Source dropdown controls how user identity and authentication information is passed to the called flow.</p> <p>Available Options:</p> <p>None: No user information is passed to the called flow. The called flow executes without any user context.</p> <p>Execution Init User: Passes the user object that was provided when the current flow started. This maintains the original user context throughout the flow chain.</p> <p>Trigger User: Passes the user object from a specific trigger within the current flow. When this option is selected, a second dropdown appears allowing you to choose which trigger's user information to pass.</p> <p>The trigger selection dropdown shows all preceding triggers in the current flow that have captured user information, such as External Callback triggers that received user-token headers.</p>"},{"location":"reference/call-flow-action.html#understanding-the-results","title":"Understanding the Results","text":"<p>The Call Flow block's result depends on the execution mode and whether the called flow returns data.</p>"},{"location":"reference/call-flow-action.html#synchronous-execution-results","title":"Synchronous Execution Results","text":"<p>When \"Wait for Execution\" is enabled, the block result depends on the called flow's behavior:</p> <p>With Return Result Block: If the called flow includes a \"Return Result\" block, the data returned by that block becomes the Call Flow block's result.</p> <pre><code>{\n  \"validationStatus\": \"passed\",\n  \"processedData\": {\n    \"userId\": 12345,\n    \"score\": 85.5\n  },\n  \"timestamp\": \"2024-01-15T10:30:00Z\"\n}\n</code></pre> <p>Without Return Result Block: If the called flow doesn't explicitly return data, the Call Flow block returns an object with the <code>executionId</code> property and its value.</p>"},{"location":"reference/call-flow-action.html#asynchronous-execution-results","title":"Asynchronous Execution Results","text":"<p>When \"Wait for Execution\" is disabled, the Call Flow block immediately returns an execution identifier:</p> <pre><code>{\n  \"executionId\": \"550e8400-e29b-41d4-a716-446655440000\"\n}\n</code></pre> <p>This execution ID can be used to track or query the status of the called flow through other mechanisms if needed.</p>"},{"location":"reference/call-flow-action.html#accessing-results","title":"Accessing Results","text":"<p>The Call Flow results become available to subsequent workflow blocks through the Expression Editor, just like any other block result.</p> <p>Common Access Patterns:</p> <ul> <li><code>CallFlowResult.validationStatus</code>: Accessing returned data from synchronous calls</li> <li><code>CallFlowResult.executionId</code>: Accessing execution ID from asynchronous calls</li> <li><code>CallFlowResult.processedData.userId</code>: Accessing nested data structures</li> </ul>"},{"location":"reference/call-flow-action.html#configuring-the-block","title":"Configuring the Block","text":"<p>Like all FlowRunner\u2122 blocks, you can customize how the Call Flow block appears in your workflow and how its results are referenced by subsequent blocks.</p>"},{"location":"reference/call-flow-action.html#block-naming","title":"Block Naming","text":"<p>Use the \"Name\" field to assign a descriptive name that reflects the block's purpose in your workflow. Examples include \"Validate User Data,\" \"Process Order Items,\" or \"Send Notification\" to make your workflow more readable and maintainable.</p>"},{"location":"reference/call-flow-action.html#result-reference","title":"Result Reference","text":"<p>The \"Reference Result Data As\" field determines how other blocks in your workflow access the Call Flow results. Choose clear, descriptive names like \"ValidationResult\" or \"ProcessingOutput\" that make sense when building expressions in subsequent blocks.</p>"},{"location":"reference/call-flow-action.html#implementation-strategies","title":"Implementation Strategies","text":""},{"location":"reference/call-flow-action.html#modular-workflow-design","title":"Modular Workflow Design","text":"<p>Design called flows to be self-contained and reusable. Create flows that perform specific functions and can be called from multiple contexts. This approach promotes maintainability and reduces duplication across your automation system.</p>"},{"location":"reference/call-flow-action.html#parameter-standardization","title":"Parameter Standardization","text":"<p>Establish consistent parameter naming conventions across your workspace. Use clear, descriptive property names that make it easy to understand what data is being passed between flows.</p>"},{"location":"reference/call-flow-action.html#error-handling-patterns","title":"Error Handling Patterns","text":"<p>For synchronous calls, implement error handling in both the calling and called flows. The called flow should use Return Result blocks to communicate success or failure status, while the calling flow should check results and handle different scenarios appropriately.</p>"},{"location":"reference/call-flow-action.html#user-context-management","title":"User Context Management","text":"<p>Carefully consider which user context to pass to called flows. Use \"Execution Init User\" for maintaining original user identity throughout a process chain, or \"Trigger User\" when you need to pass specific user information from particular trigger events.</p>"},{"location":"reference/call-flow-action.html#performance-considerations","title":"Performance Considerations","text":"<p>Use asynchronous calls for operations that don't require immediate results, such as logging, notifications, or background processing. Reserve synchronous calls for scenarios where you genuinely need the called flow's output before proceeding.</p>"},{"location":"reference/call-flow-action.html#flow-state-management","title":"Flow State Management","text":"<p>Ensure called flows are in LIVE state before deploying workflows that depend on them. Implement testing procedures to verify that all flow dependencies are properly deployed and functional.</p>"},{"location":"reference/call-flow-action.html#debugging-and-monitoring","title":"Debugging and Monitoring","text":"<p>When using Call Flow blocks, consider how to track execution across multiple flows. For asynchronous calls, the execution ID can be valuable for monitoring and debugging purposes. For synchronous calls, ensure that error conditions in called flows are properly communicated back to the calling flow.</p>"},{"location":"reference/condition.html","title":"Condition Block","text":"<p>The Condition block is FlowRunner\u2122's primary decision-making component, allowing your workflow to branch into different paths based on logical evaluations. This block creates a fork in your automation where the flow follows one route if the condition evaluates to true (<code>Yes</code> path) and another route if it evaluates to false (<code>No</code> path).</p> <p>The Condition block is essential for building intelligent workflows that respond dynamically to data, user inputs, business rules, and changing circumstances. Whether you need to validate user permissions, check business hours, evaluate data quality, or implement approval workflows, the Condition block provides the logical foundation for sophisticated automation decision-making.</p> <p>Common use cases include user access control based on roles or permissions, business rule enforcement such as discount eligibility or shipping options, data validation and quality checks, workflow routing based on priority or urgency levels, and time-based automation that behaves differently during business hours versus weekends.</p>"},{"location":"reference/condition.html#block-configuration","title":"Block Configuration","text":"<p>The Condition block uses the same condition configuration system described in the Conditional Logic chapter, supporting single checks and multiple parts connected with AND/OR operators.</p> <p></p>"},{"location":"reference/condition.html#building-your-condition-logic","title":"Building Your Condition Logic","text":"<p>The Condition block accepts any combination of condition checks, from simple single evaluations to complex multi-part expressions with parenthetical grouping.</p> <p>Single Check Example: Evaluate whether a user's account status equals \"Premium\" to determine if they have access to advanced features.</p> <p>Multi-Part Example: Check if it's a weekday AND the current time is during business hours AND the user has the required permissions before allowing certain operations.</p> <p></p>"},{"location":"reference/condition.html#condition-configuration-fields","title":"Condition Configuration Fields","text":"<p>The condition configuration within the Condition block includes:</p> <ol> <li>Value to Check: Select the data you want to evaluate using the Expression Editor</li> <li>Value Data Type: Choose the appropriate data type (String, Int, Double, Boolean, Datetime, Image, JSON Object, JSON Array)</li> <li>Operation: Select the comparison or evaluation operation based on the data type</li> <li>Additional Fields: Dynamically appearing fields based on the selected operation</li> </ol> <p>For complete details on available operations and configuration options, refer to the Conditional Logic chapter.</p>"},{"location":"reference/condition.html#understanding-block-execution","title":"Understanding Block Execution","text":"<p>The Condition block evaluates your configured logic and directs flow execution based on the result.</p>"},{"location":"reference/condition.html#execution-flow-paths","title":"Execution Flow Paths","text":"<p>Yes Path: When the condition evaluates to <code>true</code>, the flow continues along the Yes branch. Connect subsequent blocks to this path for actions that should occur when the condition is met.</p> <p>No Path: When the condition evaluates to <code>false</code>, the flow continues along the No branch. Connect alternative actions or error handling logic to this path.</p> <p></p>"},{"location":"reference/condition.html#practical-implementation-examples","title":"Practical Implementation Examples","text":""},{"location":"reference/condition.html#user-permission-check","title":"User Permission Check","text":"<p>Configure a condition that checks if a user has the required role for accessing a specific feature:</p> <p>Value to Check: <code>Initial User &gt; roles</code> Value Data Type: JSON ARRAY Operation: CONTAINS VALUE Value: \"Administrator\"</p> <p></p> <p>This creates a simple branch where administrative users follow one path while other users are directed to an access denied or alternative workflow path.</p>"},{"location":"reference/condition.html#business-hours-validation","title":"Business Hours Validation","text":"<p>Create a condition that determines if the current time falls within business hours:</p> <p>Value to Check: <code>Get Hour Operation Result</code> Value Data Type: INT Operation: GREATER OR EQUAL Value: 9</p> <p>AND</p> <p>Value to Check: <code>Get Hour Operation Result</code> Value Data Type: INT  Operation: LESS THAN Value: 17</p> <p></p> <p>This multi-part condition ensures operations only proceed during standard business hours (9 AM to 5 PM).</p>"},{"location":"reference/condition.html#configuring-the-block","title":"Configuring the Block","text":"<p>Like all FlowRunner\u2122 blocks, you can customize how the Condition block appears in your workflow and how its results are referenced by subsequent blocks.</p>"},{"location":"reference/condition.html#block-naming","title":"Block Naming","text":"<p>Use the \"Name\" field to assign a descriptive name that reflects the block's decision logic. Examples include \"Check User Permissions,\" \"Validate Business Hours,\" or \"Verify Required Data\" to make your workflow more readable and self-documenting.</p>"},{"location":"reference/condition.html#result-reference","title":"Result Reference","text":"<p>The \"Reference Result Data As\" field determines how other blocks in your workflow access the condition evaluation results. Choose clear names like \"PermissionCheck\" or \"ValidationResult\" that make sense when building expressions in subsequent blocks.</p>"},{"location":"reference/condition.html#best-practices-for-condition-blocks","title":"Best Practices for Condition Blocks","text":""},{"location":"reference/condition.html#logical-flow-design","title":"Logical Flow Design","text":"<p>Design your Yes and No paths to handle all possible scenarios gracefully. Consider what should happen when conditions are not met and provide appropriate alternative actions or error handling.</p>"},{"location":"reference/condition.html#complex-condition-management","title":"Complex Condition Management","text":"<p>For very complex logical evaluations, consider whether to use one comprehensive Condition block or multiple simpler blocks in sequence. Multiple blocks often provide better readability and easier debugging, while single complex blocks offer better performance.</p>"},{"location":"reference/condition.html#error-handling-integration","title":"Error Handling Integration","text":"<p>Connect your Condition block to Handle Error blocks when appropriate, especially when dealing with data that might be missing or invalid. This ensures your workflow can handle unexpected scenarios gracefully.</p>"},{"location":"reference/condition.html#testing-and-validation","title":"Testing and Validation","text":"<p>Test your Condition blocks with various data scenarios including edge cases, null values, and boundary conditions. Use clear test data to verify that your logical expressions behave as expected.</p>"},{"location":"reference/condition.html#performance-considerations","title":"Performance Considerations","text":"<p>When using multiple condition checks within a single block, order them strategically. Place the most likely conditions first in OR expressions and the most restrictive conditions first in AND expressions to optimize evaluation performance.</p>"},{"location":"reference/condition.html#documentation-and-maintenance","title":"Documentation and Maintenance","text":"<p>Use descriptive block names and consider adding comments or documentation blocks near complex conditions to explain the business logic. This helps with maintenance and team collaboration.</p>"},{"location":"reference/delete-record-action.html","title":"Delete Record in Database","text":"<p>The \"Delete Record in Database\" action block makes it easy to remove records from your Backendless database. Whether you need to delete a single record or multiple records that match certain criteria, this block offers a simple and effective way to manage your data.</p>"},{"location":"reference/delete-record-action.html#deleting-a-single-record","title":"Deleting a Single Record","text":"<p>When you want to delete a specific record, you'll use the Use Data From The Flow option. If you have data in your flow that matches a record in your database, this option lets you delete that record. You just need to select the relevant data in your flow and specify the database table where the record is stored. </p> <p></p> <p>Imagine you have a record that was the result of another action, trigger, or transformer - this data element, which must be in a key/value structure format, should include an <code>objectId</code> key. The <code>objectId</code> is a unique identifier that tells Backendless exactly which record to delete. Once you've selected the right data element, you\u2019ll also need to specify which table in your database the record belongs to. When the action runs, the identified record in that table is removed.</p>"},{"location":"reference/delete-record-action.html#deleting-records-with-a-query","title":"Deleting Records with a Query","text":"<p>To delete one or more records that match specific criteria, use the Use Where Clause option. This option allows you to create a database query using the Expression Editor, which Backendless will then run against your specified table. The query, written in Backendless' \"where clause\" syntax, defines the conditions that the records must meet to be deleted. When this action is executed, any record in the selected table that matches the query conditions is deleted.</p> <p></p>"},{"location":"reference/delete-record-action.html#action-result","title":"Action Result","text":"<p>The result of the \"Delete Record in Database\" action is the number of records that were successfully deleted. This information can be helpful in confirming that the deletion was carried out correctly and can be used in further steps within your flow. If you'd like, you can give this result a custom name using the Reference Result Data As field, making it easier to refer to in subsequent actions.</p> <p></p> <p>In essence, the \"Delete Record in Database\" action block simplifies the process of removing unnecessary records, whether you\u2019re dealing with a single item or a group of records that meet certain criteria. With the ability to seamlessly integrate this action into your flow, you can ensure that your database stays organized and up-to-date.</p>"},{"location":"reference/error-handler.html","title":"Error Handler","text":"<p>Errors are a natural part of workflow automation. Anticipating and managing them effectively ensures your automations remain reliable and resilient. FlowRunner\u2122 offers powerful error-handling tools to help your workflows recover gracefully from issues like failed service calls, database errors, or invalid input data.  </p>"},{"location":"reference/error-handler.html#common-error-scenarios","title":"Common Error Scenarios","text":"<p>Errors in your workflows can arise from various sources, including:  </p> <ul> <li>External Services: Failures in API requests due to service downtime or error responses.  </li> <li>Database Queries: Issues like malformed queries or insufficient permissions.  </li> <li>Invalid Inputs: Actions failing because of incorrect or missing data.  </li> <li>File Uploads: Problems caused by network interruptions or file size limits.  </li> </ul>"},{"location":"reference/error-handler.html#the-handle-error-block","title":"The <code>Handle Error</code> Block","text":"<p>The <code>Handle Error</code> block is a specialized mechanism for managing errors in your flows. Unlike action or trigger blocks, it acts as a fallback route for your flow when errors occur.  </p>"},{"location":"reference/error-handler.html#how-it-works","title":"How It Works","text":"<p>When you connect a block to the <code>Handle Error</code> block, any errors in that block redirect the flow to the <code>Handle Error</code> block. From there, successors define how the error is handled. For example, you could log the error, notify an admin, or call another flow to recover from the issue.  </p> <p>In the example below, if the <code>Retrieve Orders</code> block encounters an error, control passes to the <code>Handle Error</code> block, which directs it to the <code>Log Error</code> block. If no error occurs, the flow continues to <code>Process Orders</code>: </p>"},{"location":"reference/error-handler.html#error-types","title":"Error Types","text":"<p>Errors in FlowRunner\u2122 fall into two categories:  </p> <ul> <li>Handled Errors: These are errors connected to a <code>Handle Error</code> block. The flow knows how to respond and continues executing.  </li> <li>Unhandled Errors: These occur when no <code>Handle Error</code> block is connected. They cause the flow to stop unexpectedly.  </li> </ul>"},{"location":"reference/error-handler.html#error-structure","title":"Error Structure","text":"<p>Errors are represented as a key/value structure with three main properties:  </p> <ul> <li><code>code</code>: A numeric identifier for the specific error type.  </li> <li><code>message</code>: A text description of the error, useful for troubleshooting.  </li> <li><code>source</code>: The name of the block where the error occurred, especially helpful when reusing a <code>Handle Error</code> block.  </li> </ul>"},{"location":"reference/error-handler.html#accessing-error-information","title":"Accessing Error Information","text":"<p>When an error is handled, successors of the <code>Handle Error</code> block can access error details via the \"Handle Error Result\" in the Expression Editor. This information allows you to implement custom error-handling strategies based on the error\u2019s properties:  </p> <ul> <li>Use the <code>code</code> to classify the error type.  </li> <li>Log meaningful details from the <code>message</code>.  </li> <li>Trace the origin of the error using the <code>source</code>.  </li> </ul>"},{"location":"reference/error-handler.html#conditional-error-handling-example","title":"Conditional Error Handling Example","text":"<p>Conditional logic can be used to respond differently based on the <code>code</code> or other error properties. For instance, you might:  </p> <ul> <li>Retry a failed action if the error code indicates a temporary issue.  </li> <li>Log and notify administrators for critical errors.  </li> <li>Redirect to a fallback process for non-recoverable errors.  </li> </ul> <p>The example below shows how to use a condition block to handle specific errors based on their <code>code</code>: </p> <p>This approach enables tailored responses to errors, ensuring your workflows remain resilient and adaptable.  </p>"},{"location":"reference/error-handler.html#best-practices-for-error-handling","title":"Best Practices for Error Handling","text":"<ol> <li>Identify Error-Prone Blocks: Recognize which blocks may encounter errors, such as external service calls or database queries.  </li> <li>Use <code>Handle Error</code> Blocks: Connect these blocks to <code>Handle Error</code> blocks to ensure proper handling. You can centralize error handling or use multiple <code>Handle Error</code> blocks for different errors.  </li> <li> <p>Define Recovery Strategies: Plan how to respond to errors, such as:  </p> </li> <li> <p>Logging the error for analysis.  </p> </li> <li>Sending notifications to administrators.  </li> <li>Retrying the action after a delay (use the Wait Block).  </li> <li>Switching to fallback options, like an alternative service.  </li> <li>Calling another flow for advanced error handling (see Call Flow Action).  </li> </ol> <p>By following these best practices, you can create workflows that are resilient to unexpected issues and maintain operational stability.  </p>"},{"location":"reference/external-callback-trigger.html","title":"External Callback Trigger","text":"<p>The External Callback trigger allows your workflow to pause and wait for external systems to send confirmation before continuing. This is essential when your process depends on events outside your application, such as payment confirmations, email verifications, or third-party approvals.</p> <p>When your flow reaches an External Callback trigger, it pauses execution and waits for an HTTP request to a unique callback URL. External systems activate the trigger by calling this URL, optionally passing data that becomes available to subsequent blocks in your flow.</p>"},{"location":"reference/external-callback-trigger.html#common-use-case-order-processing","title":"Common Use Case: Order Processing","text":"<p>Consider an e-commerce scenario where you need to process orders only after payment confirmation. Here's how you structure this workflow:</p> <ol> <li>Order Received: The flow starts when a new order is placed</li> <li>Process Order Details: The flow processes the order details and prepares for fulfillment</li> <li>External Callback Trigger: The flow pauses and waits for payment confirmation</li> <li>Complete Order: Once payment is confirmed via the callback, the flow continues to complete the order</li> </ol> <p>This ensures orders are only processed after successful payment while allowing your system to prepare everything else in advance.</p>"},{"location":"reference/external-callback-trigger.html#setting-up-the-external-callback-block","title":"Setting Up the External Callback Block","text":"<p>When you add an External Callback trigger to your flow, FlowRunner\u2122 generates a unique URL for that trigger. This URL serves as the endpoint where external systems send their callback requests.</p> <p></p> <p>The URL includes unique identifiers for both your flow and the specific trigger, ensuring callbacks reach the correct destination even when you have multiple flows or multiple callback triggers running simultaneously.</p>"},{"location":"reference/external-callback-trigger.html#callback-request-format","title":"Callback Request Format","text":"<p>External systems can activate your trigger using either GET or POST HTTP methods. The choice between methods affects how you pass data to the trigger and how you manage multiple workflow instances.</p> <p>Base Endpoint: <pre><code>https://xxxx.backendless.app/api/automation/flow/[FLOW-ID]/trigger/[TRIGGER-ID]/activate\n</code></pre></p> <p>The <code>[FLOW-ID]</code> and <code>[TRIGGER-ID]</code> are automatically generated identifiers. Use the trigger's properties panel to get the complete URL.</p>"},{"location":"reference/external-callback-trigger.html#understanding-trigger-placement","title":"Understanding Trigger Placement","text":"<p>How you structure your callback request depends on where the External Callback trigger is positioned in your workflow:</p> <p>Flow-Starting Triggers: When an External Callback trigger is the first block in your flow, activating it creates a new workflow instance. These triggers start fresh executions rather than resuming existing ones.</p> <p>Mid-Flow Triggers: When an External Callback trigger appears in the middle of your workflow, it pauses an already-running execution. Activating these triggers resumes the paused workflow instance from that specific point.</p> <p>This distinction is important because mid-flow triggers require you to specify which workflow instance should be resumed, while flow-starting triggers always create new instances.</p>"},{"location":"reference/external-callback-trigger.html#get-method-requests","title":"GET Method Requests","text":"<p>GET requests pass data through query parameters, making them useful for simple callbacks with minimal data.</p> <p>For Flow-Starting Triggers: <pre><code>GET https://xxxx.backendless.app/api/automation/flow/[FLOW-ID]/trigger/[TRIGGER-ID]/activate?param1=value1&amp;param2=value2\n</code></pre></p> <p>All query parameters become the trigger data object available to subsequent blocks. See the Accessing Callback Data section for additional details.</p> <p>For Mid-Flow Triggers: <pre><code>GET https://xxxx.backendless.app/api/automation/flow/[FLOW-ID]/trigger/[TRIGGER-ID]/activate?execution=EXECUTION_ID&amp;param1=value1&amp;param2=value2\n</code></pre></p> <p>The <code>execution</code> or <code>executionId</code> parameter specifies which workflow instance to resume. All other query parameters form the trigger data object. For more details about the trigger data object, see the Accessing Callback Data section.</p>"},{"location":"reference/external-callback-trigger.html#post-method-requests","title":"POST Method Requests","text":"<p>POST requests allow you to send more complex data structures in the request body, making them suitable for callbacks with rich data payloads.</p> <p>For Flow-Starting Triggers: <pre><code>POST https://xxxx.backendless.app/api/automation/flow/[FLOW-ID]/trigger/[TRIGGER-ID]/activate\nContent-Type: application/json\n\n{\n  \"any valid JSON object can be passed to the trigger\"\n}\n</code></pre></p> <p>FlowRunner\u2122 uses the entire request body as the \"trigger data\" object. Query parameters are ignored for flow-starting triggers.</p> <p>For Mid-Flow Triggers: <pre><code>POST https://xxxx.backendless.app/api/automation/flow/[FLOW-ID]/trigger/[TRIGGER-ID]/activate?execution=EXECUTION_ID\nContent-Type: application/json\n\n{\n  \"any valid JSON object can be passed to the trigger\"\n}\n</code></pre></p> <p>The <code>execution</code> or <code>executionId</code> query parameter specifies which workflow instance to resume. FlowRunner\u2122 uses the entire request body as the \"trigger data\" object, and other query parameters are ignored.</p>"},{"location":"reference/external-callback-trigger.html#managing-multiple-workflow-instances","title":"Managing Multiple Workflow Instances","text":"<p>When working with mid-flow triggers, you often need to manage multiple instances of the same workflow. For example, if your workflow processes orders and uses a timer to create new instances throughout the day, you might have several order processing workflows waiting at External Callback triggers for payment confirmments.</p> <p>The execution parameter provides three powerful options for managing these instances:</p> <p>Specific Execution ID: Use the exact execution ID to resume one particular workflow instance. This approach gives you precise control when you need to target a specific order or process. <pre><code>?execution=ABC123-DEF456-GHI789\n</code></pre></p> <p>Any Available Instance: Use \"any\" to let FlowRunner\u2122 pick any waiting workflow instance and resume it. This approach works well when all waiting instances are equivalent and you just need to process the next available one. <pre><code>?execution=any\n</code></pre></p> <p>All Waiting Instances: Use \"all\" to resume every workflow instance that's waiting at this trigger. This approach is useful for broadcast scenarios where one external event should wake up multiple processes simultaneously. <pre><code>?execution=all\n</code></pre></p>"},{"location":"reference/external-callback-trigger.html#obtaining-execution-ids-for-external-systems","title":"Obtaining Execution IDs for External Systems","text":"<p>When using specific execution IDs, external systems need to know which execution ID to include in their callback requests. This creates an important design consideration: your workflow must actively share the execution ID with external systems before reaching the External Callback trigger.</p> <p>The execution ID becomes available through the Expression Editor as soon as your workflow starts running. Your flow logic should capture this ID and send it to external systems through whatever communication channel you're using.</p> <p>Common Implementation Pattern: A typical approach involves sending an email or creating a web page that includes the execution ID in a URL parameter. For example, your workflow might send a payment verification email containing a link like:</p> <pre><code>https://yourapp.com/verify-payment?executionId=ABC123-DEF456-GHI789&amp;orderId=12345\n</code></pre> <p>When users click this link, your web application can extract the execution ID from the URL and include it in the callback request to resume that specific workflow instance.</p> <p>Accessing Execution ID in Your Flow: The execution ID is accessible through the Expression Editor interface at any point in your workflow. You can reference this value in email templates, API calls, database records, or any other blocks that communicate with external systems.</p> <p></p> <p>This pattern ensures that external systems have the information they need to target specific workflow instances while maintaining the security and reliability of your automation processes.</p>"},{"location":"reference/external-callback-trigger.html#authentication-headers","title":"Authentication Headers","text":"<p>Optional User Token: <pre><code>user-token: value \n</code></pre></p> <p>The <code>user-token</code> header passes the identity of an authenticated user to the trigger, making user information available to subsequent blocks in your workflow.</p>"},{"location":"reference/external-callback-trigger.html#response-handling","title":"Response Handling","text":"<p>Successful Activation: Returns <code>HTTP 200</code> with no response body for single instance activation. When using <code>execution=all</code>, the response contains a comma-separated list of all resumed execution IDs.</p> <p>Error Responses: When no workflow instances are waiting at the trigger (for \"any\" or \"all\" options) or when a specific execution ID doesn't exist, FlowRunner\u2122 returns a JSON error response with details about the failure.</p>"},{"location":"reference/external-callback-trigger.html#accessing-callback-data","title":"Accessing Callback Data","text":"<p>When external systems send data with callback requests, that data becomes available to subsequent blocks in your workflow through the Expression Editor. The system references this data using the trigger's assigned name.</p> <p></p> <p>In this example, the trigger is named \"Callback with Orders\" so any data sent to it becomes accessible as \"Callback with Orders Data\".</p> <p>Here's a sample callback request that sends order data:</p> <p></p> <p>The same request in cURL format: <pre><code>curl 'https://demoapp.backendless.app/api/automation/flow/AC0B2747-EAD8-4C9A-BB9C-9F0A4EBEAB81/trigger/C778279B-B151-6272-EDA7-76C9141E1F11/activate' \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n      \"data\":[\n         {\"name\":\"shampoo\",\"price\":9.95},\n         {\"name\":\"conditioner\",\"price\":8.99},\n         {\"name\":\"body wash\",\"price\":5.99}\n      ]\n  }'\n</code></pre></p> <p>After the trigger activates, subsequent blocks can access this data through the Expression Editor:</p> <p></p>"},{"location":"reference/external-callback-trigger.html#working-with-authenticated-users","title":"Working with Authenticated Users","text":"<p>Include a <code>user-token</code> header in callback requests to pass authenticated user information to your workflow. This token represents a logged-in Backendless user and makes the complete user object available to subsequent blocks.</p> <p></p> <p>The user object contains all properties from your application's Users table. For example, with this Users table schema:</p> <p></p> <p>The user object accessible through the Expression Editor would include:</p> <pre><code>{\n  \"lastLogin\": 1719591614000,\n  \"lastName\": \"Bond\",\n  \"userStatus\": \"ENABLED\",\n  \"gender\": \"male\",\n  \"firstName\": \"James\",\n  \"phoneNumber\": \"+44 007007007\",\n  \"age\": 45,\n  \"email\": \"jamesbond@mi6.co.uk\",\n  \"created\": 1719589705912,\n  \"accountType\": \"BACKENDLESS\",\n  \"objectId\": \"087A2B43-EB71-4322-AD34-EDA9CA77B77E\"\n}\n</code></pre> <p>Access these properties easily through the Expression Editor:</p> <p></p>"},{"location":"reference/external-callback-trigger.html#configuring-authentication-requirements","title":"Configuring Authentication Requirements","text":"<p>You can require authentication for callback requests to ensure only authorized users can trigger your workflow. Set the trigger's <code>Authentication Type</code> property to <code>BACKENDLESS</code>:</p> <p></p> <p>With this setting, the trigger only activates when callbacks include a valid <code>user-token</code> header. You can further restrict access by specifying required security roles:</p> <p></p> <p>The <code>On Fail Policy</code> setting controls how the system handles requests that fail authentication or role requirements:</p> <p></p> <p>When set to <code>ERROR</code>, failed authentication returns this error response:</p> <pre><code>{\n    \"code\": 1000,\n    \"message\": \"Unable to execute the callback. User is missing required security role(s)\"\n}\n</code></pre> <p>When set to <code>IGNORE</code>, the callback request completes successfully but the trigger does not activate if authentication fails.</p>"},{"location":"reference/external-callback-trigger.html#conditional-trigger-activation","title":"Conditional Trigger Activation","text":"<p>You can add conditions to External Callback triggers to control when they actually activate. When a callback request arrives, FlowRunner\u2122 evaluates the condition first. The trigger only activates if the condition evaluates to <code>TRUE</code>. If the condition evaluates to <code>FALSE</code>, the callback request is ignored and the workflow remains paused.</p> <p>This is useful when external systems might send multiple status updates but you only want to proceed when a specific condition is met, such as a payment status reaching \"confirmed\" rather than just \"processing\".</p> <p>For more information about setting up conditions, see the Conditional Logic section.</p>"},{"location":"reference/find-records-action.html","title":"Find Record(s) in Database","text":"<p>The \"Find Record(s) in Database\" action block is a powerful feature in FlowRunner\u2122 that allows you to tap into the full potential of your Backendless database. Whether you\u2019re managing customer information, tracking inventory, or analyzing sales data, this block makes it easy to retrieve the exact records you need.</p> <p>Your Backendless workspace includes a complete, cloud-based database where you can store and manage all kinds of data. As your data grows, you\u2019ll often need to filter, sort, and retrieve specific records to use in your automated workflows. That\u2019s where the \"Find Record(s) in Database\" block comes in.</p> <p>This block is essential for any process that requires pulling data from your database\u2014whether you\u2019re sending personalized emails to customers, generating reports, or triggering actions based on specific criteria. With it, you can pinpoint the exact data you need, ensuring your workflows are both efficient and precise.</p>"},{"location":"reference/find-records-action.html#how-it-works","title":"How It Works","text":"<p>The \"Find Record(s) in Database\" block allows you to retrieve records from any table in your Backendless database. You can customize the data retrieval by using an optional \"where clause\" query, sorting the results, and managing the number of records returned through pagination settings.</p>"},{"location":"reference/find-records-action.html#blocks-properties","title":"Block's Properties","text":"<p>The \"Find Record(s) in Database\" action block comes with several configurable properties that allow you to tailor the data retrieval to your specific needs. Let\u2019s go through each of these properties to understand how they work.</p> <p></p>"},{"location":"reference/find-records-action.html#table-or-view","title":"Table or View","text":"<p>This property allows you to specify the source from which you want to retrieve records. In your Backendless workspace, you can select either a database table or a view. Tables store your data directly, while views are virtual tables that represent the result of a query. Selecting the appropriate table or view is the first step in ensuring that you pull the relevant records into your Flow. Simply choose the table or view that contains the data you need.</p>"},{"location":"reference/find-records-action.html#where-clause","title":"Where Clause","text":"<p>A where clause instructs the database to filter the records retrieved by setting specific criteria. This clause uses Backendless' \"where clause\" syntax to define the conditions that records must meet to be included in the results. For example, you could use a where clause to find all customers who have made a purchase in the last 30 days or to retrieve records that match a certain status. If you leave this field empty, the block will return records starting from the specified \"Offset\" up to the \"Page Size.\"</p>"},{"location":"reference/find-records-action.html#sort-by","title":"Sort By","text":"<p>This property lets you determine the order in which the records are returned. You can specify one or more columns by which to sort the results, and choose whether to sort each column in ascending or descending order. If you sort by multiple columns, the block will first sort by the primary column; any records with the same value in this column will then be sorted by the secondary column, and so on. There are several formats to specify the columns names:</p> <ul> <li>Comma delimited string value:     <pre><code>Name,Price\n</code></pre></li> <li> <p>List of string values. For the demonstration purposes, the first screenshot below creates a list of string values. The second screenshot shows how to utilize the list in the Sort By parameter:      </p> <p>This feature is useful when you need your data organized in a specific way, such as listing customers alphabetically by last name or ordering sales transactions by date.</p> </li> </ul>"},{"location":"reference/find-records-action.html#page-size","title":"Page Size","text":"<p>This property controls how many records are returned in a single query. This is particularly useful when working with large datasets, as it allows you to retrieve a manageable number of records at a time. If you don\u2019t specify a page size, the system will default to returning 10 records. Adjusting the page size can help you balance between performance and the volume of data you want to work with. Maximum page size in the Backendless Development System is 100 records. You can customize it in the self-hosted version of the Backendless Platform. For additional information about database paging, see the Data Retrieval with Paging section in the Backendless Development System documentation.</p>"},{"location":"reference/find-records-action.html#offset","title":"Offset","text":"<p>Determines where the data retrieval starts within the dataset. By default, the offset is set to 0, meaning the block will start retrieving records from the very beginning of the table. If you\u2019re paging through results or want to skip a certain number of records, you can adjust the offset to begin retrieval from a different point. This property is essential when you need to manage large amounts of data across multiple queries.</p>"},{"location":"reference/find-records-action.html#result-format","title":"Result Format","text":"<p>The records retrieved by the \"Find Record(s) in Database\" block are returned as a JSON list. Each record in the list is represented as a JSON object (a key/value structure), where the keys correspond to the column names in the database table/view, and the values are the corresponding data values from the records. This format makes it easy to process and manipulate the data further in your Flow.</p>"},{"location":"reference/find-records-action.html#handling-errors","title":"Handling Errors","text":"<p>If something goes wrong during the data retrieval\u2014such as an invalid query or a connection issue - the error can be managed using the Error Handler block. This ensures that your Flow can gracefully handle issues and continue running or take alternative actions as needed.</p>"},{"location":"reference/http-request-action.html","title":"HTTP Request Block","text":"<p>The HTTP Request block enables your workflow to communicate with external APIs, web services, and endpoints by making HTTP requests. This block provides complete control over request configuration, allowing you to integrate with virtually any REST API, webhook, or web service that accepts HTTP communications.</p> <p>This block is essential for building workflows that interact with external systems such as CRM platforms, payment processors, notification services, data providers, and third-party APIs. Whether you need to fetch data, submit forms, trigger external processes, or synchronize information across systems, the HTTP Request block provides the flexibility to handle diverse integration scenarios.</p> <p>Common use cases include calling REST APIs for data retrieval, posting form submissions to external services, triggering webhooks for event notifications, integrating with payment gateways, updating records in external databases, and connecting with social media platforms or marketing automation tools.</p>"},{"location":"reference/http-request-action.html#input-configuration","title":"Input Configuration","text":"<p>The HTTP Request block offers comprehensive configuration options to construct and customize HTTP requests for any external service or API.</p> <p></p>"},{"location":"reference/http-request-action.html#url","title":"URL","text":"<p>The URL field specifies the complete endpoint address for your HTTP request. This field supports the Expression Editor, allowing you to dynamically construct URLs using data from previous workflow blocks.</p> <p>You can build URLs dynamically by combining base URLs with dynamic parameters. For example, you might construct an API endpoint like the one shown below: <pre><code>https://api.example.com/users/${userId}/orders\n</code></pre> where <code>userId</code> comes from a previous block's result. This dynamic URL built with the Expression Editor may look as shown below:</p> <p></p> <p>URL Construction Tips:</p> <ul> <li>Always include the complete URL with protocol (https:// or http://)</li> <li>Use the Expression Editor to inject dynamic values into the URL path</li> <li>Ensure proper URL encoding for special characters when building dynamic URLs</li> <li>Consider using query parameters for optional or variable data rather than embedding everything in the URL path</li> </ul>"},{"location":"reference/http-request-action.html#http-method","title":"HTTP Method","text":"<p>The HTTP Method dropdown allows you to select the appropriate HTTP verb for your request, determining how the receiving server should process your request.</p> <p>Available Methods:</p> <ul> <li>GET: Retrieve data from the server (most common for API calls)</li> <li>POST: Send data to create new resources or submit forms</li> <li>PUT: Update existing resources with complete replacement</li> <li>PATCH: Partially update existing resources</li> <li>DELETE: Remove resources from the server</li> <li>HEAD: Retrieve headers only, without the response body</li> </ul> <p>Choose the method that matches the API's expected behavior. Most data retrieval operations use GET, while form submissions and data creation typically use POST. Update operations generally use PUT for complete replacement or PATCH for partial updates.</p>"},{"location":"reference/http-request-action.html#request-body","title":"Request Body","text":"<p>The Body field contains the data payload sent with your HTTP request. This field supports the Expression Editor, enabling you to send dynamic content constructed from previous workflow steps.</p> <p>Body Usage Guidelines:</p> <ul> <li>Required for POST, PUT, and PATCH requests when sending data</li> <li>Typically empty for GET, DELETE, and HEAD requests</li> <li>Most APIs expect JSON format, but can also send XML, form data, or plain text</li> <li>Use the Expression Editor to construct JSON payloads dynamically</li> <li>Ensure the body content matches the Content-Type header you specify</li> </ul> <p>Example JSON Body: <pre><code>{\n  \"name\": \"${userName}\",\n  \"email\": \"${userEmail}\",\n  \"data\": {\n    \"timestamp\": \"${currentTimestamp}\",\n    \"source\": \"FlowRunner\u2122\"\n  }\n}\n</code></pre></p>"},{"location":"reference/http-request-action.html#query-parameters","title":"Query Parameters","text":"<p>The Query field allows you to specify URL query parameters that are appended to the request URL. This field supports the Expression Editor for dynamic parameter construction.</p> <p>Query parameters are ideal for filtering, pagination, sorting, and optional request modifiers. Format parameters as key-value pairs, for example:</p> <p><pre><code>page=1&amp;limit=50&amp;sort=created_date&amp;filter=${categoryName}\n</code></pre> </p> <p>Query Parameter Best Practices:</p> <ul> <li>Use for GET requests to filter or modify results</li> <li>Include pagination parameters for large datasets</li> <li>Add API keys or tokens if required by the service</li> <li>URL encoding is handled automatically for special characters</li> <li>Keep parameter names consistent with the API documentation</li> </ul>"},{"location":"reference/http-request-action.html#headers","title":"Headers","text":"<p>The Headers section allows you to specify HTTP headers as name-value pairs. You can add multiple headers using the \"+\" button, and the Value fields support the Expression Editor for dynamic header construction.</p> <p>Common Headers:</p> <ul> <li>Content-Type: Specifies the format of the request body (e.g., <code>application/json</code>)</li> <li>Authorization: Contains authentication tokens or API keys</li> <li>Accept: Indicates the expected response format</li> <li>User-Agent: Identifies your application to the receiving server</li> <li>X-API-Key: Custom header for API authentication</li> </ul> <p>Example Header Configuration:</p> <ul> <li>Name: <code>Content-Type</code>, Value: <code>application/json</code></li> <li>Name: <code>Authorization</code>, Value: <code>Bearer ${apiToken}</code></li> <li>Name: <code>X-API-Key</code>, Value: <code>${dynamicApiKey}</code></li> <li>Name: <code>Accept</code>, Value: <code>application/json</code></li> </ul> <p></p>"},{"location":"reference/http-request-action.html#understanding-the-results","title":"Understanding the Results","text":"<p>The HTTP Request block returns only the response body from the target server. Status codes and headers are not included in the block result.</p> <p>Example API Response Body: <pre><code>{\n  \"id\": 12345,\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"status\": \"active\"\n}\n</code></pre></p>"},{"location":"reference/http-request-action.html#accessing-response-data","title":"Accessing Response Data","text":"<p>The HTTP response body becomes available to subsequent workflow blocks through the Expression Editor. You can access the returned data directly as it was sent by the server.For JSON responses, you can directly access object properties and array elements. For text responses, the entire content is available as a string value.</p>"},{"location":"reference/http-request-action.html#error-handling","title":"Error Handling","text":"<p>Since the HTTP Request block returns only the response body, HTTP errors and status codes are not directly accessible in the block result. However, many APIs include error information in their response body when errors occur.</p> <p>API Error Response Examples: <pre><code>{\n  \"error\": \"Not Found\",\n  \"message\": \"User with ID 12345 does not exist\",\n  \"code\": 404\n}\n</code></pre></p> <pre><code>{\n  \"success\": false,\n  \"error_code\": \"INVALID_TOKEN\",\n  \"error_message\": \"Authentication token is invalid or expired\"\n}\n</code></pre> <p>Handle errors by checking for error indicators in the response body content rather than HTTP status codes. Use conditional logic in subsequent blocks to detect error responses based on the API's error format.</p>"},{"location":"reference/http-request-action.html#configuring-the-block","title":"Configuring the Block","text":"<p>Like all FlowRunner\u2122 blocks, you can customize how the HTTP Request block appears in your workflow and how its results are referenced by subsequent blocks.</p>"},{"location":"reference/http-request-action.html#block-naming","title":"Block Naming","text":"<p>Use the \"Name\" field to assign a descriptive name that reflects the block's purpose in your workflow. Examples include \"User Profile API Call,\" \"Payment Processing Request,\" or \"Webhook Notification\" to make your workflow more readable and maintainable.</p>"},{"location":"reference/http-request-action.html#result-reference","title":"Result Reference","text":"<p>The \"Reference Result Data As\" field determines how other blocks in your workflow access the HTTP response. Choose clear, descriptive names like \"APIResponse\" or \"UserData\" that make sense when building expressions in subsequent blocks.</p>"},{"location":"reference/http-request-action.html#implementation-strategies","title":"Implementation Strategies","text":""},{"location":"reference/http-request-action.html#authentication-patterns","title":"Authentication Patterns","text":"<p>Different APIs use various authentication methods. Implement authentication using headers:</p> <p>API Key Authentication: Add a header like <code>X-API-Key</code> with your API key value.</p> <p>Bearer Token Authentication: Use an <code>Authorization</code> header with value <code>Bearer ${token}</code>.</p> <p>Basic Authentication: Use an <code>Authorization</code> header with value <code>Basic ${encodedCredentials}</code>.</p>"},{"location":"reference/http-request-action.html#error-handling-and-retry-logic","title":"Error Handling and Retry Logic","text":"<p>Implement robust error handling by checking for error indicators in the response body content. Create conditional paths for success and failure scenarios based on the API's response format, and consider implementing retry logic for transient failures.</p>"},{"location":"reference/http-request-action.html#data-transformation","title":"Data Transformation","text":"<p>Often, API responses need transformation before use in subsequent workflow steps. Combine HTTP Request blocks with data processing blocks to extract, format, or restructure response data as needed.</p>"},{"location":"reference/http-request-action.html#rate-limiting-and-performance","title":"Rate Limiting and Performance","text":"<p>Be mindful of API rate limits and implement appropriate delays between requests when making multiple calls. Some APIs include rate limit information in response headers that you can use to adjust request timing.</p>"},{"location":"reference/http-request-action.html#security-considerations","title":"Security Considerations","text":"<p>Never hardcode sensitive information like API keys or passwords directly in the configuration. Use Expression Editor to reference secure data from previous blocks or external configuration sources. Ensure HTTPS is used for sensitive data transmission.</p>"},{"location":"reference/http-request-action.html#pagination-handling","title":"Pagination Handling","text":"<p>For APIs that return paginated results, implement logic to handle multiple requests by tracking pagination tokens or page numbers, and combine results from multiple requests as needed.</p>"},{"location":"reference/list-iterator.html","title":"List Iterator Block","text":"<p>The List Iterator block enables your workflow to process collections of data by executing a sequence of operations for each item in a list. This block functions as a loop mechanism, allowing you to apply the same logic repeatedly to every element in an array or collection, making it essential for bulk data processing, batch operations, and repetitive tasks.</p> <p>The List Iterator block provides a sophisticated looping environment where you can design complex processing logic that executes once for each item in your input list. Whether you're processing user records, transforming data arrays, validating multiple items, or performing bulk operations across datasets, this block provides the control and flexibility needed for efficient list processing.</p> <p>Common use cases include processing arrays of user data for bulk updates, transforming collections of records from API responses, validating multiple form submissions or uploads, generating reports from lists of transactions, and performing batch operations like sending emails to multiple recipients or updating multiple database records.</p>"},{"location":"reference/list-iterator.html#block-configuration","title":"Block Configuration","text":"<p>The List Iterator block requires a single input parameter that defines the collection of data to be processed.</p> <p></p>"},{"location":"reference/list-iterator.html#list-input","title":"List Input","text":"<p>The List input field accepts any array or collection from previous blocks in your workflow. Use the Expression Editor to select arrays from API responses, database queries, file processing results, or any other source that provides list data.</p> <p>Supported List Types:</p> <ul> <li>JSON arrays</li> <li>Database query result sets</li> <li>File processing outputs (CSV rows, etc.)</li> <li>User-generated collections</li> <li>Transformed data arrays from previous blocks</li> </ul> <p>The List Iterator will execute its internal logic once for each item in the provided array, regardless of the data type or structure of the individual items.</p>"},{"location":"reference/list-iterator.html#internal-flow-design","title":"Internal Flow Design","text":"<p>The List Iterator block creates a contained execution environment where you design the logic that processes each list item. When you navigate into the List Iterator block, FlowRunner\u2122 opens a dedicated canvas for building the iteration logic. To access the internal canvas, double click the List Iterator block, or click the Expand icon. You will navigate the block's internal design environment. This canvas operates identically to the main flow editor but represents the logic that executes for each iteration.</p>"},{"location":"reference/list-iterator.html#special-flow-context-elements","title":"Special Flow Context Elements","text":"<p>When designing logic inside a List Iterator, the Expression Editor provides access to special context elements that are specific to the current iteration and essential for most iterator implementations.</p> <p></p>"},{"location":"reference/list-iterator.html#current-iteration-number","title":"Current Iteration Number","text":"<p>The \"Current Iteration Number\" element provides the zero-based index of the current loop cycle. This value starts at 0 for the first item and increments by 1 for each subsequent iteration.</p> <p>Use Cases for Iteration Number:</p> <ul> <li>Creating unique identifiers or filenames</li> <li>Implementing pagination or batching logic</li> <li>Adding sequence numbers to processed items</li> <li>Conditional logic based on iteration position</li> <li>Progress tracking and logging</li> </ul>"},{"location":"reference/list-iterator.html#current-iteration-item","title":"Current Iteration Item","text":"<p>The \"Current Iteration Item\" element provides direct access to the data for the current list item being processed. The structure and content depend on the type of data in your input list.</p> <p>Accessing Item Data:</p> <ul> <li><code>Flow Context.Current Iteration Item</code>: The complete current item</li> <li><code>Flow Context.Current Iteration Item.propertyName</code>: Specific properties of object items</li> <li>For simple arrays: the element value directly</li> <li>For object arrays: access object properties and nested data</li> </ul>"},{"location":"reference/list-iterator.html#loop-control-and-termination","title":"Loop Control and Termination","text":"<p>The List Iterator processes each item in the provided list sequentially. By default, it will iterate through every item in the collection, but you can implement early termination using loop control blocks.</p>"},{"location":"reference/list-iterator.html#break-block-integration","title":"Break Block Integration","text":"<p>Within the List Iterator's internal flow, you can use a Break block to exit the loop early based on specific conditions. This allows you to implement scenarios where you only need to process items until a certain condition is met.</p> <p></p> <p>Common Break Scenarios:</p> <ul> <li>Stop processing when a target value is found</li> <li>Exit early when error thresholds are reached</li> <li>Terminate based on accumulated results or counters</li> <li>Implement timeout or resource limit controls</li> </ul>"},{"location":"reference/list-iterator.html#empty-list-handling","title":"Empty List Handling","text":"<p>When the List Iterator receives an empty array or null value, it skips execution entirely and continues to the next block in the main workflow. No iterations occur, and any blocks within the List Iterator are not executed.</p>"},{"location":"reference/list-iterator.html#variable-access-and-data-return","title":"Variable Access and Data Return","text":"<p>The List Iterator block operates within the scope of the main workflow, providing specific patterns for accessing external data and returning results from the iteration process.</p>"},{"location":"reference/list-iterator.html#accessing-external-variables","title":"Accessing External Variables","text":"<p>Logic inside the List Iterator can read and reference any variables or data declared in blocks that execute before the List Iterator. This includes results from previous blocks, trigger data, and any other workflow context.</p> <p>Available External Data:</p> <ul> <li>Results from all previous blocks in the main flow</li> <li>Initial trigger data and parameters</li> <li>Global workflow variables and constants</li> <li>User session information and context data</li> </ul>"},{"location":"reference/list-iterator.html#returning-data-from-iterations","title":"Returning Data from Iterations","text":"<p>The List Iterator block cannot directly return data through traditional result mechanisms. Instead, you must use external variables to collect and store iteration results using dedicated variable management blocks.</p> <p>Variable Update Mechanisms:</p> <ul> <li>Set Variables Block: Assign values directly to predefined variables</li> <li>Transform Data Block: Process data and assign the result to a variable</li> </ul> <p>Data Return Pattern:</p> <ol> <li>Create or initialize a variable in the main flow before the List Iterator</li> <li>Within the iterator logic, use Set Variables or Transform Data blocks to update external variables</li> <li>After the List Iterator completes, access the accumulated results from the external variable</li> </ol> <p>Implementation Strategy:</p> <ul> <li>Use Array or Object variables to collect results from each iteration</li> <li>Implement append or update operations to modify external variables</li> <li>Consider using conditional logic to filter which results to store</li> <li>Handle error scenarios to prevent incomplete data collection</li> </ul>"},{"location":"reference/list-iterator.html#error-handling-strategies","title":"Error Handling Strategies","text":"<p>The List Iterator provides flexible error handling options that can be implemented at different levels of the iteration process.</p>"},{"location":"reference/list-iterator.html#external-error-handling","title":"External Error Handling","text":"<p>Errors that occur within the List Iterator's internal logic are propagated to the main workflow level. You can connect the List Iterator block to a Handle Error block to manage these exceptions at the workflow level.</p> <p></p>"},{"location":"reference/list-iterator.html#internal-error-handling","title":"Internal Error Handling","text":"<p>Alternatively, you can use Handle Error blocks within the List Iterator's internal flow to manage errors locally for individual iterations. This approach allows the iteration to continue processing remaining items even when individual items encounter errors.</p> <p></p> <p>Internal Error Handling Benefits:</p> <ul> <li>Continue processing remaining list items after individual failures</li> <li>Collect error information while maintaining overall progress</li> <li>Implement item-specific error recovery logic</li> <li>Maintain detailed error tracking per iteration</li> </ul>"},{"location":"reference/list-iterator.html#performance-and-limitations","title":"Performance and Limitations","text":""},{"location":"reference/list-iterator.html#runtime-considerations","title":"Runtime Considerations","text":"<p>Every FlowRunner\u2122 flow has limits on total runtime duration, which depend on your subscription plan. List Iterator blocks can consume significant execution time when processing large datasets or performing complex operations per iteration.</p> <p>Optimization Strategies:</p> <ul> <li>Consider the size of input lists when designing iteration logic</li> <li>Implement efficient processing patterns within iterations</li> <li>Use Break blocks to exit early when objectives are met</li> <li>Monitor total execution time for compliance with plan limits</li> </ul> <p>Large Dataset Recommendations:</p> <ul> <li>Break large lists into smaller batches using multiple List Iterator blocks</li> <li>Implement pagination or chunking strategies</li> <li>Consider asynchronous processing patterns for very large datasets</li> <li>Use conditional logic to skip unnecessary processing steps</li> </ul>"},{"location":"reference/list-iterator.html#execution-time-management","title":"Execution Time Management","text":"<p>For very large lists, consider implementing execution strategies that optimize total flow runtime:</p> <ul> <li>Process only essential items based on filtering criteria</li> <li>Use parallel processing approaches with multiple smaller iterators</li> <li>Implement checkpoint patterns to resume processing across multiple flow executions</li> <li>Monitor and log progress to identify performance bottlenecks</li> </ul>"},{"location":"reference/record-removed-trigger.html","title":"Blocker:","text":"<ul> <li>https://backendless.atlassian.net/browse/AUTO-570</li> </ul>"},{"location":"reference/record-saved-trigger.html","title":"Record Created in Database","text":"<p>The \"Record Created in Database\" trigger in FlowRunner\u2122 allows you to pause flow execution until a new record is saved in a specified database table. This is useful for automating actions that depend on new data entries. For instance, you might want to send an email notification whenever a new product is added to your inventory database.</p>"},{"location":"reference/record-saved-trigger.html#how-the-trigger-works","title":"How the Trigger Works","text":"<p>When a new record is added to the specified database table, the trigger pauses the flow until this event occurs. The created record is then available as a key/value structure (an object) for all successor blocks in the flow, with the table's columns corresponding to the object's properties.</p>"},{"location":"reference/record-saved-trigger.html#trigger-properties","title":"Trigger Properties","text":"<p>The trigger properties include:</p> <ul> <li>Name - should be a meaningful name that represents what this trigger does. Follow the recommendations in the Block Naming section of this guide for best practices.</li> <li>Table - a table in the Backendless Database where FlowRunner\u2122 will monitor for newly created records.</li> <li>Authentication Type - specifies whether an authenticated user is required to activate the trigger.</li> <li>Condition - an optional condition associated with the trigger. When the trigger receives an activation event, the system checks the condition. If the condition is evaluated to <code>TRUE</code>, the flow execution proceeds, otherwise, the trigger's event is ignored.</li> <li>Reference Trigger Data As - this is a name assigned to the data that activated the trigger. The data is a key/value structure that contains the values for the record stored in the trigger's configured table.</li> </ul> <p></p>"},{"location":"reference/record-saved-trigger.html#required-authentication","title":"Required Authentication","text":"<p>You can configure the Record Created in Database trigger to require authentication, ensuring that a reference to an authenticated user is present in the trigger activation event. To enable this, select the trigger block and set the <code>Authentication Type</code> property to <code>BACKENDLESS</code>:</p> <p></p> <p>With the setting shown above, the trigger will activate only when the event has a valid user reference through the <code>user-token</code> HTTP header. Additionally, you can specify the security roles that the referenced user must have. This selection is made in the <code>Required Roles</code> drop-down list:</p> <p></p> <p>The <code>On Fail Policy</code> setting allows you to define how the trigger activation request should be handled if there is no authenticated user or if the user does not belong to the specified roles:</p> <p></p> <p>If the policy is set to <code>ERROR</code>, the trigger will issue the following error for events that fail the authentication or role check. The error must be handled to avoid flow execution interruptions. For more details, see the Error Handling section of this guide.</p> <pre><code>{\n    \"code\": 1000,\n    \"message\": \"Unable to execute the callback. User is missing required security role(s)\"\n}\n</code></pre> <p>If the policy is set to <code>IGNORE</code>, the trigger activation request will be completed successfully, but the trigger will not be activated if the user reference is missing or the user does not have the required roles.</p> <p>By using these authentication settings, you can ensure that your workflows are secure and only triggered by authorized users.</p>"},{"location":"reference/record-saved-trigger.html#accessing-event-data","title":"Accessing Event Data","text":"<p>The data from the event that activated the trigger is available through the Expression Editor. This data is structured in a key/value format, where the key names correspond to the column names of the respective database table. You can access this data to create a condition for the trigger or use it in any block that follows the trigger in the flow. By default, the name of the element containing trigger event data in the Expression Editor will use the name you assigned to the block followed by the word <code>Data</code>: </p> <p>You can modify the name of the element that references the data using the <code>Reference Trigger Data As</code> field: </p>"},{"location":"reference/record-saved-trigger.html#example-configuration","title":"Example Configuration","text":"<p>Imagine a <code>Products</code> table with columns: <code>ProductName</code>, <code>Quantity</code>, and <code>Category</code>. </p> <p></p> <p>You want to send an email notification only if the <code>Quantity</code> is greater than zero when a new record is added.</p> <ol> <li> <p>Trigger Block: Set up the \"Record Created in Database\" trigger to monitor the <code>Products</code> table.</p> </li> <li> <p>Condition: Create a condition using the Expression Editor to check if <code>Quantity &gt; 0</code>.</p> </li> <li> <p>Successor Blocks: Add an email action block that uses properties of the created record (e.g., <code>ProductName</code>, <code>Quantity</code>) to compose and send the notification.</p> </li> </ol> <p></p> <p>The \"Record Created in Database\" trigger helps automate workflows based on new data entries. By pausing the flow until a new record is added and optionally checking conditions, you ensure that automated actions are timely and relevant. This trigger seamlessly integrates real-time data changes into your business processes.</p>"},{"location":"reference/record-updated-trigger.html","title":"Record Updated in Database","text":"<p>The \"Record Updated in Database\" trigger in FlowRunner\u2122 allows you to pause flow execution until an existing record in a specified database table is updated. This is particularly useful for automating actions that should occur in response to changes in your data. When the trigger is activated, the updated record is made accessible to successor blocks through the Expression Editor.</p>"},{"location":"reference/record-updated-trigger.html#how-the-trigger-works","title":"How the Trigger Works","text":"<p>When an existing record in the specified database table is updated, this trigger pauses the flow until that update occurs. The updated record is then available as a key/value structure (an object) for all successor blocks in the flow. The structure of the \"result\" object matches the columns of the table, making it easy to work with the updated data.</p>"},{"location":"reference/record-updated-trigger.html#trigger-properties","title":"Trigger Properties","text":"<p>The trigger properties include:</p> <ul> <li>Name - should be a meaningful name that represents what this trigger does. Follow the recommendations in the Block Naming section of this guide for best practices.</li> <li>Table - a table in the Backendless Database where FlowRunner\u2122 will monitor for updated records.</li> <li>Authentication Type - specifies whether an authenticated user is required to activate the trigger.</li> <li>Condition - an optional condition associated with the trigger.  When the trigger is activated, FlowRunner\u2122 evaluates the condition. If the condition evaluates to <code>TRUE</code>, the flow continues its execution. If the condition evaluates to <code>FALSE</code>, the trigger activation is ignored. For more information about conditions, see the Conditional Logic section of this guide. </li> <li>Reference Trigger Data As - this is a name assigned to the data that activated the trigger. The data is a key/value structure that contains the values for the record updated in the trigger's configured table.</li> </ul> <p></p>"},{"location":"reference/record-updated-trigger.html#required-authentication","title":"Required Authentication","text":"<p>You can configure the Record Updated in Database trigger to require authentication, ensuring that a reference to an authenticated user is present in the trigger activation event. To enable this, select the trigger block and set the <code>Authentication Type</code> property to <code>BACKENDLESS</code>:</p> <p></p> <p>With the setting shown above, the trigger will activate only when the event has a valid user reference through the <code>user-token</code> HTTP header. Additionally, you can specify the security roles that the referenced user must have. This selection is made in the <code>Required Roles</code> drop-down list:</p> <p></p> <p>The <code>On Fail Policy</code> setting allows you to define how the trigger activation request should be handled if there is no authenticated user or if the user does not belong to the specified roles:</p> <p></p> <p>If the policy is set to <code>ERROR</code>, the trigger will issue the following error for events that fail the authentication or role check. The error must be handled to avoid flow execution interruptions. For more details, see the Error Handling section of this guide.</p> <pre><code>{\n    \"code\": 1000,\n    \"message\": \"Unable to execute the callback. User is missing required security role(s)\"\n}\n</code></pre> <p>If the policy is set to <code>IGNORE</code>, the trigger activation request will be completed successfully, but the trigger will not be activated if the user reference is missing or the user does not have the required roles.</p> <p>By using these authentication settings, you can ensure that your workflows are secure and only triggered by authorized users.</p>"},{"location":"reference/record-updated-trigger.html#accessing-event-data","title":"Accessing Event Data","text":"<p>The data from the event that activated the trigger is available through the Expression Editor. This data is structured in a key/value format, where the key names correspond to the column names of the respective database table. You can access this data to create a condition for the trigger or use it in any block that follows the trigger in the flow. By default, the name of the element containing trigger event data in the Expression Editor will use the name you assigned to the block followed by the word <code>Data</code>: </p> <p>You can modify the name of the element that references the data using the <code>Reference Trigger Data As</code> field: </p>"},{"location":"reference/record-updated-trigger.html#example-configuration","title":"Example Configuration","text":"<p>Imagine you have an <code>Orders</code> table with columns: <code>OrderID</code>, <code>Customer</code>, <code>Status</code>, and <code>TotalAmount</code>. You want to perform specific actions only when the <code>Status</code> of an order is updated to <code>Completed</code>.</p> <ol> <li> <p>Trigger Block: Set up the \"Record Updated in Database\" trigger to monitor the <code>Orders</code> table.</p> </li> <li> <p>Condition: Create a condition using the Expression Editor to check if <code>Status</code> equals <code>Completed</code>.</p> </li> <li> <p>Successor Blocks: Add actions that should follow this update, such as sending a confirmation email to the customer or updating inventory.</p> </li> </ol> <p></p> <p>The \"Record Updated in Database\" trigger is a powerful tool for automating workflows based on updates to your data. By pausing the flow until a record is updated and optionally checking conditions, you can ensure that your automated actions are both timely and relevant. This trigger helps you integrate real-time data changes into your business processes effectively.</p>"},{"location":"reference/repeat-loops.html","title":"Repeat (Loops)","text":"<p>In programming and automation, a loop is a way to repeat a set of actions multiple times. Think of it like a washing machine that repeats the same washing cycle until your clothes are clean. Loops help automate repetitive tasks, making processes more efficient and less prone to errors.</p>"},{"location":"reference/repeat-loops.html#what-is-a-loop","title":"What is a Loop?","text":"<p>A loop allows you to perform a series of steps over and over again until a specific condition is met. Each cycle in a loop is called an iteration. This is particularly useful when you need to process a large amount of data, check for updates regularly, or repeat an action until a desired result is achieved. For example, imagine you are managing an email marketing campaign. You want to send a reminder email to all customers who haven't opened your previous email. Instead of manually checking each customer and sending emails one by one, you can use a loop to automate this process:</p> <ol> <li>Check the Email Status - look at the status of each customer's email.</li> <li>Send Reminder Email - if the email is not opened, send a reminder.</li> <li>Repeat - continue this process for each customer in your list.</li> </ol> <p>This way, the loop will keep checking and sending emails until it has gone through the entire customer list.</p>"},{"location":"reference/repeat-loops.html#loops-in-flowrunner","title":"Loops in FlowRunner","text":"<p>In FlowRunner, loops are implemented using the \"Repeat\" block. This block allows you to repeat a group of actions, known as a sub-flow, as many times as needed until a specified condition is met. </p> <p></p>"},{"location":"reference/repeat-loops.html#repeast-block-properties","title":"Repeast Block Properties","text":"<p>The \"Repeat\" block has several unique qualities:</p> <ol> <li> <p>Grouping Blocks: The Repeat block acts like a container where you can place multiple blocks. These blocks form the sub-flow that will be repeated. For example, you might include blocks to check a condition, perform an action, and then wait for a specified time or a trigger event before checking again. To edit the sub-flow of the Repeat block, click the \"expand\" icon: </p> </li> <li> <p>Condition for Iterations: The Repeat block includes a condition that determines how many times the loop will run. As long as this condition is true, the Repeat block will keep running the sub-flow. Once the condition is false, the loop stops, and the flow continues to the next block outside the Repeat block.  When you click the Add a Condition button, you can add a condition the same way as in other parts where conditions are supported of FlowRunner. </p> </li> <li> <p>Current Iteration Number: FlowRunner maintains a special number called the <code>Current Iteration Number</code>, which starts at 0 for the first iteration and increments by 1 with each subsequent iteration. This number can be used within your flow to track or control the loop's progress. You can reference <code>Current Iteration Number</code> in the \"Repeat\" condition or in any block in the sub-flow. The <code>Current Iteration Number</code> element is available through the Expression Editor. </p> </li> <li> <p>Failsafe Protection Count: The Repeat block includes a special configuration property called \"Failsafe Protection Count\". This field allows you to set the maximum number of iterations before the loop stops. This feature is particularly useful during flow development to prevent infinite looping, which can result in an error due to flow execution timeout. It is recommended to set this number to the lowest value that is reasonably high enough for your needs.</p> <p></p> </li> </ol> <p>In summary, loops in FlowRunner, facilitated by the Repeat block, enable you to automate repetitive tasks effectively. This ensures your workflows are efficient, reliable, and can handle large-scale processes seamlessly.</p>"},{"location":"reference/return-result.html","title":"Return Result","text":"<p>The Return Result block defines the data returned from SubFlows and flows invoked via Call Flow. Use Return Result blocks to structure the output that subsequent workflow steps can access.</p>"},{"location":"reference/return-result.html#how-return-result-works","title":"How Return Result Works","text":"<p>Return Result is a terminal block - it marks the end of an execution branch. When a flow reaches a Return Result block, that branch stops executing and the configured data becomes available as the result.</p> <p>Return Result blocks can be used in:</p> <ul> <li>SubFlows - Define data returned to the parent flow</li> <li>Flows invoked via Call Flow - Define data returned to the calling flow</li> </ul> <p>The block functions identically in both contexts.</p>"},{"location":"reference/return-result.html#configuring-return-result","title":"Configuring Return Result","text":"<p>Configure the return structure in the Compose Result section of the block settings.</p> <p></p> <p>Each row in the Compose Result section consists of:</p> <p>Property The name of the property in the returned result object. This field supports Expression Editor, allowing dynamic property names based on workflow data. </p> <p>Value The data to return for this property. This field supports Expression Editor, enabling you to return values from previous blocks, variables, or computed expressions. Values can be static (entered directly) or dynamic (selected through Expression Editor). Click the Expression Editor icon in the field to open Expression Editor.</p> <p>Add additional properties by clicking the  icon. Remove properties by clicking the  icon next to the property row.</p>"},{"location":"reference/return-result.html#result-structure","title":"Result Structure","text":"<p>The structure of returned data depends on how many Return Result blocks exist in the flow or SubFlow.</p>"},{"location":"reference/return-result.html#single-return-result-block","title":"Single Return Result Block","text":"<p>When a flow or SubFlow has only one Return Result block, the result is an object containing the properties and values you configured.</p> <p>For example, if you configure these properties (see the screenshot above in the Configuring Return Result section):</p> <ul> <li><code>auditId</code> with value <code>\"12345\"</code></li> <li><code>timestamp</code> with value <code>\"2025-10-29T10:30:00Z\"</code></li> </ul> <p>The result structure is:</p> <pre><code>{\n  \"auditId\": \"12345\",\n  \"timestamp\": \"2025-10-29T10:30:00Z\"\n}\n</code></pre>"},{"location":"reference/return-result.html#multiple-return-result-blocks","title":"Multiple Return Result Blocks","text":"<p>When a flow or SubFlow has multiple execution branches with Return Result blocks, the result structure includes both the first-reached result and a complete list of all results:</p> <pre><code>{\n  \"executionId\": \"BDE51159-E27C-431F-97DC-FEF5D8014481\",\n  \"result\": {\n    \"blockName\": \"Audit Success\",\n    \"data\": {\n      \"auditId\": \"12345\",\n      \"status\": \"completed\"\n    }\n  },\n  \"results\": [\n    {\n      \"blockName\": \"Audit Success\",\n      \"data\": {\n        \"auditId\": \"12345\",\n        \"status\": \"completed\"\n      }\n    },\n    {\n      \"blockName\": \"Audit Failed\",\n      \"data\": {\n        \"errorCode\": \"E401\",\n        \"errorMessage\": \"Validation failed\"\n      }\n    }\n  ],\n  \"status\": \"COMPLETED\"\n}\n</code></pre> <p>The <code>result</code> property contains the data from the Return Result block that was reached first. The <code>results</code> array contains data from all Return Result blocks across all branches. The flow waits until all branches complete before returning results.</p>"},{"location":"reference/return-result.html#naming-return-result-blocks","title":"Naming Return Result Blocks","text":"<p>The <code>blockName</code> value in the result structure comes from the name you assign to the Return Result block. Use the Name field in the block settings to provide meaningful names.</p> <p>Good naming practices:</p> <ul> <li>Use names that describe what the result represents: \"Success Response\", \"Error Details\", \"Validation Result\"</li> <li>Avoid generic names like \"Return Result\" or \"Return Result (2)\"</li> <li>Use names that help identify which branch produced the result: \"Payment Approved\", \"Payment Declined\"</li> </ul> <p>Meaningful names make it easier to identify and access specific results when working with multiple Return Result blocks.</p>"},{"location":"reference/return-result.html#using-expression-editor","title":"Using Expression Editor","text":"<p>Both the Property and Value fields support Expression Editor. You can use dynamic property names and compute values using any valid Expression Editor syntax, including data from previous blocks, variables, transformations, and conditional logic.</p>"},{"location":"reference/return-result.html#data-types","title":"Data Types","text":"<p>Return Result blocks support all FlowRunner\u2122 data types. The data type is preserved when returned to the calling context.</p>"},{"location":"reference/return-result.html#accessing-returned-data","title":"Accessing Returned Data","text":"<p>Access returned data in subsequent blocks using Expression Editor. The return structure is the same whether Return Result is used in a SubFlow or a flow invoked via Call Flow - only the block name differs.</p> <p>For single Return Result:</p> <pre><code>{{SubFlowBlockName Result-&gt;propertyName}}\n</code></pre> <p>For multiple Return Results:</p> <p>Access the first-reached result:</p> <pre><code>{{BlockName Result-&gt;data.propertyName}}\n</code></pre> <p>Access specific branches from the results array:</p> <pre><code>{{BlockName Result-&gt;[0].data.propertyName}}\n{{BlockName Result-&gt;[1].data.propertyName}}\n</code></pre> <p>Access execution metadata:</p> <pre><code>{{BlockName Result-&gt;executionId}}\n{{lockName Result-&gt;status}}\n</code></pre> <pre><code>{{BlockName Result-&gt;propertyName}}\n</code></pre> <p>Replace <code>BlockName</code> with either the SubFlow block name or the Call Flow block name depending on which invoked the flow containing the Return Result block.</p> <p>Best Practices</p> <p>Use Meaningful Property Names Choose property names that clearly describe the data they contain. Use <code>customerEmail</code> instead of <code>email</code>, or <code>orderTotal</code> instead of <code>total</code> when the context matters.</p> <p>Return Only Necessary Data Include only the data that calling flows or blocks actually need. Returning excessive data makes results harder to work with and can impact performance.</p> <p>Consistent Structure Across Branches When using multiple Return Result blocks, maintain consistent property names across branches where possible. This makes it easier to process results regardless of which branch executed.</p> <p>Document Complex Results Add comments in your flow to document the structure of returned data, especially when returning complex objects or arrays. Future users will appreciate understanding what each property represents.</p> <p>Test Return Result Configuration Use Test Mode to verify that Return Result blocks return the expected data structure and values. Check both single-path and multi-branch scenarios.</p>"},{"location":"reference/save-record-action.html","title":"Save Record in Database","text":"<p>The \"Save Record in Database\" action block in FlowRunner\u2122 is designed to help you interact with your Backendless database by creating new records or updating existing ones. This block supports three modes of operation: creating a new record, updating a specific record, and updating a collection of records that match a query. </p> <p>If you are not familiar with the Backendless Database, it is a cloud-based database service that allows you to store, retrieve, and manage data for your application. It provides a range of powerful features for data management, including real-time data synchronization, advanced querying, and user management.</p> <p>The block has three modes to support its operations:</p>"},{"location":"reference/save-record-action.html#create-a-new-record","title":"Create a New Record","text":"<p>In this mode, you can create a new record in a specified table. Here's how to configure it:</p> <ul> <li>Specify the Table: Select the table where the new record will be created from a drop-down list of available tables. If the list of tables changes, you can refresh it by clicking the \"refresh\" icon.</li> <li>Set Column Values: Use the \"Set Column Values\" form to assign values to the columns in the table. Each column can be set to a specific value as needed.</li> </ul> <p>The result of this action is the created record, which is returned in a key/value structure format.</p>"},{"location":"reference/save-record-action.html#update-record-from-flow","title":"Update Record from Flow","text":"<p>This mode allows you to update a specific record using the result of an action, trigger, or transform operation. Here's how to configure it:</p> <ul> <li> <p>Select the Table: Choose the table where the record exists.        </p> </li> <li> <p>Select a Record to Update: Choose a result from any of the previous blocks (action, trigger, transform operation, or variable) that you want to update.</p> <p>Note</p> <p>The Backendless databaase uses a special column called <code>objectId</code> which uniquely identifies a record in a table. Make sure the data element you select has the <code>objectId</code> property/key with a valid value identifying a record in the selected table.</p> </li> <li> <p>Perform Changes: Configure the Perform Changes form by specifying Property/Value pairs. The \"Property\" is a column from the selected table, and the \"Value\" is what will be updated in the record.</p> </li> </ul> <p>The result of this action is the updated record, which is returned in a key/value structure format.</p>"},{"location":"reference/save-record-action.html#update-record-with-a-query","title":"Update Record with a Query","text":"<p>In this mode, you can update multiple records that match a specific query. Here's how to configure it:</p> <ul> <li>Define the Query: Use the where clause syntax to define the query that identifies which records to update.</li> <li>Select the Table: Choose the table where the query will run.</li> <li>Set Changes: Define the changes to apply as a collection of Property/Value pairs. Each \"Property\" is a column from the selected table, and the \"Value\" is what will be set for the corresponding column in the records identified by the query.</li> </ul> <p>The changes will apply new values to the specified columns for all records that match the query.</p>"},{"location":"reference/save-record-action.html#using-the-expression-editor","title":"Using the Expression Editor","text":"<p>All fields in the \"Save Record in Database\" block, including query criteria, and column values are integrated with the Expression Editor. This tool makes it easy to link data from other blocks in your flow, ensuring a seamless flow of information and enabling dynamic data manipulation based on the results of previous actions.</p>"},{"location":"reference/save-record-action.html#example-usage","title":"Example Usage","text":"<p>Imagine you need to update the status of multiple orders in your database to \"shipped\" when a shipping confirmation is received. You could configure the \"Save Record in Database\" block as follows:</p> <ol> <li>Create a New Record: If you receive a new order, you can add it to your database by specifying the order details in the \"Set Column Values\" form.</li> <li>Update Record from Flow: When a specific order is updated with shipping information, select the order record from a previous block and update its status to \"shipped\".</li> <li>Update Record with a Query: Use a query to find all orders that have a status of \"processing\" and update their status to \"shipped\" once they are confirmed for shipping.</li> </ol> <p>By configuring the \"Save Record in Database\" block in these ways, you can efficiently manage and update your database records, ensuring that your application data remains accurate and up-to-date.</p>"},{"location":"reference/send-email-action.html","title":"Send Email","text":"<p>The \"Send Email\" action block in FlowRunner\u2122 is a versatile tool designed to automate the process of sending emails. This block can be configured to send emails using a predefined template and can target specific recipients either explicitly or based on query from your Backendless database.</p> <p>Note</p> <p>Sending customized emails requires that you configure an email provider in Backendless. You can choose from a variety of pre-configured options (you will need to create an account with a provider) or configure a custom SMTP server provider.</p>"},{"location":"reference/send-email-action.html#send-email-properties","title":"Send Email Properties","text":"<p>The Send Email action block includes the following configuration properties:</p> <ol> <li> <p>Email Template: A template to use. The template defines the static content and visual presentation of the email. Backendless templates can include substitution variables and \"smart text\" with dynamic values injected from the database.</p> </li> <li> <p>Send To: Zero or more email addresses where the email will be sent.</p> </li> <li> <p>CC: Zero or more email addresses for \"Carbon Copy (CC)\" email delivery.</p> </li> <li> <p>BCC: Zero or more email addresses for \"Blind Carbon Copy (BCC)\" email delivery.</p> </li> <li> <p>Criteria: A query in the format of the Backendless where clause against the Users database table. FlowRunner\u2122 will use the email addresses from the records identified by the query.</p> </li> <li> <p>Attachments: Zero or more references to files to attach to the email message.</p> </li> </ol> <p></p> <p>At least one of the fields must be set. Otherwise, you will see the following block input validation errors:</p> <p></p>"},{"location":"reference/send-email-action.html#email-templates","title":"Email Templates","text":"<p>The \"Send Email\" block uses a selected email template to define the content of the email body. This template can be in plain text or HTML format, allowing for visually appealing and well-structured emails. Templates can also include template variables and smart substitution tags to dynamically insert data into the email content. For more information about Backendless Templates, see the Email Templates section of the Backendless Developer Guide. To select a template, use the Email Template drop-down list. If you need to quickly navigate to the Email Template Management interface, use the icon on the right. The refresh icon will update the list of available templates.</p> <p></p> <p>If the selected template has any dynamic text variables, they will appear under the template selection drop-down list. You can assign values for the variables using the Expression Editor. This allows for injecting any data available in the flow into the sent emails. Below is an example of an Email Template with a dynamic text variable called <code>{name}</code>:</p> <p></p> <p>When the template is selected in a \"Send Email\" block, the <code>name</code> variable can be configured with data from the flow:</p> <p></p>"},{"location":"reference/send-email-action.html#specifying-recipients","title":"Specifying Recipients","text":"<p>You have several options for specifying recipients for your email:</p> <ul> <li>Explicit Recipients: You can manually enter email addresses in the \"Send To\", \"CC\", and \"BCC\" fields. This is useful when you know the specific email addresses of your recipients.</li> <li>Implicit Recipients via Criteria: You can also set a query in the \"Criteria\" field, which FlowRunner\u2122 executes against the \"Users\" data table in Backendless. The email will be sent to the email addresses from the database records that match the criteria query. This allows you to target recipients dynamically based on specific conditions or attributes in your database.</li> </ul>"},{"location":"reference/send-email-action.html#adding-attachments","title":"Adding Attachments","text":"<p>The \"Send Email\" block allows you to add one or more file attachments to your email. You can specify these attachments using the Attachments\"** property. This feature is helpful for including documents, images, or other files in your email communications.</p>"},{"location":"reference/send-email-action.html#using-the-expression-editor","title":"Using the Expression Editor","text":"<p>All fields in the \"Send Email\" block, including the Send To, CC, BCC, Criteria, and Attachments fields, are integrated with the Expression Editor. The Expression Editor makes it easy to link data from other blocks in your flow to these fields. This ensures a seamless flow of information, allowing you to dynamically generate recipient lists, email content, and attachments based on the data processed within your flow.</p>"},{"location":"reference/send-email-action.html#example","title":"Example","text":"<p>Imagine you need to send a monthly newsletter to all users who have subscribed to your service. You could configure the \"Send Email\" block as follows:</p> <ol> <li>Template Selection: Choose an HTML template for your newsletter, including variables for the user's name and subscription details.</li> <li>Criteria: Set a query in the \"Criteria\" field to select all users who have subscribed to your newsletter.</li> <li>Attachments: Attach a monthly report or promotional material to the email using the \"Attachments\" property.</li> <li>Configure Schedule: Set up a schedule to run your flow once a month.</li> </ol> <p>By configuring the \"Send Email\" block in this way, you can automate the process of sending personalized newsletters to your subscribers, ensuring that each email is tailored to the recipient's details and preferences.</p> <p>In summary, the \"Send Email\" action block is a powerful component in FlowRunner\u2122 that allows you to automate email sending with rich content, dynamic recipient lists, and attachments. Its integration with the Expression Editor ensures that your email communications are data-driven and seamlessly connected to your workflow.</p>"},{"location":"reference/set-variables.html","title":"Set Variables","text":"<p>Variables in FlowRunner\u2122 are a method for storing and accessing data in your flow\u2019s actions, transformers, and conditions. Think of each variable as a drawer with a label. You can store any type of data in these drawers, such as string literals, numbers, dates, boolean values, data collections, or key/value structures. By naming these drawers, you can easily recall and use the data whenever needed.</p> <p>To further organize your variables, FlowRunner\u2122 supports a concept called Data Buckets. A data bucket is like a collection of drawers, grouped under a single name. This helps in logically organizing and managing your variables. For instance, if you have variables containing configuration parameters that apply to the entire flow, you might place them in a data bucket named <code>Global Config Params</code>.</p>"},{"location":"reference/set-variables.html#set-variables-block","title":"Set Variables Block","text":"<p>To set or change a variable, you use the <code>Set Variables</code> block.</p> <p></p> <p>Before you assign any variable values, make sure to specify a data bucket where the changes will occur. In the screenshot below the selected data bucket is called <code>My Flow Vars</code>:</p> <p></p> <p>It is easy to create new data buckets - simply type in a name for your data bucket and select the option below to create it:</p> <p></p>"},{"location":"reference/set-variables.html#setting-and-changing-variables","title":"Setting and Changing Variables","text":"<p>The process involves identifying a variable name and assigning a value to it, both done using the Expression Editor. This method allows the variable name and value to be dynamically calculated, providing great flexibility. </p> <p>Consider the following example - it creates a variable called <code>has phone number</code>. The value assigned to the variable is dynamic. Using the Expression Editor, you can create an expression that sets the value of <code>has phone number</code> based on data available within the current flow.</p> <p></p> <p>When you build an expression to calculate a value for your variable, you can reference other variables. This means that the new variable\u2019s value can be composite, drawing from any data available in the current <code>Set Variables</code> block. Below is a screenshot of the Expression Editor showing how the expression for the <code>has phone number</code> variable is composed:</p> <p></p>"},{"location":"reference/set-variables.html#accessing-variables","title":"Accessing Variables","text":"<p>To access your variables, you use the Expression Editor. This tool includes a dedicated section that lists all variables available for the current block. For example, in the screenshot below, you can see there is one variable in the <code>My Flow Vars</code> data bucket, named <code>has phone number</code>.</p> <p></p> <p>By understanding how to effectively set, change, and access variables, you can build more dynamic and responsive automation flows. Variables help you manage data efficiently, ensuring that your workflows are both flexible and powerful.</p>"},{"location":"reference/subflow.html","title":"SubFlows","text":"<p>SubFlows are reusable workflow sequences that you define once and use multiple times within the same flow. Think of a SubFlow as a packaged set of steps you can place multiple times throughout your workflow.</p>"},{"location":"reference/subflow.html#example-audit-tracking","title":"Example: Audit Tracking","text":"<p>Consider a workflow that processes financial transactions and must create audit records at multiple steps for compliance. Each audit record requires the same sequence - check configuration settings to determine what to log, format the audit data according to organizational standards, add a timestamp, and save the record to the audit database. Instead of rebuilding this sequence at each audit point, create a SubFlow called \"Create Audit Record\" and place it at different points in your transaction workflow:</p> <ul> <li>After transaction validation (audit the validation result)</li> <li>After payment authorization (audit the authorization response)</li> <li>After transaction completion (audit the final transaction state)</li> </ul> <p>Each time the SubFlow runs within the transaction workflow, it executes the same audit logic but receives different input values for the event type, transaction ID, and event details.</p>"},{"location":"reference/subflow.html#why-use-subflows","title":"Why Use SubFlows","text":"<p>SubFlows help you:</p> <ul> <li>Avoid duplicating the same workflow logic in multiple places</li> <li>Simplify complex flows by breaking them into manageable pieces</li> <li>Update logic in one place and have changes apply everywhere the SubFlow is used</li> <li>Make workflows easier to read and maintain</li> </ul>"},{"location":"reference/subflow.html#subflows-vs-call-flow-action","title":"SubFlows vs. Call Flow Action","text":"<p>FlowRunner\u2122 offers two ways to reuse workflow logic:</p> <p>SubFlows are workflow sequences that exist only within the current flow. Use SubFlows when you need to repeat a specific sequence multiple times in the same workflow. SubFlows cannot be called from other flows.</p> <p>Call Flow action invokes a complete, separate flow from within your current flow. Use the Call Flow action when you need to reuse an entire flow across multiple different flows.</p>"},{"location":"reference/subflow.html#creating-a-subflow","title":"Creating a SubFlow","text":"<p>Locate the Create SubFlow button in the Block List panel. This button cannot be dragged to the canvas - click it to open the New SubFlow dialog.</p> <p></p> <p>The New SubFlow dialog requests:</p> <p>SubFlow Name Enter a descriptive name that indicates what the SubFlow does. This name appears in the Block List panel and helps you identify the SubFlow when building your workflow.</p> <p>Input Parameter Names Define the data the SubFlow needs to perform its task. For example, a \"Send Order Confirmation\" SubFlow might need parameters like <code>customerEmail</code>, <code>orderNumber</code>, and <code>orderTotal</code>. Add additional parameters by clicking the plus icon.</p> <p></p> <p>Click CREATE SUBFLOW to create the SubFlow. The new SubFlow appears in the SUBFLOWS group in the Block List panel.</p> <p></p>"},{"location":"reference/subflow.html#using-subflows-in-your-workflow","title":"Using SubFlows in Your Workflow","text":"<p>Drag the SubFlow from the Block List panel to the Flow Editor canvas. The SubFlow functions like any other action block - connect it to predecessor blocks and add successor blocks after it.</p> <p>When you select a SubFlow block on the canvas, the settings panel displays input fields for any parameters you defined. Provide values for these parameters using Expression Editor for dynamic values or enter static values directly.</p> <p>Parameter configuration for SubFlows follows the same rules as other FlowRunner\u2122 blocks. You can reference results from previous blocks, use variables, or apply data transformations through Expression Editor.</p> <p></p>"},{"location":"reference/subflow.html#defining-subflow-logic","title":"Defining SubFlow Logic","text":"<p>When you first create a SubFlow, it contains no logic. You must define what the SubFlow does by adding blocks inside it.</p> <p>To edit a SubFlow, click the expand icon in the lower right corner of the SubFlow block on the canvas. This navigates into the SubFlow editor.</p> <p></p> <p>When editing a SubFlow, the editor title bar displays the SubFlow name, indicating you are working inside that SubFlow. Build the SubFlow's logic the same way you build regular flows - drag blocks from the Block List, configure parameters, and connect blocks to define the execution sequence.</p> <p>Important limitation: SubFlows cannot contain other SubFlows. You can only use standard actions, triggers, conditions, and other flow control blocks inside a SubFlow.</p> <p>To return to the main flow, click the flow name in the breadcrumb navigation or use the back button in the editor.</p>"},{"location":"reference/subflow.html#accessing-input-parameters","title":"Accessing Input Parameters","text":"<p>Inside a SubFlow, access input parameters through the Expression Editor using the Input Data pill. The Input Data pill provides a dropdown list of all declared input parameters for the SubFlow.</p> <p>To use an input parameter:</p> <ol> <li>Open Expression Editor for any parameter field in a block inside the SubFlow</li> <li>Locate the Input Data pill in the Expression Editor</li> <li>Click the dropdown on the Input Data pill to see available parameters</li> <li>Drag the Input Data pill into your expression</li> <li>Select the specific parameter from the dropdown</li> </ol> <p></p>"},{"location":"reference/subflow.html#subflow-reusability","title":"SubFlow Reusability","text":"<p>You can place the same SubFlow multiple times in your workflow. Each instance executes the same logic but can receive different input parameters.</p> <p>For example, your order processing flow might use \"Send Order Confirmation\" in multiple places:</p> <ul> <li>After initial order placement (with customer order details)</li> <li>After successful payment processing (with payment confirmation details)</li> <li>After shipping dispatch (with tracking information)</li> </ul> <p>Each instance receives different input values but executes the same underlying logic.</p>"},{"location":"reference/subflow.html#updating-subflow-logic","title":"Updating SubFlow Logic","text":"<p>When you modify a SubFlow's internal logic, all instances of that SubFlow in your workflow update automatically. If you have three instances of \"Send Order Confirmation\" and you change how the confirmation email is formatted, all three instances use the updated format immediately.</p> <p>This ensures consistency across your workflow and eliminates the need to update multiple copies of the same logic.</p>"},{"location":"reference/subflow.html#subflow-results","title":"SubFlow Results","text":"<p>SubFlows return results that subsequent blocks in your workflow can use. The result structure depends on whether the SubFlow uses Return Result blocks and how many execution branches exist.</p>"},{"location":"reference/subflow.html#single-return-result-block","title":"Single Return Result Block","text":"<p>When a SubFlow has only one Return Result block, the result is an object containing the properties and values defined in that Return Result block.</p> <p>For example, if your Return Result block defines <code>auditId</code> and <code>timestamp</code>:</p> <p></p> <p>the SubFlow result contains those properties directly: <pre><code>{\n  \"auditId\": \"12345\",\n  \"timestamp\": \"2025-10-29T10:30:00Z\"\n}\n</code></pre></p>"},{"location":"reference/subflow.html#multiple-return-result-blocks","title":"Multiple Return Result Blocks","text":"<p>When a SubFlow has multiple Return Result blocks (meaning multiple execution branches), the result structure includes the result of the Return Result block that was reached first as well as a list of all Return Result objects. For example, suppose a SubFlow has two Return Result blocks, one shown above and the other shown in the screenshot below:</p> <p></p> <p>The result structure of the sublfow would look as shown below:</p> <pre><code>{\n  \"executionId\": \"BDE51159-E27C-431F-97DC-FEF5D8014481\",\n  \"result\": {\n    \"blockName\": \"Return Audit Result\",\n    \"data\": {\n      \"auditId\": \"12345\",\n      \"timestamp\": \"2025-10-29T10:30:00Z\"\n    }\n  },\n  \"results\": [\n    {\n      \"blockName\": \"Return Audit Result\",\n      \"data\": {\n         \"auditId\": \"12345\",\n          \"timestamp\": \"2025-10-29T10:30:00Z\"\n      }\n    },\n    {\n      \"blockName\": \"Return Log Status\",\n      \"data\": {\n        \"logCreated\": true\n      }\n    }\n  ],\n  \"status\": \"COMPLETED\"\n}\n</code></pre> <p>The <code>blockName</code> value is the actual name assigned to each Return Result block. It is recommended to assign meaningful names to Return Result blocks that represent the result they provide. For example, name blocks \"Audit Success\" or \"Audit Failed\" rather than using default names.</p>"},{"location":"reference/subflow.html#without-return-result-blocks","title":"Without Return Result Blocks","text":"<p>If a SubFlow does not use Return Result blocks, the result object will not include any data from the SubFlow.</p>"},{"location":"reference/subflow.html#accessing-subflow-results","title":"Accessing SubFlow Results","text":"<p>Reference SubFlow results in subsequent blocks using Expression Editor.</p> <p>For single Return Result: <pre><code>{{SubFlowBlockName Result-&gt;propertyName}}\n</code></pre></p> <p>For multiple Return Results:</p> <p>Access the <code>result</code> property for the first branch: <pre><code>{{SubFlowBlockName Result-&gt;data.propertyName}}\n</code></pre></p> <p>Access specific branches from the <code>results</code> array: <pre><code>{{SubFlowBlockName Result-&gt;[0].data.propertyName}}\n{{SubFlowBlockName Result-&gt;[1].data.propertyName}}\n</code></pre></p> <p>Access execution metadata: <pre><code>{{SubFlowBlockName Result-&gt;executionId}}\n{{SubFlowBlockName Result-&gt;status}}\n</code></pre></p> <p>For detailed information about configuring Return Result blocks, see the Return Result documentation.</p>"},{"location":"reference/subflow.html#when-to-use-subflows","title":"When to Use SubFlows","text":"<p>Use SubFlows when:</p> <ul> <li>You repeat the same sequence of actions multiple times in a workflow</li> <li>You want to organize complex workflows into logical sections</li> <li>Changes to repeated logic should apply consistently everywhere</li> <li>The reusable logic is specific to the current workflow</li> </ul> <p>Use the Call Flow action when:</p> <ul> <li>You need to reuse complete workflows across multiple different flows</li> <li>The logic represents a standalone process</li> <li>Multiple teams or projects need access to the same workflow</li> </ul> <p>Best Practices</p> <p>Naming SubFlows Use descriptive names that explain what the SubFlow does. Good names include \"Validate Customer Data\", \"Calculate Shipping Cost\", or \"Send Notification\". Avoid generic names like \"SubFlow1\" or \"Process Data\".</p> <p>Parameter Design Define only the parameters the SubFlow actually needs. Too many parameters make SubFlows harder to configure and maintain. If a SubFlow needs many parameters, consider whether it should be broken into smaller SubFlows.</p> <p>Single Responsibility Each SubFlow should perform one clear task. SubFlows that try to do too many things become difficult to reuse and maintain. If a SubFlow becomes complex, consider splitting it into multiple smaller SubFlows.</p> <p>Documentation Add comments or notes inside SubFlows to explain complex logic. Future users (including yourself) will appreciate clear explanations of what the SubFlow does and why certain steps are necessary.</p> <p>Testing Test SubFlows thoroughly before using them in multiple places in your workflow. Bugs in a SubFlow affect every instance where it appears. Use Test Mode to validate SubFlow behavior with different input parameters.</p>"},{"location":"reference/synchronize.html","title":"Synchronize Block","text":"<p>The Synchronize block is an advanced FlowRunner\u2122 component that merges parallel execution branches back into a single execution path. This block is essential for complex workflows where you need to split processing into parallel branches and then consolidate the results or continue with unified execution after parallel operations complete.</p> <p>Understanding the Synchronize block requires knowledge of how FlowRunner\u2122 handles branched execution. When a single block connects to multiple successor blocks, FlowRunner\u2122 automatically creates separate execution branches that run independently and in parallel. The Synchronize block provides a controlled way to merge these parallel branches back together.</p> <p>Common use cases include consolidating results from parallel data processing operations, ensuring all validation checks complete before proceeding, coordinating multiple API calls that must all finish before continuing, merging parallel approval workflows, and implementing join patterns in complex business process flows.</p>"},{"location":"reference/synchronize.html#understanding-parallel-execution-in-flowrunner","title":"Understanding Parallel Execution in FlowRunner","text":"<p>FlowRunner\u2122 automatically creates parallel execution branches whenever a block has multiple successors. Each branch runs independently, which can lead to downstream blocks being executed multiple times if they receive input from multiple parallel branches.</p>"},{"location":"reference/synchronize.html#basic-parallel-execution-example","title":"Basic Parallel Execution Example","text":"<p>Consider this flow structure:</p> <pre><code>flowchart TD\n    A[Trigger A] --&gt; B[Action B]\n    A[Trigger A] --&gt; C[Action C]\n    B --&gt; D[Action D]\n    C --&gt; D[Action D]</code></pre> <p>In this scenario:</p> <ul> <li>Trigger A creates two parallel branches leading to Action B and Action C</li> <li>Both Action B and Action C execute simultaneously in separate branches</li> <li>Action D executes twice - once for each incoming branch</li> <li>Each execution of Action D operates independently with its own context and data</li> </ul> <p>This parallel execution model provides powerful capabilities for concurrent processing, but sometimes you need to merge branches back into a single execution path.</p>"},{"location":"reference/synchronize.html#synchronized-execution-with-synchronize-block","title":"Synchronized Execution with Synchronize Block","text":"<p>The Synchronize block solves the multiple execution challenge by waiting for all incoming branches to arrive before allowing a single consolidated execution to continue:</p> <pre><code>flowchart TD\n    A[Trigger A] --&gt; B[Action B]\n    A[Trigger A] --&gt; C[Action C]\n    B --&gt; S[Synchronize]\n    C --&gt; S[Synchronize]\n    S --&gt; D[Action D]\n\n    style S fill:#f9f,stroke:#333,stroke-width:2px</code></pre> <p>With the Synchronize block:</p> <ul> <li>Action B and Action C still execute in parallel</li> <li>The Synchronize block waits for both branches to complete</li> <li>Action D executes only once after synchronization completes</li> <li>The flow continues with a single execution branch containing consolidated context</li> </ul>"},{"location":"reference/synchronize.html#block-configuration","title":"Block Configuration","text":"<p>The Synchronize block provides flexible timing control to accommodate different synchronization scenarios.</p> <p></p>"},{"location":"reference/synchronize.html#max-waiting-time-configuration","title":"Max Waiting Time Configuration","text":"<p>The Max Waiting Time parameter determines how long the Synchronize block will wait for all incoming branches to arrive. This parameter has two configuration modes to accommodate different timing needs.</p>"},{"location":"reference/synchronize.html#static-time-configuration","title":"Static Time Configuration","text":"<p>In static mode, you specify a fixed duration using individual time units (see the screenshot above).</p> <p>Time Unit Options:</p> <ul> <li>Days: For long-running processes or batch operations</li> <li>Hours: For extended processing workflows</li> <li>Minutes: For standard synchronization scenarios</li> <li>Seconds: For quick parallel operations</li> </ul>"},{"location":"reference/synchronize.html#dynamic-time-configuration-expression-editor","title":"Dynamic Time Configuration (Expression Editor)","text":"<p>In dynamic mode, you can specify the wait time in seconds using the Expression Editor, allowing for variable timing based on workflow context:</p> <p></p> <p>Dynamic Timing Examples</p> <ul> <li><code>${ProcessingTime.estimated}</code>: Use calculated processing time estimates</li> <li><code>${Configuration.timeoutSeconds}</code>: Reference configuration variables</li> <li><code>${APIResponse.expectedDuration}</code>: Base timing on external service estimates</li> <li><code>300</code>: Static 5-minute timeout using expression syntax</li> </ul>"},{"location":"reference/synchronize.html#timeout-behavior","title":"Timeout Behavior","text":"<p>When the Max Waiting Time expires before all branches arrive:</p> <p>Timeout Handling</p> <ul> <li>The Synchronize block stops waiting and continues execution</li> <li>Only branches that arrived before timeout are included in the synchronized context</li> <li>Late-arriving branches are effectively dropped from the execution flow</li> <li>Consider error handling downstream to detect incomplete synchronization</li> </ul>"},{"location":"reference/synchronize.html#implementation-patterns","title":"Implementation Patterns","text":""},{"location":"reference/synchronize.html#parallel-data-processing","title":"Parallel Data Processing","text":"<p>Use the Synchronize block to merge results from parallel data processing operations:</p> <pre><code>flowchart TD\n    A[Data Source] --&gt; B[Process Batch 1]\n    A --&gt; C[Process Batch 2]\n    A --&gt; D[Process Batch 3]\n    B --&gt; E[Synchronize Results]\n    C --&gt; E\n    D --&gt; E\n    E --&gt; F[Consolidate Final Results]</code></pre> <p>Alternative Approach: Actions Group</p> <p>For simpler parallel execution scenarios, consider using an Actions Group block with transition mode set to \"On Completion\". This ensures the outgoing transition happens only when all enclosed actions complete their execution, providing a more streamlined alternative to explicit Synchronize blocks.</p>"},{"location":"reference/synchronize.html#multiple-api-validation","title":"Multiple API Validation","text":"<p>Coordinate multiple validation API calls before proceeding:</p> <pre><code>flowchart TD\n    A[User Input] --&gt; B[Validate Email]\n    A --&gt; C[Check User Permissions]\n    A --&gt; D[Verify Account Status]\n    B --&gt; E[Synchronize Validations]\n    C --&gt; E\n    D --&gt; E\n    E --&gt; F[Process Valid User]</code></pre> <p>Alternative Approach: Action Group</p> <p>Multiple validation calls can also be handled using an Action Group with \"On Completion\" transition mode, which automatically waits for all validations to finish before proceeding.</p>"},{"location":"reference/synchronize.html#best-practices","title":"Best Practices","text":"<p>Synchronization Design Strategy</p> <ul> <li>Plan Branch Timing: Consider the expected duration of each parallel branch</li> <li>Set Appropriate Timeouts: Balance between waiting for slow branches and maintaining flow responsiveness</li> <li>Handle Incomplete Synchronization: Design downstream logic to handle cases where not all branches complete</li> <li>Monitor Performance: Track synchronization patterns to optimize timing parameters</li> </ul> <p>Common Pitfalls</p> <ul> <li>Overly Short Timeouts: May cause premature synchronization with missing data</li> <li>No Timeout Strategy: Indefinite waiting can hang workflows</li> <li>Complex Branch Dependencies: Avoid circular dependencies in parallel branches</li> <li>Resource Contention: Be mindful of parallel branches competing for limited resources</li> </ul> <p>Performance Considerations</p> <ul> <li>Memory Usage: Synchronize blocks hold branch data until synchronization completes</li> <li>Execution Time: Total flow time includes the longest parallel branch plus synchronization time</li> <li>Resource Planning: Account for peak resource usage during parallel execution phases</li> <li>Error Propagation: Design error handling for both individual branches and synchronization failures</li> </ul>"},{"location":"reference/transformer.html","title":"Transform Data","text":"<p>The \"Transform Data\" block is a versatile tool that offers various data transformation operations. Each operation has unique behavior based on how it transforms data. These operations are grouped according to the data type they work with. Below are tables detailing each operation within its respective category.</p>"},{"location":"reference/transformer.html#logic-operations","title":"Logic Operations","text":"<p>Logic operations in FlowRunner\u2122 provide essential tools for making decisions within your flows. These operations allow you to evaluate conditions in preparation for more advanced flow control decisions based on specific criteria. By incorporating logic operations, you can create more dynamic and responsive workflows that adapt to various situations.</p> <p>There are four main logic operations in FlowRunner\u2122:</p> <ol> <li>If: This operation checks a condition and returns one of two values based on whether the condition is true or false.</li> <li>Equals: This operation compares two values to determine if they are equal.</li> <li>Switch: This operation evaluates a value against a list of cases and returns a corresponding result for the first matching case.</li> <li>Is Empty: This operation checks if a value is empty and returns one of two specified values based on the result.</li> </ol> <p>These logic operations work at a fundamental level, helping you to implement basic decision-making processes within your flows. They are versatile and can be used in a wide range of scenarios to ensure your automation behaves as expected under different conditions.</p> <p>The details of each operation are described below.</p> Operation Description Arguments  If Returns \"Yes\" if the condition is satisfied, otherwise returns \"No\".  - Condition  - Yes  - No  Equal Compares two values to check if they are equal. Returns <code>true</code> if the values are equal or <code>false</code> otherwise. - Compare value  - With  Switch Evaluates a value against a list and returns the result corresponding to the first matching value.  - Value or Expression to Evaluate  - Pairs of \"For the Case Of\" and \"Return Value\"  - Default  If Empty Returns the first value if the input is not empty, otherwise returns the second value.  - Evaluate Value or Expression  - When Empty, Return"},{"location":"reference/transformer.html#object-operations","title":"Object Operations","text":"<p>In programming, an \"object\" is a way to organize and store data. Think of an object as a collection of related information, much like a real-world object that has various characteristics. These characteristics are stored as key/value pairs within the object.</p> <ul> <li>Key: This is the name of a property or attribute in the object. It serves as a label to identify the data.</li> <li>Value: This is the data or information associated with the key. It can be any type of data, such as a number, text, or even another object.</li> </ul> <p>Note</p> <p>Elsewhere in this guide we use the term \"key/value structure\" to refer to objects.</p> <p>Each key in an object maps to a value, and this mapping is unique. This means you can easily retrieve the value by using its corresponding key.</p> <p>Let's look at a simple example of an object representing a person. Here are the keys and values in a tabular format:</p> Key Value <code>firstName</code> James <code>lastName</code> Bond <code>age</code> 45 <code>occupation</code> Spy <code>email</code> jamesbond@mi6.co.uk <p>In this example, the object has keys like <code>firstName</code>,<code>lastName</code>, <code>age</code>, <code>occupation</code> and <code>email</code>. Each key is associated with a specific value. To retrieve values from an object, you use the key names. For instance, if you want to find out the person's first name, you look up the value associated with the <code>firstName</code> key.</p> <p>Here's how you can retrieve the values using their keys:</p> <ul> <li>To get the first name: <code>firstName</code> -&gt; James</li> <li>To get the last name: <code>lastName</code> -&gt; Bond</li> <li>To get the age: <code>age</code> -&gt; 45</li> <li>To get the occupation: <code>occupation</code> -&gt; Spy</li> <li>To get the email: <code>email</code> -&gt; jamesbond@mi6.co.uk</li> </ul> <p>By using the key names, you can easily access and manipulate the data within the object. This makes objects a powerful and flexible way to handle complex data in programming. The operations listed below work with objects. You can retrieve a value associated with a specific key, or \"transform\" an object by omitting or selecting specific properties.</p> Operation Description Arguments  Get Retrieves the value of a specified property from an object or array. Use dot notation for nested key/value structures (objects).  - Object  - Property Name  Omit Omits specified keys from an object and returns the remaining properties.  - Object  - Property Name(s)  Pick Picks only the specified keys from an object.  - Object  - Property Name(s)"},{"location":"reference/transformer.html#arraylist-operations","title":"Array/List Operations","text":"<p>In programming, an \"array\" is a way to organize and store a collection of items. Think of an array as a list where you can keep multiple pieces of related information in one place. Each item in an array has a specific position, known as an index, which helps you access and manage the items easily. Arrays can contain data of different types, such as numbers, strings, objects or even other arrays.</p> <p>Let's look at a simple example of an array representing a list of fruits:</p> <p><code>\"Apple\"</code>, <code>\"Banana\"</code>, <code>\"Cherry\"</code>, <code>\"Date\"</code>, <code>\"Elderberry\"</code></p> <p>In this array, each fruit is an item, and each item has an index:</p> Index Item 0 Apple 1 Banana 2 Cherry 3 Date 4 Elderberry <p>Here are some common operations you can perform on arrays:</p> <ul> <li>Get Length - The length of an array is the number of items it contains. You can easily find out how many items are in an array by checking its length.</li> <li>Get First Item - You can retrieve the first item in an array by accessing the item at index 0.</li> <li>Sort - Sorting an array means arranging its items in a specific order, such as alphabetically or numerically.</li> </ul> <p>Let's see these operations in action with our fruit array:</p> Operation Result Get Length 5 Get First Item Apple Sort Apple, Banana, Cherry, Date, Elderberry <p>Arrays are a powerful way to manage collections of related items in programming. Below is a list of array operations supported by FlowRunner\u2122. By using these operations you can efficiently organize and manipulate your data.</p> Operation Description Arguments  Create Array Creates an array from the provided elements. - Element  Convert List To String Concatenates all items of an array into a string, using the specified separator between each item. - Array  - Separator  Get List Length Returns the number of items in an array. - Array  Merge Lists Merges two or more arrays into one. - Array  - Array  If List Contains Checks if an array contains a specified value. - Array  - Value  Remove From List Removes specified values from an array. Effective only on arrays of primitive text or numbers. - Array  - Value  Add To List Adds specified values to an array and returns the updated array. - Array  - Value  Get First List Item Returns the first element of an array. - Array  Get Last List Item Returns the last element of an array. - Array  Reverse List Reverses the order of elements in an array and returns the reversed array. - Array  Shuffle List Randomly reorders the elements of an array. - Array  Flatten List Concatenates all sub-array elements into a single array. The \"key\" argument specifies which properties to flatten. - Array  - Key  Distinct List Removes duplicate values from an array. Use the \"key\" argument to specify properties in complex objects. - Array  - Key  Slice List Returns a new array containing only selected items. The \"start\" position is inclusive, \"end\" is exclusive. The first element has the position of <code>0</code>. - Array  - Start  - End  Sort List Sorts the values of an array. Use the \"key\" argument to specify properties in complex objects. - Array  - Order  - Key  Object Keys To List Returns an array containing the properties of a given object. - Object"},{"location":"reference/transformer.html#date-operations","title":"Date Operations","text":"Operation Description Arguments  Now Returns the current Unix timestamp in milliseconds since January 1, 1970 GMT. No arguments  Set Seconds Sets the seconds in a date to a specified value. Accepts numbers from 0 to 59. - Date/Time  - Seconds (0-59)  Get Seconds Returns the seconds from a specified date. - Date/Time  Add Seconds Adds a specified number of seconds to a date. To subtract, enter a negative number. - Date/Time  - Seconds (0-59)  Set Minutes Sets the minutes in a date to a specified value. Accepts numbers from 0 to 59. - Date/Time  - Minutes (0-59)  Get Minutes Returns the minutes from a specified date. - Date/Time  Add Minutes Adds a specified number of minutes to a date. To subtract, enter a negative number. - Date/Time  - Minutes (0-59)  Set Hour Sets the hour in a date to a specified value. Accepts numbers from 0 to 23. - Date/Time  - Hour (0-23)  Get Hour Returns the hours from a specified date. - Date/Time  Add Hours Adds a specified number of hours to a date. To subtract, enter a negative number. - Date/Time  - Hours  Set Day of Month Sets the day of the month in a date to a specified value. Accepts numbers from 1 to 31. - Date  - Day (1-31)  Get Day of Month Returns the day of the month from a specified date. - Date  Set Day of Year Sets the day of the year in a date to a specified value. Accepts numbers from 1 to 365. - Date  - Day (1-365)  Get Day of Year Returns the day of the year from a specified date. - Date  Get Day of Week as Number Returns the day of the week as a number from a specified date. - Date  Add Days Adds a specified number of days to a date. To subtract days, enter a negative number. - Date  - Days  Set Month Sets the month in a date to a specified value. Accepts numbers from 1 to 12. - Date  - Month (1-12)  Get Month Returns the month from a specified date. - Date  Add Months Adds a specified number of months to a date. To subtract months, enter a negative number. - Date  - Months  Set Year Sets the year in a date to a specified value. - Date  - Year  Get Year Returns the year from a specified date. - Date  Add Years Adds a specified number of years to a date. To subtract years, enter a negative number. - Date  - Years  Parse Date Parses a string and returns a date. - Date  - Format  Format Date Formats a date according to specified criteria. - Date  - Format"},{"location":"reference/transformer.html#math-operations","title":"Math Operations","text":"Operation Description Arguments  Subtract Subtracts one number from another. - Minuend  - Subtrahend  Divide Divides one number by another. - Dividend  - Divisor  Multiply Multiplies two numbers together. - Multiplier  - Multiplicand  Max Returns the largest number in a specified array or among individually entered numbers. - Number/Numbers  - Number/Numbers  Min Returns the smallest number in a specified array or among individually entered numbers. - Number/Numbers  - Number/Numbers  Sum Returns the sum of values in a specified array or among individually entered numbers. - Number/Numbers  - Number/Numbers  Round Up Rounds a number up to the nearest integer. - Number  Round Down Rounds a number down to the nearest integer. - Number  Round with Fraction Rounds a number to the nearest integer. - Number  Average Returns the average of the values in a specified array or among individually entered numbers. - Number/Numbers  - Number/Numbers  Parse Number Parses a string and returns a number. - Number  Format Number Formats a number according to specified criteria. - Number  - Decimal Points  - Decimal Separator  - Thousands Separator  Pi Returns the constant \u03c0. No arguments  Random Returns a random number between 0 and 1. No arguments"},{"location":"reference/transformer.html#text-operations","title":"Text Operations","text":"Operation Description Arguments  Lower Converts all characters in a text string to lowercase. - Text  Upper Converts all characters in a text string to uppercase. - Text  Trim Removes whitespace from the start and end of a text string. - Text  Capitalize Converts the first character of a text string to uppercase. - Text  Start Case Capitalizes the first letter of each word in a text string. - Text  Length Returns the length of a text string. - Text  Contains Checks if a text string contains a specified substring. - Text  - Search String  Substring Returns a portion of a text string between specified start and end positions. - Text  - Start  - End  Replace Replaces occurrences of a specified substring within a text string with another substring. - Text  - Search String  - Replacement string  Index Of Returns the position of the first occurrence of a specified substring within a text string. - Text  - Substring  - Start  Split Splits a text string into an array of substrings based on a specified separator. - Text  - Separator  - Keep Empty String  Unique Identifier Generates a RFC 4122 version 4 compliant unique identifier. No arguments  Decode URL Decodes a URL-encoded text string. - Text  Encode URL Encodes a text string to a URL-safe format. - Text  Text To Binary Converts a text string to a binary format. - Bytes  Binary To Text Converts binary data to a text string. - Bytes  To String Converts any value to a text string. - Value  md5 decode Calculates the MD5 hash of a text string. - Text  md5 encode Generates a text string from a given MD5 hash. - MD5  ascii Removes non-ASCII characters from a text string. - Text  - Remove Diacritics  base64 decode Decodes a Base64-encoded text string. - Text  base64 encode Encodes a text string in Base64 format. - Base64  Remove HTML tags Removes HTML tags from a text string. - Text  Escape HTML Tags Escapes HTML tags within a text string. - Text"},{"location":"reference/triggers-group.html","title":"Triggers Group","text":"<p>Imagine you are orchestrating a complex business workflow with multiple conditions that need to be met before proceeding to the next step. For instance, let's say you are managing an order processing system. You need to ensure that an order confirmation is received, payment is completed, and the inventory is updated before shipping the product. This is where FlowRunner's <code>Triggers Group</code> block comes into play.</p> <p></p> <p>In FlowRunner, the <code>Triggers Group</code> block allows you to pause the flow execution until specific conditions, represented by triggers, are met. This block can contain multiple trigger blocks, each representing a different condition. The triggers within this group are equal; there is no predefined order, and the flow will remain paused until the configured conditions are satisfied.</p>"},{"location":"reference/triggers-group.html#creating-a-triggers-group","title":"Creating a Triggers Group","text":"<p>To configure the Triggers Group block, click the <code>Expand</code> icon. This action opens a special editing mode in the Flow Editor that allows you to add other triggers to the group. In this mode, you can add the necessary triggers without needing to connect them in a sequence, as all triggers in a group are equal and do not represent any specific order.</p> <p></p>"},{"location":"reference/triggers-group.html#transition-modes","title":"Transition Modes","text":"<p>The Triggers Group block offers flexibility with two Outgoing Transition Modes. You can access the transition mode configuration by clicking the Triggers Group block in your flow to open its properties:</p> <p></p> <p>The first mode, \"When at least one trigger occurs,\" allows the flow to continue as soon as any one of the triggers in the group is activated. This is particularly useful in scenarios where you need to proceed as soon as any condition is met. For example, in our order processing system, you might want to start the shipping process as soon as either the order confirmation or the payment is completed, not necessarily waiting for both.</p> <p>The second mode, \"When all triggers start within the time set below,\" is designed for more complex scenarios where all conditions must be met within a certain timeframe before proceeding. In the same order processing example, you may want to ensure that both the order confirmation and payment completion happen within, say, 24 hours. If both triggers are activated within this period, the flow will continue to the next step, which might involve updating the inventory and preparing the product for shipment. If not, you might want to take a different action, such as notifying the customer or canceling the order.</p>"},{"location":"reference/triggers-group.html#triggers-group-benefits","title":"Triggers Group Benefits","text":"<p>Using the <code>Triggers Group</code> block, FlowRunner empowers you to design workflows that can adapt to various conditions and requirements. Whether you need to proceed based on the first available trigger or wait for all conditions to be met within a specified timeframe, this feature offers the flexibility to handle both simple and complex scenarios with ease.</p> <p>In essence, the <code>Triggers Group</code> block in FlowRunner is a powerful tool for managing workflow conditions. By allowing multiple triggers to be grouped and providing flexible transition modes, it ensures that your workflows can pause and resume based on precise conditions, making your automation processes more robust and reliable.</p>"},{"location":"reference/user-registered-trigger.html","title":"User Registered","text":"<p>The \"User Registered\" trigger block in FlowRunner\u2122 is designed to pause a flow until a new user account is created within your Backendless application. This trigger is activated when the user registration API call is used, which means a user uses the registration form in your application or someone with admin privileges registers a user.</p>"},{"location":"reference/user-registered-trigger.html#trigger-properties","title":"Trigger Properties","text":"<p>The trigger properties include:</p> <ul> <li>Name - should be a meaningful name that represents what this trigger does. Follow the recommendations in the Block Naming section of this guide for best practices.</li> <li>Condition - an optional condition associated with the trigger. When the trigger receives an activation event (i.e. when a user is being registered with the API), the system checks the condition. If the condition is evaluated to <code>TRUE</code>, the flow execution proceeds, otherwise, the trigger's event is ignored.</li> <li>Reference Trigger Data As - this is a name assigned to the data that activated the trigger. The data is a key/value structure that contains the values from the user registration API call.</li> </ul> <p></p>"},{"location":"reference/user-registered-trigger.html#assigning-custom-name","title":"Assigning Custom Name","text":"<p>To make your workflow more intuitive, it's recommended that you rename this block to something that clearly reflects the specific part of the process you are automating. Any references to the trigger activation event in the Expression Editor will then use this new name, which helps keep your workflow organized and understandable. The data received upon trigger activation can be utilized in any subsequent blocks within the flow. For example, the screenshot above shows the block has a name of <code>User Registered via Form</code>. Notice that in the screenshot below, the data for the trigger activation event uses the assigned name.</p>"},{"location":"reference/user-registered-trigger.html#accessing-trigger-data","title":"Accessing Trigger Data","text":"<p>Once activated, the trigger event provides the new user\u2019s information in a key/value structure format. The keys in this structure correspond to the column names in Backendless' \"Users\" table, and the values are what were included in the user registration API call.</p> <p></p> Note <p>One crucial detail to remember is that if a user is created directly through the Backendless Console, this trigger will not activate since the User Registration API call isn't utilized in that scenario.</p>"},{"location":"reference/user-registered-trigger.html#conditional-trigger-activation","title":"Conditional Trigger Activation","text":"<p>The \"User Registered\" trigger block also supports conditional logic. You can set conditions that control whether the trigger activates when a user registers. For the trigger to proceed, the condition must evaluate to true. More details on configuring these conditions can be found in the \"Conditional Logic\" chapter of this guide.</p>"},{"location":"reference/value-router.html","title":"Value Router","text":"<p>The Value Router block is a versatile routing utility in FlowRunner that allows you to dynamically direct flow execution based on evaluated values. By defining multiple branches with flexible matching criteria, it enables you to split workflows into precise execution paths based on data content, user inputs, or computed results. The block provides sophisticated routing logic while maintaining clean, readable workflow designs.</p> <p>The Value Router block evaluates a single input value against multiple branch conditions and routes execution to the appropriate path. Whether you need simple equality matching, collection-based routing, or range-based decisions, this block provides the flexibility to handle complex routing scenarios with precision and clarity.</p> <p>Common use cases include routing based on user roles or permissions, directing workflows based on data categories or types, implementing approval workflows with different paths for various scenarios, handling API responses with multiple possible outcomes, and creating dynamic workflows that adapt to changing business rules or thresholds.</p> <p></p>"},{"location":"reference/value-router.html#block-configuration","title":"Block Configuration","text":"<p>The Value Router block consists of a primary evaluation field and multiple branch configurations that define the routing logic.</p>"},{"location":"reference/value-router.html#value-to-evaluate","title":"Value to Evaluate","text":"<p>The \"Value to Evaluate\" field specifies the data that will be compared against branch conditions to determine routing. This field supports the Expression Editor, allowing you to select values from previous blocks, trigger data, or computed expressions.</p> <p></p> <p>Common Evaluation Sources</p> <ul> <li>User attributes: <code>User.role</code>, <code>User.department</code>, <code>User.accountType</code></li> <li>API response data: <code>APIResponse.status</code>, <code>APIResponse.category</code></li> <li>Computed values: <code>OrderTotal.amount</code>, <code>ProcessingResult.score</code></li> <li>Trigger data: <code>WebhookData.eventType</code>, <code>FormSubmission.priority</code></li> </ul> <p>The value you specify here becomes the basis for all branch matching logic, so choose data that provides meaningful differentiation for your workflow routing needs.</p>"},{"location":"reference/value-router.html#branch-configuration","title":"Branch Configuration","text":"<p>The Value Router block allows you to create multiple branches, each representing a different execution path based on specific matching criteria. You can add as many branches as needed to handle your routing scenarios, with each branch configured independently.</p> <p>Available Branch Types:</p> <ul> <li>Single Value Matching: Route when the evaluated value exactly equals one specific value</li> <li>Collection Matching: Route when the evaluated value matches any value from a specified list</li> <li>Range Matching: Route when the evaluated value falls within a numeric range</li> </ul> <p>Each branch operates independently, and the Value Router will route to the first branch whose conditions are met, making branch order important for overlapping conditions.</p> <p></p> <p>Each branch in the Value Router represents a potential execution path with its own matching criteria. You can create multiple branches to handle different scenarios and values.</p>"},{"location":"reference/value-router.html#branch-name","title":"Branch Name","text":"<p>The Branch Name field assigns a descriptive label to each routing path. This name becomes the connector label on the block, making your workflow more readable and self-documenting.</p> <p>Naming Best Practices</p> <ul> <li>Use descriptive names that clearly indicate the routing purpose</li> <li>Examples: \"Admin Users\", \"High Priority Orders\", \"Approved Status\", \"Weekend Processing\"</li> <li>Avoid generic names like \"Branch 1\" or \"Option A\"</li> <li>Consider using business terminology that stakeholders will understand</li> </ul>"},{"location":"reference/value-router.html#value-mode-options","title":"Value Mode Options","text":"<p>The Value Mode dropdown determines how the branch matching logic operates, providing three distinct matching patterns for different use cases.</p>"},{"location":"reference/value-router.html#single-value","title":"Single Value","text":"<p>When \"Single Value\" is selected, the branch matches when the \"Value to Evaluate\" exactly equals the specified value. This mode is ideal for precise matching scenarios.</p> <p>Single Value Configuration:</p> <ul> <li>Value Field: Input field supporting Expression Editor for dynamic values</li> <li>Matching Logic: Exact equality comparison</li> <li>Use Cases: User roles, status codes, specific categories, boolean flags</li> </ul> <p>Example Configuration</p> Field Value Branch Name Admin Access Value Mode Single Value Value \"administrator\" <p>This branch activates when <code>Value to Evaluate</code> equals exactly \"administrator\".</p>"},{"location":"reference/value-router.html#collection-of-values","title":"Collection of Values","text":"<p>The \"Collection of Values\" mode allows you to specify multiple values that can trigger the same branch. If the \"Value to Evaluate\" matches any value in the collection, the branch is selected.</p> <p>Collection Configuration:</p> <ul> <li>Multiple Value Fields: Add values using the \"+\" button</li> <li>Expression Editor Support: Each field supports dynamic values</li> <li>Matching Logic: OR logic - matches if evaluation equals any specified value</li> <li>Use Cases: Multiple user roles, various status categories, different product types</li> </ul> <p>Example Configuration</p> Field Value Branch Name Management Access Value Mode Collection of Values Value 1 \"manager\" Value 2 \"supervisor\" Value 3 \"director\" <p>This branch activates when <code>Value to Evaluate</code> equals \"manager\", \"supervisor\", or \"director\".</p>"},{"location":"reference/value-router.html#range-of-values","title":"Range of Values","text":"<p>The \"Range of Values\" mode enables numeric range matching, routing execution when the evaluated value falls within specified boundaries.</p> <p>Range Configuration:</p> <ul> <li>From Field: Lower boundary (inclusive)</li> <li>To Field: Upper boundary (inclusive)</li> <li>Expression Editor Support: Both fields support dynamic values</li> <li>Matching Logic: Inclusive range check (From \u2264 value \u2264 To)</li> <li>Use Cases: Order amounts, user ages, scores, quantities, time periods</li> </ul> <p>Example Configuration</p> Field Value Branch Name High Value Orders Value Mode Range of Values From 1000 To 5000 <p>This branch activates when <code>Value to Evaluate</code> is between 1000 and 5000 (inclusive).</p>"},{"location":"reference/value-router.html#default-routing-with-everything-else","title":"Default Routing with Everything Else","text":"<p>The Value Router automatically includes an \"Everything Else\" branch that handles cases where the evaluated value doesn't match any configured branch criteria. This ensures robust workflow execution even with unexpected data.</p> <p>Everything Else Branch Features</p> <ul> <li>Automatic Inclusion: Always present, no configuration required</li> <li>Fallback Logic: Activates when no other branches match</li> <li>Error Prevention: Prevents workflow failures from unmatched values</li> <li>Debugging Aid: Useful for logging unexpected values or implementing fallback actions</li> </ul> Common Everything Else Uses <ul> <li>Error logging and notification</li> <li>Default processing paths</li> <li>Fallback business logic</li> <li>Data validation and quality checks</li> </ul>"},{"location":"reference/value-router.html#execution-flow-and-branch-selection","title":"Execution Flow and Branch Selection","text":"<p>The Value Router evaluates branches in the order they are configured and routes to the first matching branch. Understanding this evaluation order helps you design effective routing logic.</p>"},{"location":"reference/value-router.html#evaluation-process","title":"Evaluation Process","text":"<ol> <li>Value Assessment: The \"Value to Evaluate\" is computed using current workflow context</li> <li>Branch Testing: Each branch is tested in configuration order</li> <li>First Match Selection: The first branch meeting its criteria is selected for execution</li> <li>Everything Else Fallback: If no branches match, the Everything Else path is taken</li> </ol>"},{"location":"reference/value-router.html#branch-priority-considerations","title":"Branch Priority Considerations","text":"<p>Since evaluation stops at the first match, arrange branches strategically:</p> <ul> <li>Place more specific conditions before general ones</li> <li>Order range conditions to avoid overlap conflicts</li> <li>Consider the likelihood of different values when ordering branches</li> </ul>"},{"location":"reference/wait.html","title":"Wait","text":"<p>Introducing pauses or delays in your automation flows can be crucial for timing certain actions perfectly. Imagine you want to send a welcome email to a new user after they register for your service. To avoid sending it instantly and to make the process feel more personalized, you might decide to delay the email delivery. Backendless makes this easy with the <code>Wait</code> block, allowing you to incorporate such pauses seamlessly into your flows.</p>"},{"location":"reference/wait.html#why-wait","title":"Why <code>Wait</code>?","text":"<p>The <code>Wait</code> block serves a simple yet powerful purpose: it pauses the flow of actions for a specified period. This feature can be handy in various scenarios, such as delaying notifications, emails, or any other actions, to ensure they occur at the most opportune moment.</p>"},{"location":"reference/wait.html#setting-up-delays","title":"Setting Up Delays","text":"<p>The <code>Wait</code> block offers two approaches for injecting a delay in the flow execution. Each approach is designed to meet different needs:</p>"},{"location":"reference/wait.html#simple-mode","title":"Simple Mode","text":"<p>For direct and uncomplicated delays, the Simple Mode lets you specify a fixed delay in days, hours, minutes, or seconds. This mode is ideal when you need a consistent pause in your flow. The requirement is to set at least one of these time units to a non-zero value. </p>"},{"location":"reference/wait.html#advanced-mode","title":"Advanced Mode","text":"<p>For scenarios where the delay needs to be more flexible, the Advanced Mode comes into play. This mode utilizes the Expression Editor, which allows you to calculate the delay period dynamically. Whether through a variable, a property, or a custom expression, the resulting value determines the length of the pause, measured in seconds. </p> <p>Implementing delays in Backendless automation flows offers a straightforward method to time your actions precisely, enhancing the overall effectiveness and personalization. Whether you're aiming for simplicity with a fixed delay or seeking flexibility with dynamic calculation, the <code>Wait</code> block provides the necessary functionality to integrate these pauses into your flows effortlessly.</p>"},{"location":"training/about-demo-flows.html","title":"About Demo Flows","text":"<p>FlowRunner\u2122 comes with a set of sample flows designed to help you learn and explore its capabilities. These flows demonstrate common use cases and techniques, offering practical examples of how to build and automate workflows effectively. Each flow is tailored to teach specific skills, from handling user inputs to leveraging AI and managing errors.  </p> <p>The following tables provide a detailed overview of the included sample flows and highlight the features they demonstrate.  </p>"},{"location":"training/about-demo-flows.html#sample-flows","title":"Sample Flows","text":"Flow Name Overview Features Covered Welcome Email Flow  Automatically initiates a flow to send a welcome email when a new user registers, ensuring personalized communication with each new user. <ul><li>User Registered Trigger</li><li>Custom Action</li><li>Conditions</li><li>Gmail integration</li></ul> Basic Approval Flow  Implements a standard approval process where user-submitted requests are routed to an approver. Approved requests proceed, while denied ones loop back with feedback. <ul><li>AppLogic Trigger</li><li>Variables<li>Store data in database</li><li>Gmail integration</li><li>Triggers Group</li><li>Value Router</li><li>Error handling</li> Daily Reminder Email Flow  Automates weekly checks for incomplete tasks and sends reminders, ensuring tasks stay on track and deadlines are met. <ul><li>Scheduled flows</li><li>Database Data Retrieval<li>Loops</li> Customer Satisfaction Survey  Processes survey form inputs, records responses, assigns satisfaction scores, and sends thank-you notes based on the results. <ul><li>External Callback with Google Forms</li><li>Conditions</li><li>Assign Instance Name</li><li>Saving Data in DB</li><li>Gmail integration</li></ul> AI-Driven Sentiment Analysis  Analyzes sentiment in user feedback using AI and routes positive or negative feedback to the appropriate teams for follow-up. <ul><li>AI Router</li><li>External Callback with Google Forms</li><li>Actions Group</li><li>Record Update in DB</li><li>Gmail integration</li></ul> AI-Powered Chatbot  Enables bidirectional communication between a user interface and AI, where user prompts are processed and responses are delivered back to the UI. <ul><li>Loop</li><li>AI Assistant</li><li>App Logic Trigger</li><li>Bidirectional communication with UI</li></ul> AI-Powered Daily Report   Generates and sends a daily summary report, combining AI document processing with PDF Generation and email automation. <ul><li>Scheduled flows</li><li>AI Assistant</li><li>PDF generation</li><li>Gmail integration</li></ul> AI-Powered Data From Image Extraction  Handles file uploads by extracting data from images using AI and saving the results in a database for further processing. <ul><li>App Logic Trigger</li><li>AI Assistant</li><li>File storage</li><li>Save Data in DB</li><li>Communication with UI</li></ul> Sample Error Handling  Runs tasks with error monitoring, sending notifications and logging error details whenever issues arise. <ul><li>External Callback</li><li>Saving Data in DB</li><li>Update Data in DB</li><li>Error Handler</li><li>Logging/Debugging</li></ul>"},{"location":"training/about-demo-flows.html#features-and-sample-flows","title":"Features and Sample Flows","text":"<p>These tables provide a comprehensive guide to the sample flows included in FlowRunner\u2122, helping you quickly identify the flows and features most relevant to your needs. By exploring these examples, you can gain valuable insights into building effective and sophisticated workflows.  </p> Feature Sample Flows Actions Group AI-Driven Sentiment Analysis AI Assistant AI-Powered ChatbotAI-Powered Daily Report AI Document Processing AI-Powered Data From Image AI Router AI-Driven Sentiment Analysis AppLogic Trigger Basic Approval FlowAI-Powered Chatbot Assign Instance Name Customer Satisfaction Survey Bidirectional Communication with UI AI-Powered ChatbotAI-Powered Data From Image Conditions Welcome Email FlowCustomer Satisfaction SurveyAI-Driven Sentiment Analysis Custom Action Welcome Email Flow Gmail integration Welcome Email FlowBasic Approval FlowCustomer Satisfaction SurveyAI-Driven Sentiment AnalysisAI-Powered Daily Report Database Data Retrieval Daily Reminder Email Flow Error Handling Basic Approval FlowSample Error Handling External Callback Customer Satisfaction SurveyAI-Driven Sentiment AnalysisSample Error Handling Logging/Debugging Sample Error Handling Loops Daily Reminder Email FlowAI-Powered Chatbot PDF Generation AI-Powered Daily Report Record Update in DB AI-Driven Sentiment AnalysisSample Error Handling Scheduled Flows Daily Reminder Email FlowAI-Powered Daily Report Store Data in Database Basic Approval FlowCustomer Satisfaction SurveySample Error Handling Triggers Group Basic Approval Flow User Registered Trigger Welcome Email Flow Value Router Basic Approval Flow Variables Basic Approval Flow"},{"location":"training/ai-chatbot.html","title":"AI-Powered Chatbot","text":"<p>The AI Chatbot Flow demonstrates how to create a dynamic, interactive chatbot experience by combining FlowRunner\u2122 with a custom user interface. This solution highlights essential FlowRunner\u2122 concepts such as looping, integrating AI assistants, bidirectional communication between UI and flow, and using the Call Flow API.  </p> <p>This chatbot is designed to be highly adaptable; by training an AI assistant on specific domains, you can create specialized chatbots without modifying the flow\u2019s core logic or UI. Let\u2019s break down the backend (the flow) and the frontend (the UI) to understand how this solution works.  </p>"},{"location":"training/ai-chatbot.html#flow-highlights","title":"Flow Highlights","text":"<p>This flow and UI combination introduces several essential concepts in FlowRunner\u2122 and Backendless:  </p> <ul> <li>Flow Loops with Repeat Block: Learn how to handle repetitive tasks, like processing sequential user inputs, using the Repeat block.  </li> <li>Flow-to-UI Communication: Discover how to send flow-generated data back to the UI in real time, ensuring seamless interactions.  </li> <li>AI Integration: Explore how to integrate AI assistants into your flows to build intelligent, context-aware chatbots.  </li> <li>Session Isolation with Execution ID: Understand how <code>executionId</code> is used to isolate sessions, enabling multiple concurrent chatbot interactions without interference.  </li> <li>Using Call Flow API: Gain experience with the Call Flow API to dynamically create flow instances from the UI.  </li> </ul>"},{"location":"training/ai-chatbot.html#backend-the-flow","title":"Backend: The Flow","text":""},{"location":"training/ai-chatbot.html#the-repeat-block","title":"The Repeat Block","text":"<p>The flow provides the backend logic that powers the chatbot. At the highest level, the flow uses a Repeat block to process messages in a loop. This structure ensures the chatbot can handle multiple back-and-forth exchanges between the user and the AI in the same session.  </p> <p></p> <p>The Repeat block contains the logic for handling a single interaction between the user and the AI. </p>"},{"location":"training/ai-chatbot.html#app-logic-trigger","title":"App Logic Trigger","text":"<p>Repeat's loop iteration starts with an App Logic Trigger block, which waits for a new message to be submitted by the user. The trigger provides the <code>message</code> property, which contains the user\u2019s input.  </p> <p></p>"},{"location":"training/ai-chatbot.html#ai-assistant","title":"AI Assistant","text":"<p>The user\u2019s message is passed to the AI Chatbot block as the Message to Assistant parameter. The block, which uses an AI assistant which can be trained for specific chatbot interactions, generates a response. The AI Chatbot Result element contains the response data in its <code>decision</code> property. This value represents the AI\u2019s reply to the user\u2019s input.  </p> <p></p>"},{"location":"training/ai-chatbot.html#send-data-to-ui","title":"Send Data to UI","text":"<p>The flow uses the Send Data to UI block to deliver the AI\u2019s response back to the user.  </p> <ul> <li>The <code>Data</code> parameter is set to the <code>decision</code> property from the AI result.  </li> <li>The <code>SessionId</code> parameter is set to the flow\u2019s <code>Execution ID</code>, ensuring the response is sent to the correct user session.  This architecture ensures that each chatbot session remains isolated, even when multiple users interact with the system simultaneously.  </li> </ul> <p></p>"},{"location":"training/ai-chatbot.html#frontend-the-ui","title":"Frontend: The UI","text":"<p>The custom UI page provides the user interface for interacting with the chatbot. It initializes the flow instance, manages real-time communication, and handles user input.  </p> <p></p>"},{"location":"training/ai-chatbot.html#starting-flow","title":"Starting Flow","text":"<p>When the UI page loads, it uses the Call Flow API to create a new flow instance. This process assigns a unique identifier, <code>executionId</code>, to the flow instance. The identifier is returned in the API's response and then stored in the Page Data using the Assign Object Properties block.  </p> <p></p>"},{"location":"training/ai-chatbot.html#receiving-messages-from-flow","title":"Receiving Messages from Flow","text":"<p>The page creates a real-time (RT) listener tied to a messaging channel named after the assigned <code>executionId</code> value. This ensures that the UI only receives messages from the specific flow instance associated with the session. When a new message is received, the UI updates the chat display by adding the message to a list and re-rendering the view using data-binding.  </p> <p></p>"},{"location":"training/ai-chatbot.html#sending-messages-from-user","title":"Sending Messages from User","text":"<p>The Send button\u2019s <code>On Click</code> event contains the logic for sending user messages to the flow.  When the user clicks Send, the <code>sendMessage</code> function triggers the Run App Logic Trigger Codeless block.</p> <p></p> <p>Notice the Run App Logic Trigger block operates in Activate Specific mode, ensuring the correct flow instance is activated. It uses the <code>executionId</code> stored in the Page Data (which is the result of the <code>Call Flow</code> API call) to target the corresponding chatbot session.  </p> <p>The <code>Body</code> parameter contains the user\u2019s message, which is sent to the flow for processing.  </p> <p>By studying and experimenting with the AI Chatbot Flow, you\u2019ll develop a deeper understanding of building responsive, real-time, and intelligent applications with FlowRunner\u2122 and Backendless.  </p>"},{"location":"training/ai-driven-sentiment-analysis.html","title":"AI-Driven Sentiment Analysis","text":"<p>The AI-Driven Sentiment Analysis Flow showcases how FlowRunner\u2122 leverages AI to evaluate user feedback and route decisions dynamically. By integrating a Google Form, a database, and AI Router functionality, this flow provides a hands-on example of building intelligent workflows that respond to user input.  </p>"},{"location":"training/ai-driven-sentiment-analysis.html#about-the-flow","title":"About the Flow","text":"<p>This flow begins when a user submits a Google Form containing their name, email, and feedback. The flow saves the form data in a database and uses the AI Router block to analyze the sentiment of the feedback. Based on the sentiment - Positive, Negative, Neutral, or Everything Else - the flow branches into separate paths, each demonstrating different actions and logic.  </p> <p>For example:  </p> <ul> <li>Positive feedback can be flagged for sharing on social media.  </li> <li>Negative feedback triggers a sequence of actions grouped in an Actions Group block.  </li> <li>Neutral feedback results in a follow-up email.  </li> <li>If the AI cannot determine the sentiment, the flow logs the result for further analysis.  </li> </ul>"},{"location":"training/ai-driven-sentiment-analysis.html#how-the-flow-works","title":"How the Flow Works","text":""},{"location":"training/ai-driven-sentiment-analysis.html#receiving-form-data","title":"Receiving Form Data","text":"<p>The flow begins with the Form Submitted block, which receives data from the Google Form. For demo purposes, the form collects: CallbackURL, Name , Email , Feedback </p> <p></p> <p>Note on the Callback URL Field</p> <p>The form includes a field for the Callback URL. This field is present to make the form reusable and to simplify the setup process. By including it directly in the form, you can quickly connect the form to the flow without additional steps.</p> <p>To configure this, copy the Callback URL from the Form Submitted block in the flow and paste it into the Callback URL field in the form. A script in the form uses this value to send the form data to the flow upon submission.</p> <p>If you\u2019re creating your own form, check the section at the end of this chapter for detailed instructions. You\u2019ll see how the Callback URL is incorporated into the form\u2019s submission script.</p> <p>The form data is then saved in a database table to enable future analysis. Each submission creates a new record in the <code>AIDrivenSentimentAnalysisFlow</code> table, mapping the form fields to corresponding columns.  </p> <p></p> <p>Note on the Database Table\"**</p> <p>Every FlowRunner\u2122 workspace includes a database by default. To view the database structure for this flow, click the QUICK ACCESS button in the top-left corner of the interface and navigate to Backendless Database. Select the <code>AIDrivenSentimentAnalysisFlow</code> table to explore its contents.</p> <p>The DATA BROWSER tab displays the table's data, while the SCHEMA tab shows its structure and fields.</p>"},{"location":"training/ai-driven-sentiment-analysis.html#analyzing-feedback-sentiment","title":"Analyzing Feedback Sentiment","text":"<p>The AI Router block evaluates the sentiment of the feedback provided in the form. The block is configured with three main decision outcomes:  </p> <ul> <li>Positive </li> <li>Negative </li> <li>Neutral </li> </ul> <p>It also includes an \"Everything Else\" outcome, used when the AI cannot confidently classify the feedback.  </p> <p></p> <p>The AI Router block uses the following prompt:  </p> <pre><code>The \"Feedback\" field contains user feedback. Determine the sentiment of the feedback.  \n</code></pre> <p>The Feedback field is passed to the block as Decision Data, which the AI analyzes to determine the appropriate sentiment.  </p>"},{"location":"training/ai-driven-sentiment-analysis.html#branching-logic","title":"Branching Logic","text":"<p>The AI processes the feedback value and chooses one of the provided expected decisions. If none of the decisions apply, the resulting branch will follow the Everything Else route. Based on the determined sentiment, the flow follows different branches:  </p> <p>Positive Feedback:   One branch updates the database record to indicate the feedback is suitable for social media. This is done by setting the <code>shareFeedback</code> column to <code>true</code>.  The other branch sends an email to the user thanking them for the positive feedback.</p> <p>Negative Feedback:   The negative branch demonstrates the use of an Actions Group. Inside the group, several actions are performed sequentially. Specifically, the actions include logging the received form data in FlowLogger and sending an email to \"customer service\".</p> <p>Neutral Feedback:   The flow logs the form data in FlowLogger. </p> <p>Everything Else:   If the AI cannot determine the sentiment, the flow logs the result for analysis. This ensures no feedback is overlooked.  </p>"},{"location":"training/ai-driven-sentiment-analysis.html#preparing-the-flow","title":"Preparing the Flow","text":"<p>To configure and test the flow, follow these steps:  </p> <ol> <li> <p>Set Up Gmail Integration:    Open the Send Email block (standalone and inside the Actions Group). Click the Login button to perform an OAuth login with your Google account. This enables the flow to send emails using your account.  </p> </li> <li> <p>Configure FlowLogger:    Open any of the Log blocks in the flow and click Configure. Enter the session code from FlowLogger to capture log messages in real time.  </p> </li> <li> <p>Connect the Google Form:    Copy the Callback URL from the Form Submitted block in the Flow Editor. Paste this URL into the Google Form to ensure submissions are sent to your flow.  </p> </li> </ol>"},{"location":"training/ai-driven-sentiment-analysis.html#running-the-flow","title":"Running the Flow","text":"<p>Once the configuration is complete, start the flow by clicking the Start Flow button. Open the Google Form, fill it out and submit. The flow will automatically process the data and execute actions based on the sentiment analysis.  </p> <ul> <li>Positive feedback will be flagged in the database or routed to other actions.  </li> <li>Negative feedback will trigger additional steps in the Actions Group.  </li> <li>Neutral and Indeterminate feedback will be logged for review.  </li> </ul> <p>Monitor the flow\u2019s execution in FlowLogger to observe how decisions are made and actions are executed.  </p>"},{"location":"training/ai-driven-sentiment-analysis.html#set-up-your-own-google-form","title":"Set Up Your Own Google Form","text":"<ol> <li> <p>Create the Form    Navigate to Google Forms and create a new form. Add the following fields:  </p> <ul> <li>Name (Short Answer)  </li> <li>Email (Short Answer)  </li> <li>Satisfaction (Linear Scale, 1 to 10, labeled \"Dissatisfied\" to \"Highly Satisfied\")  </li> <li>Feedback (Paragraph)  </li> </ul> </li> <li> <p>Access the Script Editor    In the form, click the three-dot menu in the top-right corner, then select Script Editor.  </p> </li> <li> <p>Add a Script to Submit Data to FlowRunner\u2122    Replace any default code in the Apps Script editor with the following script:  </p> <pre><code>function onFormSubmit(e) { \n var url = \"YOUR_EXTERNAL_CALLBACK_URL_HERE\"; // Replace with your target URL \n var formResponse = e.response; // Extract answers from the form response \n var itemResponses = formResponse.getItemResponses(); \n var data = {}; \n for (var i = 0; i &lt; itemResponses.length; i++) { \n     var itemResponse = itemResponses[i]; \n     data[itemResponse.getItem().getTitle()] = itemResponse.getResponse(); \n } \n // Send data as POST request \n var options = { \n     method: \"post\", \n     contentType: \"application/json\", \n     payload: JSON.stringify(data) \n }; \n UrlFetchApp.fetch(url, options); \n}\n</code></pre> <p>Replace <code>YOUR_EXTERNAL_CALLBACK_URL_HERE</code> with the Callback URL copied from the Form Submitted block.  </p> </li> <li> <p>Set Up the Trigger    In the Script Editor:  </p> <ul> <li>Open the Triggers menu (clock icon or via Extensions &gt; Apps Script &gt; Triggers).  </li> <li>Add a new trigger for the <code>onFormSubmit</code> function.  </li> <li>Set the event type to On form submit and save.  </li> </ul> </li> <li> <p>Grant Permissions    When saving the trigger, Google will prompt you to authorize the script. Review the permissions, select your Google account, and allow the required access.  </p> <p>Once completed, your custom form is ready to submit data to the flow.  </p> </li> </ol>"},{"location":"training/ai-driven-sentiment-analysis.html#key-concepts-demonstrated","title":"Key Concepts Demonstrated","text":"<p>This flow highlights several important FlowRunner\u2122 features:  </p> <ul> <li>AI Router Block: Configure AI decision-making with dynamic branching based on outcomes.  </li> <li>Database Integration: Save and update records in a database table as part of flow execution.  </li> <li>Actions Group: Combine multiple actions into a single group for sequential or conditional execution.  </li> <li>FlowLogger: Monitor flow activity and outcomes in real time for debugging and analysis.  </li> </ul> <p>By exploring the AI-Driven Sentiment Analysis Flow, you\u2019ll gain practical experience with AI integration, branching logic, and FlowRunner\u2019s robust automation capabilities.  </p>"},{"location":"training/ai-powered-daily-report.html","title":"AI-Powered Daily Report","text":"<p>The Daily Report Generation with AI flow demonstrates how to automate the creation and delivery of data-driven reports using FlowRunner\u2122. This flow leverages AI-powered chart generation, PDF templating, and email integration to deliver professional-quality reports automatically.  </p>"},{"location":"training/ai-powered-daily-report.html#how-the-flow-works","title":"How the Flow Works","text":""},{"location":"training/ai-powered-daily-report.html#data-fetch","title":"Data Fetch","text":"<p>The flow is initiated daily through a configured schedule. When the flow runs, it begins with the Fetch Orders(1) block which  queries the Orders database table to retrieve order data. For demonstration purposes, the query fetches all orders, but it can be customized to include only recent entries.  Notice the result of the block is referenced as <code>Orders List</code> (see the bottom of the screenshot below). That value will be used in the next step of the flow.</p> <ol> <li> The Fetch Orders block is an instance of Find Record(s) in Database. It is an action responsible for retrieving data from the Backendless database associated with your workspace.</li> </ol> <p></p>"},{"location":"training/ai-powered-daily-report.html#orders-exist","title":"Orders Exist?","text":"<p>The retrieved data is evaluated using a Condition block. If no orders are returned, the flow terminates via the \"No\" connector on the block(1). If there are orders, the flow continues along the \"Yes\" branch to the next step. </p> <ol> <li> Notice the \"No\" connector is not connected to any blocks. When the condition is evaluated to <code>false</code> (i.e. \"No\") the flow will stop because it has nowhere to go.</li> </ol> <p>The condition checks the <code>Orders List</code> value, which is the result returned by the Fetch Orders block. This value is a JSON array(1), and the condition evaluates whether the array's length is greater than 0 - effectively determining if it is not empty.</p> <ol> <li> To check what the returned data looks like, try running the Fetch Orders block in Test Mode.</li> </ol> <p></p>"},{"location":"training/ai-powered-daily-report.html#generate-charts","title":"Generate Charts","text":"<p>The next block in the sequence is the Generate Charts block, which is powered by an AI Assistant. This assistant analyzes the order data and generates three charts. The block's configuration is very simple - it passes the <code>Orders List</code> to the assistant. Notice the result of the assistant's action is referenced as <code>AI data analyst Result</code> - it will be used in the subsequent actions in the flow.</p> <p></p> <p>However the most interesting part is the actual assistant configuration. To see how the assistant is configured, switch to the Blocks Toolbox view, hover the mouse pointer over the AI data analyst assistant and click the view assistant configuration icon. The following popup will open with the configuration (prompt) that specifies how the charts are generated:</p> <p></p> <p>The complete text of the assistant's prompt is below: <pre><code>You are an AI data analyst. I will provide you with a dataset in JSON format, \nand I want you to generate the following visualizations:\n\nOrders by Product Summary: A bar chart showing the number of orders for each product.\nAmount by Product Summary: A bar chart showing the total revenue (in dollars) generated by each product.\nAmount by Salesperson: A bar chart showing the total revenue (in dollars) generated by each salesperson.\n\nInstructions:\n\nUse appropriate labels and titles for the charts.\nIf possible, include exact values on the bars for clarity.\nHighlight the top-performing product and salesperson in the visualizations.\nIf the dataset is incomplete or malformed, suggest corrections or assumptions.\nCharts should be visually appealing.\nUse padding for images.\nGenerate the charts as separate PNG images.\nFor file names use chart titles.\n</code></pre></p>"},{"location":"training/ai-powered-daily-report.html#get-charts-files","title":"Get Charts Files","text":"<p>After chart generation, the flow proceeds to the Retrieve Charts - Action Group block. This is a special type of block in FlowRunner\u2122 that can group multiple actions. The group ensures that all its contained actions - such as fetching chart references - complete successfully before moving forward.  </p> <p></p> <p>To see the contents of the group, click the \"expand\" icon - . You will see there are three actions in the group. Each action is responsible for obtaining a specific file from the AI Assistant's result. Results of the actions in a group will be visible outside of the group:</p> <p></p>"},{"location":"training/ai-powered-daily-report.html#generate-pdf","title":"Generate PDF","text":"<p>Once the charts are retrieved, the flow moves to the Generate PDF Report block. This block uses a predefined PDF Template with fields mapped to the flow data. The charts generated earlier are inserted into these fields to create a polished PDF report.  </p> <p></p> <p>There are several important configuration elements shown in the screenshot above:</p> <ol> <li>The Template field identifies a PDF Template used by the generator (see the details about PDF templates below).</li> <li>The Template Values section establishes the mappings between the data in the flow (charts extracted by the actions in the Action Group) and the \"fields\" in the specified template.</li> </ol> <p>To further understand how it works, navigate to the PDF Template Editor by clicking the QUICK ACCESS button and search for \"PDF\". Click the PDF Template Editor. The Orders Daily Report template will open by default (if not, click the template to open). The template consists of two pages. Both pages have \"fields\". A field summary is displayed in the Field List on the right:</p> <p></p> <p>If you go back to the Generate PDF Report block's settings, you will see that the fields declared in the PDF Template are listed in the Template Values section. This is where data from the flow is mapped to the fields. </p>"},{"location":"training/ai-powered-daily-report.html#send-email","title":"Send Email","text":"<p>The final step is the Send Report in Email block. This block uses Gmail integration to send the generated report to a specified email address. The Generate PDF Report block provides a URL for the generated report, which is attached to the outgoing email. </p> <p></p>"},{"location":"training/ai-powered-daily-report.html#configuring-the-flow-schedule","title":"Configuring the Flow Schedule","text":"<p>This flow is configured to run once a day. To inspect the schedule, open the Flow Manager interface and locate the flow by searching for Daily Report Generation with AI. You will notice the schedule icon is highlighted green, indicating an active schedule. Click the icon to view the schedule details, which confirm the daily execution setup.  </p> <p></p>"},{"location":"training/ai-powered-daily-report.html#preparing-to-run-the-flow","title":"Preparing to Run the Flow","text":"<p>Before running the flow, you need to ensure Gmail integration is set up. Open the Send Report in Email block, click the Login button, and authenticate with your Google credentials. This step allows the flow to send emails using your Gmail account.  </p> <p>Next, specify the recipient's email address in the To field of the same block. This address will receive the generated report.</p> <p></p>"},{"location":"training/ai-powered-daily-report.html#running-the-flow","title":"Running the Flow","text":"<p>To start the flow, click the Start Flow button in the Flow Editor. The flow will execute according to its defined schedule, querying order data, generating charts and a PDF report, and emailing the report to the specified recipient.  </p> <p>The Daily Report Generation with AI flow illustrates how FlowRunner\u2122 can automate repetitive reporting tasks, incorporating AI and dynamic data handling. With its ability to produce polished, data-rich reports effortlessly, this flow serves as a powerful example of automation for professional environments.  </p>"},{"location":"training/ai-powered-extraction-from-image.html","title":"AI-Powered Data From Image","text":"<p>The Business Card Data Extraction with AI flow showcases how FlowRunner\u2122\u2122 can automate the extraction of structured data from images using AI, providing a flexible foundation for workflows that process visual inputs like business cards, documents, or scanned forms.  This flow combines file upload trigger, conditional logic, AI-powered data extraction, and database integration to deliver a seamless and efficient solution. Below is an in-depth look at how the flow works and how to use it.</p>"},{"location":"training/ai-powered-extraction-from-image.html#what-you-will-learn","title":"What You Will Learn","text":"<p>This sample flow highlights several important features and techniques in FlowRunner\u2122:  </p> <ul> <li>File Upload Triggers: Automate workflows based on file uploads with validation conditions.  </li> <li>AI Integration: Use AI Assistants to extract meaningful data from complex inputs like images.  </li> <li>Error Handling: Implement robust error handling to manage and log failures gracefully.  </li> <li>Database Integration: Save and organize structured data for future use.  </li> </ul>"},{"location":"training/ai-powered-extraction-from-image.html#how-the-flow-works","title":"How the Flow Works","text":""},{"location":"training/ai-powered-extraction-from-image.html#app-logic-trigger-for-file-upload","title":"App Logic Trigger for File Upload","text":"<p>The flow begins when a user uploads an image of a business card via a UI page. This triggers the Business Card Uploaded block in the flow. The trigger is an App Logic Trigger. </p> <p></p>"},{"location":"training/ai-powered-extraction-from-image.html#ai-data-extraction","title":"AI Data Extraction","text":"<p>Once a flow instance is activated by the trigger, the flow sends the image URL to an AI Assistant configured for business card data extraction. The assistant processes the image and returns a structured JSON response containing the extracted contact details:  Contact's Name, Email, Phone, and Address.</p> <p></p> <p>The AI Assistant is configured without additonal capabilities such as \"Data Analyzer\" or \"Data Search in Files\". The assistant's prompt is below:</p> <pre><code>You are an AI Assistant specialized in extracting key information from images of business cards. Users will provide you with an image of a business card, and your task is to analyze the image and extract the following details:\n\n1. Name: The name of the individual or business.\n2. Email: The email address present on the card.\n3. Phone Number: Any phone number(s) listed.\n4. Address: The postal address, if available.\n\nWorkflow:\n1. Input:\n   - Accept the image of the business card as input.\n\n2. Process:\n   - Use OCR (Optical Character Recognition) to extract text from the image.\n   - Identify and categorize the extracted text into the specified fields.\n\n3. Output:\n   - Return the extracted data in a structured JSON format:\n\n     {\n       \"Name\": \"John Doe\",\n       \"Email\": \"john.doe@example.com\",\n       \"Phone\": \"+1 234 567 8900\",\n       \"Address\": \"123 Business St, Cityville, State, ZIP\"\n     }\n\n   - If multiple matches are found for a category (e.g., two phone numbers), include them in an array.\n   - Return only JSON, do not include any other information.\n   - Do not wrap JSON into ```json and ``` symbols \n\n4. Error Handling:\n   - If the AI fails to recognize the business card or cannot extract all fields, return an error message in the following format:\n     ```json\n     {\n       \"error\": \"Unable to process the business card. Reason: [error description].\"\n     }\n     ```\n   - Possible error descriptions:\n     - \"Image quality is too low.\"\n     - \"No recognizable text found.\"\n     - \"Fields missing or incomplete.\"\n\n5. Quality Assurance:\n   - If unsure about a field (e.g., ambiguous or incomplete text), note it in the output:\n     ```json\n     {\n       \"Name\": \"Uncertain\",\n       \"Email\": \"Uncertain\",\n       \"Phone\": \"+1 234 567 ???\",\n       \"Address\": \"Uncertain\"\n     }\n     ```\n6. Support multiple languages if cards are not always in English.\n</code></pre>"},{"location":"training/ai-powered-extraction-from-image.html#error-handling","title":"Error Handling","text":"<p>After receiving the response from the AI Assistant, the flow checks whether the assistant returned an error. The error check is done using the Condition block. The condition checks the <code>decision</code> property of the AI Assistant's response. If the property has the <code>error</code> key, the response is considered to contain an error:</p> <p></p>"},{"location":"training/ai-powered-extraction-from-image.html#saving-data-in-the-database","title":"Saving Data in the Database","text":"<ul> <li> <p>If no error is detected: The extracted contact details are saved in the Contacts database table, along with a link to the original image file.  </p> <p></p> </li> <li> <p>If an error occurs: The flow logs the error message in the Error column of the same database table. The link to the original file is also saved for reference.  </p> <p></p> </li> </ul>"},{"location":"training/ai-powered-extraction-from-image.html#using-the-flow","title":"Using the Flow","text":""},{"location":"training/ai-powered-extraction-from-image.html#running-the-flow","title":"Running the Flow","text":"<ol> <li> <p>Set Up FlowLogger:    Open FlowLogger and copy the session code. Click any of the Log... blocks and click the Configure button to enter the session code.</p> </li> <li> <p>Start the Flow:     Click the Start Flow button to change the flow's state to <code>LIVE</code>.</p> </li> <li> <p>Open the UI Page:    Navigate to the FlowManager screen and locate the Business Card Data Extraction with AI flow. The description column of the flow contains a link to open a UI page from where you can scan a business card and activate a flow instance. Use the provided UI page to test image uploads. This page should be configured to accept image files and send them to the flow's trigger.  </p> </li> </ol> <p>By understanding and implementing this flow, you\u2019ll learn how to leverage FlowRunner\u2019s powerful automation capabilities to create intelligent and scalable solutions tailored to real-world use cases.  </p>"},{"location":"training/basic-approval-flow.html","title":"Basic Approval Flow","text":"<p>The Basic Approval Flow demonstrates how FlowRunner\u2122 enables decision-based workflows. While this example focuses on handling time-off requests, the same principles can be adapted for other approval processes, such as expense approvals, project sign-offs, or purchase requests.</p> <p>This flow highlights the integration of reusable variables, database storage, email notifications, and trigger-based decision routing, offering a practical and flexible template for automating approvals.</p>"},{"location":"training/basic-approval-flow.html#overview","title":"Overview","text":"<p>The process begins when an employee submits a time-off request using a UI form. The form collects the employee\u2019s email address, the requested from and to dates, and a justification for the request. </p> <p></p> <p>Once submitted, the flow handles the request through several key steps:</p> <ol> <li>Saves the form data in a database.</li> <li>Sends an email to the manager with a link to a decision page.</li> <li>Waits for the manager to approve or reject the request.</li> <li>Routes the flow based on the decision and sends an appropriate email response to the employee.</li> </ol>"},{"location":"training/basic-approval-flow.html#flow-details","title":"Flow Details","text":""},{"location":"training/basic-approval-flow.html#setting-variables","title":"Setting Variables","text":"<p>The flow starts upon the UI form's submission. The first step in the flow execition is a Set Variables block, which initializes two reusable values:  </p> <ul> <li>Email Signature: A standardized signature appended to all emails sent from the flow.  </li> <li>Workspace Domain: The domain used for constructing URLs, such as the link to the manager's decision page.  </li> </ul> <p>This approach ensures consistency and simplifies updates if variable values change in the future.  </p> <p></p> <p>About Multiline Text Values</p> <p>The <code>Signature</code> element in the value for the <code>Email Signature</code> variable is an example of multiple-line text. To see how it is configured, click the input field that shows <code>Signature</code>, it will open the Expression Editor popup. Double click the <code>Signature</code> element in the Expression field. You will see the multiline text editor. </p> <p></p> <p>The Multiline Text element is available in the INPUTS section of Expression Editor:</p> <p></p>"},{"location":"training/basic-approval-flow.html#saving-in-the-database","title":"Saving in the Database","text":"<p>One of the critical steps in this flow is saving the submitted request data to the TimeOffRequest table in the database. The table stores:  </p> <ul> <li>The employee\u2019s email, dates, and justification.  Notice how the form fields are mapped to the table's columns. </li> <li>A unique identifier, <code>objectId</code>, automatically generated for each record.  </li> </ul> <p></p>"},{"location":"training/basic-approval-flow.html#notifying-the-manager","title":"Notifying the Manager","text":"<p>The flow uses the Send Message block (available as a part of Gmail extension in the Marketplace) to notify the manager of the time-off request. The body of the email message is composed using Expression Editor. The most important part from the implementation detail is a link to the \"Decision UI Page\". The link is dynamically constructed using the Workspace Domain variable and the <code>objectId</code> of the saved request.  </p> <p></p> <p>The <code>Workspace Domain</code> variable contains the domain name assigned to your workspace. You will find more information about it in the Setting Up the Flow section of this chapter. The value that comes after <code>Workspace Domain</code> references the page and tje <code>flowInstanceId</code> parameter: <pre><code>/index.html?page=request-approval&amp;flowInstanceId=\n</code></pre> The parameter value is determined dynamically using the <code>Execution ID</code> element. Following that in the EXPRESSION field is the <code>requestId</code> parameter. The value for that parameter is <code>objectId</code> from the record saved in the database.</p> <p>Why Use the Database?</p> <p>The decision page uses the <code>requestId</code> parameter to retrieve the request details dynamically from the database. This approach avoids passing large amounts of data directly through the URL. Instead, the page includes a query parameter, requestId, containing the <code>objectId</code> value.  </p> <p>For example, the link sent to the manager looks like this:  </p> <pre><code>https://&lt;workspace-domain&gt;//index.html?page=request-approval&amp;requestId=&lt;objectId&gt;\n</code></pre> <p>When the page loads, it queries the database using the <code>requestId</code> to fetch the relevant details. This design ensures: 1. Efficiency: The URL remains clean, with only the necessary identifier passed. 2. Security: Sensitive data is stored in the database and not exposed in the URL. 3. Scalability: The process can handle larger datasets without relying on direct data transmission.  </p>"},{"location":"training/basic-approval-flow.html#handling-manager-decisions","title":"Handling Manager Decisions","text":"<p>The decision page offers two options: Approve or Reject. </p> <p></p> <p>Each button in the UI triggers one of two App Logic Trigger blocks in the flow (to see these blocks, navigate into the Trigger Group block):  </p> <ul> <li>Request Approved: Activated when the manager clicks the Approve button.  </li> <li>Request Rejected: Activated when the manager clicks the Reject button.  </li> </ul> <p></p> <p>When you add an App Logic Trigger block to a flow, a Codeless block that can be used to activate the trigger is automatically created. The Codeless block can be used both in a UI page's logic and in custom Server Logic. You can find these blocks in the Automation Flows section in Codeless editor:</p> <p></p> <p>The logic behind the \"Approve\" and \"Reject\" buttons uses these Codeless blocks. For example, below is the logic for the <code>On Click Event</code> of the \"Approve\" button: </p> <p></p> <p>To ensure the button click activates a trigger in a specific flow, the \"Run App Logic Trigger\" Codeless blocks use the Execution ID parameter. This parameter, included in the decision page URL as <code>flowInstanceId</code>, links the UI action to the specific instance of the flow processing the request. This is important because every flow instance operates on data for a specific timeoff request. </p> <p>For the rejection case, the Run App Logic Trigger Codeless block also receives a <code>Body</code> object containing the rejection reason entered by the manager on the decision page.  </p> <p></p> <p>Both decision triggers in the flow are part of a Trigger Group block, which ensures the flow proceeds as soon as one of the triggers is activated (see the Outgoing Transition Mode):  </p> <p></p>"},{"location":"training/basic-approval-flow.html#routing-with-the-value-router","title":"Routing with the Value Router","text":"<p>When one of the triggers in the Trigger Group is activated, the group\u2019s result contains a <code>source</code> property that identifies the activated trigger. This property determines how the flow routes to the next step.  </p> <p>The flow uses a Value Router block to evaluate the <code>source</code> property and route the flow accordingly. The Value Router is configured to recognize the following expected values:  </p> <ul> <li>Request Approved: Corresponds to the trigger activated when the manager approves the request.  </li> <li>Request Rejected: Corresponds to the trigger activated when the manager rejects the request.  </li> </ul> <p>For each value, the block defines a label (called \"Case\") to match the branch routing. The connectors on the block lead to the appropriate actions:  </p> <ul> <li>If the <code>source</code> value is Request Approved, the flow follows the \"Approved\" branch and sends a confirmation email to the employee.  </li> <li>If the <code>source</code> value is Request Rejected, the flow follows the \"Rejected\" branch. It sends an email to the employee including the rejection reason provided by the manager.  </li> </ul> <p>Here\u2019s how the Value Router block\u2019s configuration looks:  </p> <p> </p>"},{"location":"training/basic-approval-flow.html#setting-up-the-flow","title":"Setting Up the Flow","text":"<ol> <li> <p>Authorize Email Integration    Open one of the Send Message blocks (labeled Send Request and Send Decision) in the flow. Click Login to establish an OAuth connection with your Google account. This step allows FlowRunner\u2122 to send emails on your behalf.  </p> </li> <li> <p>Set the <code>Workspace Domain</code> Variable    To ensure the email sent to the manager contains the correct URL, you need to configure the domain name assigned to your workspace.  </p> <ul> <li> <p>Click the Manage icon in the upper-left corner of the console:  </p> <p> </p> </li> <li> <p>Scroll down to the App ID and API Keys section and copy the Backendless subdomain value.  </p> </li> <li> <p>Navigate back to FlowRunner\u2122 and open the Basic Approval Flow. Select the Set Variables block. Paste the copied subdomain value into the Value field for the <code>Workspace Domain</code> variable. Ensure the value starts with <code>https://</code>.  </p> </li> </ul> </li> <li> <p>Set the Manager's Email Address    In the Send Request block, enter the manager\u2019s email address in the To field. This is where the email containing the Approve/Reject decision link will be sent.  </p> </li> <li> <p>Configure Logging </p> <ul> <li>Select the Log Message block in the flow and click the Configure button.  </li> <li>Open FlowLogger in a separate browser window. Copy the session code displayed in the FlowLogger window.  </li> <li>Paste the session code into the popup in FlowRunner\u2122 and save the configuration.  </li> </ul> </li> </ol>"},{"location":"training/basic-approval-flow.html#running-the-flow","title":"Running the Flow","text":"<p>Click the Start Flow button to run the flow. Return to the Flow Manager screen. Click the link in the Description column of Basic Approval Flow. This will open the time-off request UI form which when submitted will create a new flow instance.</p>"},{"location":"training/basic-approval-flow.html#key-learning-points","title":"Key Learning Points","text":"<p>This flow introduces several foundational concepts in FlowRunner\u2122: - Database Integration: Learn how to store and retrieve data efficiently using FlowRunner\u2019s database features. - Dynamic URLs: Understand how query parameters like <code>requestId</code> and <code>flowInstanceId</code> enable secure and dynamic interactions between the flow and UI. - Trigger-Based Decisions: Explore how App Logic Triggers and the Trigger Group block coordinate decision handling. - Value-Based Routing: See how the Value Router block evaluates properties to direct flow execution based on specific conditions.  </p>"},{"location":"training/customer-satisfaction-surver-flow.html","title":"Customer Satisfaction Survey","text":"<p>The Customer Satisfaction Survey Flow is an interactive demonstration of how FlowRunner\u2122 processes external data submissions, validates input, and dynamically routes logic to automate communications. By working through this flow, you\u2019ll learn how to integrate external systems (such as Google Forms) with FlowRunner\u2122 and explore core concepts like validation, database interactions, and conditional logic.  </p> <p></p>"},{"location":"training/customer-satisfaction-surver-flow.html#user-experience","title":"User Experience","text":"<p>This flow begins with a user filling out a Google Form, which collects the following details:  Name, Email, Satisfaction Rating, and Feedback. Upon form submission, the flow validates the input, saves it to a database, and sends a tailored email based on the satisfaction rating provided by the user.  </p> <p></p>"},{"location":"training/customer-satisfaction-surver-flow.html#flow-implementation","title":"Flow Implementation","text":""},{"location":"training/customer-satisfaction-surver-flow.html#receiving-and-validating-data","title":"Receiving and Validating Data","text":"<p>The Form Submitted block receives the data submitted from the Google Form. The flow then validates the data using the Is Form Data Valid condition block, ensuring that the required fields (Name, Email, and Feedback) are present and not empty. Below is the configuration panel for the condition block. Notice how the entire condition consists of three parts - <code>A</code>, <code>B</code>, and <code>C</code>. </p> <p></p> <p>The entire logical expression of the condition is shown at the bottom of the screen in the screenshot above. The <code>AND</code> operators are clickable to change between <code>AND</code> and <code>OR</code>. The individual parts can be dragged to place elsewhere in the condition expression. Finally, you can place round brackets around parts of the expression to prioritize its evaluation.</p> <p></p> <p>If the condition evaluates to <code>false</code>, the flow proceeds down the No branch. In that case, the flow logs an error message to FlowLogger and notifies the admin via email. Otherwise, the flow continues through the <code>Yes</code> branch.</p>"},{"location":"training/customer-satisfaction-surver-flow.html#assigning-instance-name","title":"Assigning Instance Name","text":"<p>Each form submission initiates a new instance of the flow, and every instance maintains its own unique context to manage the data it operates on. This design is a core architectural feature of FlowRunner\u2122, ensuring proper sandboxing to keep data isolated between different automation \"runs.\"</p> <p>To make it easier to identify individual flow instances in the analytics interface, you can assign a descriptive name to each instance. This name can be dynamically generated using any data the flow processes. For example, in this sample flow, the instance name is assigned as the user's email address. Choosing meaningful names enhances traceability and helps you quickly understand the purpose or origin of each instance.</p> <p></p>"},{"location":"training/customer-satisfaction-surver-flow.html#saving-data-to-the-database","title":"Saving Data to the Database","text":"<p>The flow uses the Save Record in Database block, labeled as Save Form Data in Database, to persist the data in the table. Each field from the form is mapped to a corresponding column in the database. The <code>Property</code> drop-downs are populated dynamically with the names of the columns from the selected table.</p> <p></p> <p>Note</p> <p>To inspect the database, its structure/schema and the data it stores, click the <code>QUICK ACCESS</code> button in the top-left corner and navigate to Backendless Database. You will find the CustomerSatisfactionSurveyFlow table. Click the table to select it. The DATA BROWSER tab will display the table data. To see the table structure/schema, click the SCHEMA tab.</p>"},{"location":"training/customer-satisfaction-surver-flow.html#sending-follow-up-emails","title":"Sending Follow-Up Emails","text":"<p>The primary goal of this flow is to send a personalized follow-up email based on the user\u2019s satisfaction rating. Each email serves a specific purpose:  </p> <ul> <li>Highly Satisfied (9 or above): Thank the user for their feedback and encourage them to share a testimonial.  </li> <li>Neutral (6 to 8): Request suggestions for improvement to better meet user needs.  </li> <li>Not Satisfied (5 or below): Apologize and invite the user to provide additional feedback.  </li> </ul> <p></p>"},{"location":"training/customer-satisfaction-surver-flow.html#evaluating-satisfaction-rating","title":"Evaluating Satisfaction Rating","text":"<p>To determine which email to send, the flow evaluates the satisfaction rating submitted through the Google Form. However, since Google Forms submits the rating as a string, the flow cannot directly compare it to numeric thresholds.  </p> <p>To address this, the flow uses a Transform Data block to convert the satisfaction rating from a string to a numeric value. The transformed value, referred to as Satisfaction as a Number, ensures that subsequent condition blocks can properly evaluate the rating.  </p> <p></p>"},{"location":"training/customer-satisfaction-surver-flow.html#using-conditional-logic","title":"Using Conditional Logic","text":"<p>With the numeric satisfaction value ready, the flow uses two condition blocks to route the logic:  </p> <ol> <li> <p>The first condition checks if the satisfaction rating is 5 or below. If true, the flow sends the \"Not Satisfied\" email.  </p> <p></p> </li> <li> <p>If the first condition is false, the flow proceeds to the second condition, which checks if the rating is 9 or above. If true, the flow sends the \"Highly Satisfied\" email.  </p> <p></p> </li> <li> <p>If neither condition is true, the flow defaults to sending the \"Neutral\" email.  </p> </li> </ol> <p>By structuring the flow in this way, every user receives a follow-up message that reflects their feedback, enhancing the user experience and maintaining effective communication.  </p>"},{"location":"training/customer-satisfaction-surver-flow.html#preparing-to-run-the-flow","title":"Preparing to Run the Flow","text":"<ol> <li> <p>Set Up FlowLogger - Open FlowLogger and copy the session code. Click the Log Error block and click the Configure button to enter the session code.  </p> </li> <li> <p>Authenticate Gmail Integration - Click the Send Email to Admin block. Click Login to authenticate with your Google account, allowing the flow to send emails. Select the created OAuth connection for all other email follow-up blocks (click the block and select the connection in the OAuth Connection section).</p> </li> <li> <p>Set Up the Google Form - To start working with this flow, we\u2019ve prepared a Google Form for testing purposes. This shared form requires you to supply your flow\u2019s callback URL, as the URL is unique for each user. Follow these steps to link the form to your flow:  </p> <ol> <li> <p>Get Your Flow\u2019s Callback URL   Open the Form Submitted block in the Flow Editor, which is an External Callback. Copy the Callback URL from its properties.  </p> </li> <li> <p>Paste the URL in the Google Form   Use the provided Google Form and paste your Callback URL in the first field. This ensures the form sends data to your flow.  </p> </li> </ol> <p>Alternatively, you can recreate the form specifically for your flow by following the steps below.  </p> </li> </ol>"},{"location":"training/customer-satisfaction-surver-flow.html#running-the-flow","title":"Running the Flow","text":"<p>Submit the Google Form or your custom form. Monitor the flow\u2019s execution in FlowLogger to observe data validation, database operations, and email delivery.  </p>"},{"location":"training/customer-satisfaction-surver-flow.html#set-up-your-own-google-form","title":"Set Up Your Own Google Form","text":"<ol> <li> <p>Create the Form    Navigate to Google Forms and create a new form. Add the following fields:  </p> <ul> <li>Name (Short Answer)  </li> <li>Email (Short Answer)  </li> <li>Satisfaction (Linear Scale, 1 to 10, labeled \"Dissatisfied\" to \"Highly Satisfied\")  </li> <li>Feedback (Paragraph)  </li> </ul> </li> <li> <p>Access the Script Editor    In the form, click the three-dot menu in the top-right corner, then select Script Editor.  </p> </li> <li> <p>Add a Script to Submit Data to FlowRunner\u2122    Replace any default code in the Apps Script editor with the following script:  </p> <pre><code>function onFormSubmit(e) { \n var url = \"YOUR_EXTERNAL_CALLBACK_URL_HERE\"; // Replace with your target URL \n var formResponse = e.response; // Extract answers from the form response \n var itemResponses = formResponse.getItemResponses(); \n var data = {}; \n for (var i = 0; i &lt; itemResponses.length; i++) { \n     var itemResponse = itemResponses[i]; \n     data[itemResponse.getItem().getTitle()] = itemResponse.getResponse(); \n } \n // Send data as POST request \n var options = { \n     method: \"post\", \n     contentType: \"application/json\", \n     payload: JSON.stringify(data) \n }; \n UrlFetchApp.fetch(url, options); \n}\n</code></pre> <p>Replace <code>YOUR_EXTERNAL_CALLBACK_URL_HERE</code> with the Callback URL copied from the Form Submitted block.  </p> </li> <li> <p>Set Up the Trigger    In the Script Editor:  </p> <ul> <li>Open the Triggers menu (clock icon or via Extensions &gt; Apps Script &gt; Triggers).  </li> <li>Add a new trigger for the <code>onFormSubmit</code> function.  </li> <li>Set the event type to On form submit and save.  </li> </ul> </li> <li> <p>Grant Permissions    When saving the trigger, Google will prompt you to authorize the script. Review the permissions, select your Google account, and allow the required access.  </p> <p>Once completed, your custom form is ready to submit data to the flow.  </p> </li> </ol> <p>This flow serves as a practical, hands-on example of integrating external tools, managing data, and automating responses with FlowRunner\u2122. By following the steps above, you\u2019ll gain a deep understanding of how to build reliable, efficient workflows.  </p>"},{"location":"training/daily-reminder-email.html","title":"Daily Reminder Email Flow","text":"<p>The Daily Reminder Email Flow automates task notifications by retrieving due and incomplete tasks from a database and sending personalized reminder emails to the responsible parties. This flow provides an excellent opportunity to explore foundational FlowRunner\u2122 features, helping you design practical and efficient automations.  </p>"},{"location":"training/daily-reminder-email.html#what-you-will-learn","title":"What You Will Learn","text":"<p>By working through this flow, you\u2019ll gain hands-on experience with several key FlowRunner\u2122 capabilities:  </p> <ul> <li>Querying a Database: Learn how to fetch records dynamically based on specific conditions like task deadlines and completion status.  </li> <li>Implementing Loops: Understand how to process collections iteratively using the Repeat block.  </li> <li>Transforming Data: Discover how to manipulate and format data for readability or further processing.  </li> <li>Sending Dynamic Emails: Explore how to automate email notifications using Gmail integration, with content tailored to database records.  </li> </ul> <p>These skills are essential for solving real-world problems with FlowRunner\u2122.  </p>"},{"location":"training/daily-reminder-email.html#how-the-flow-works","title":"How the Flow Works","text":"<ol> <li> <p>The flow starts with a database query using the Find Record(s) in Database block. This block retrieves task records from the Tasks table, filtering for tasks that are due today and not marked as done. Notice how the Where Clause parameter is structured. It uses the <code>Current Time</code> element from the Expression Editor to create a dynamic query. When the block runs according to the daily execution schedule, the query will always fetch the tasks with the <code>Due</code> date less or equal the current time. The result of the block (referenced as <code>Tasks List</code>) is a collection of task records, which serves as input for subsequent operations.(1)</p> <ol> <li> Try running the block in Test Mode to see how the result of the block is structured.</li> </ol> <p></p> </li> <li> <p>After the query, the flow calculates the number of tasks in the query result using a Transform Data block. This step provides a numeric value, referred to as Task Count, which determines how many iterations the flow will run in the next step.  The block uses the <code>Get List Length</code> operation. The operation's argument is the result of the database query block.</p> <p></p> </li> <li> <p>The Repeat block then iterates over the list of tasks. The loop runs once for each task in the collection, and during each iteration, the flow executes a predefined sequence of operations. The Repeat block has Condition which controls when the iteration over the list of tasks stops. While the condition evaluates to <code>true</code>, the iteration continues. The <code>Current Iteration Number</code> element is special, it is available in all Repeat blocks. The element has a number that is incremented by 1 for every new iteration. </p> <p></p> <p>The Repeat Condition</p> <p>The condition shown above works well for a loop that iterates over a list of values. The loop continues while the <code>Current Iteration Number</code> is less than the size of the list (represented by the <code>Tasks Count</code> element). </p> </li> <li> <p>Inside the Repeat block:  </p> <p></p> <ul> <li> <p>A Transform Data block retrieves the current task based on the iteration number. This task is stored as a value called Task, which is used in subsequent steps.  </p> <p></p> </li> <li> <p>Another Transform Data block formats the task's due date into a user-friendly format, such as <code>MM/dd/yyyy hh:mm a</code>. This formatted date is used in the email body.  </p> <p></p> </li> <li> <p>The Send Email block uses the Gmail integration extension to send a reminder email. The email is dynamically composed using the task details, including the formatted due date and the responsible party's email address.  </p> <p></p> </li> </ul> </li> <li> <p>The process repeats for every task in the collection until all tasks have been processed.  </p> </li> </ol>"},{"location":"training/daily-reminder-email.html#preparing-to-run-the-flow","title":"Preparing to Run the Flow","text":"<p>Before running the flow, you need to configure two key elements. First, set up Gmail integration. Open the Send Email block inside the Repeat block and click the Login button. Authenticate with your Google account to allow the flow to send emails on your behalf.  </p> <p>Next, create some tasks for testing. To do this, open the Flow Manager screen and click the link in the description of the Daily Reminder Email flow:</p> <p></p> <p>Click the \"Desktop Preview\" icon  to run the page in a browser. </p> <p></p> <p>The page connects to the same Tasks database table used by the flow. Create a few tasks with the following conditions:  </p> <ul> <li>The Due Date is set to today.  </li> <li>The Responsible Party field contains a valid email address.  </li> </ul> <p>These tasks will be included in the flow's query and used for sending reminder emails.  </p>"},{"location":"training/daily-reminder-email.html#running-the-flow","title":"Running the Flow","text":"<p>To start the flow, either click the Start Flow button in the Flow Editor or use the \"Run the Flow\" button on the demo webpage. Once triggered, the flow will query the database, process the tasks, and send emails to the designated recipients.  </p> <p>After the flow completes, verify the results by checking the inboxes of the responsible parties for the reminder emails.  </p>"},{"location":"training/sample-error-handling.html","title":"Sample Error Handling Flow","text":"<p>The Sample Error Handling Flow demonstrates how to implement error handling in FlowRunner\u2122. It is a comprehensive example showcasing how to log progress and errors using FlowLogger, handle errors gracefully with <code>Handle Error</code> blocks, and process data through conditional logic. This flow is ideal for understanding how to build robust workflows that can recover from unexpected issues.  </p>"},{"location":"training/sample-error-handling.html#how-the-flow-works","title":"How the Flow Works","text":"<p>The flow starts with an External Callback trigger (labeled as Data For New Task). This trigger is activated when its unique endpoint URL is invoked. </p> <p></p> <p>The flow expects four parameters in the URL:  </p> <ul> <li>Description: A brief description of the task.  </li> <li>Done: A boolean value indicating whether the task is completed.  </li> <li>Due: A timestamp for the task's due date.  </li> <li>Responsible User Email: The email address of the person responsible for the task.  </li> </ul> <p>Once activated, the trigger passes the parameters into the flow. The first action logs the incoming data to FlowLogger for transparency and debugging.  </p> <p></p> <p>After logging the input, the flow saves the task details into the Tasks database table. This table has columns corresponding to the provided parameters. If the save operation is successful, a success message is logged to FlowLogger, otherwise, if there is an error with saving the data in the database, the flow is routed to the Create Task Error block, which is an error handler. The flow then logs the error in FlowLogger.</p> <p></p> <p>Next, the flow sends a notification email to the email address specified in the <code>Responsible User Email</code> parameter. This email informs the user that a new task has been created in the database. The flow logs a message upon successful email delivery.  </p> <p></p> <p>Finally, the flow updates the database record for the task, marking it as having sent the notification email.  </p>"},{"location":"training/sample-error-handling.html#error-handling","title":"Error Handling","text":"<p>The flow is designed to handle errors at critical points, specifically during the database save and email sending tasks. If either task fails, the associated <code>Handle Error</code> block redirects the flow to a logging action. This action sends the error details to FlowLogger, ensuring you have the information needed to diagnose and fix the issue.  </p>"},{"location":"training/sample-error-handling.html#execution-prerequisites","title":"Execution Prerequisites","text":"<p>Before running the flow, ensure you have completed the following setup steps:  </p> <ol> <li> <p>Configure FlowLogger    Open FlowLogger in a separate browser window. Note the session code displayed on the screen. In the Flow Editor, select any Log... block, click the Configure button in the properties panel, and enter the session code. Save your changes to link the block to FlowLogger.  </p> </li> <li> <p>Set Up Gmail Integration    Select the Send User Notification block in the flow. Click the Login button in the properties panel and follow the prompts to log in with your Google credentials. This step authorizes the flow to send emails using your Gmail account.  </p> </li> </ol>"},{"location":"training/sample-error-handling.html#running-the-flow","title":"Running the Flow","text":"<p>To start the flow, click the Start Flow icon in the Flow Editor. The flow begins when its External Callback trigger (labeled as Data For New Task) is activated.  </p>"},{"location":"training/sample-error-handling.html#accessing-the-trigger-url","title":"Accessing the Trigger URL","text":"<p>You can get the trigger URL in two ways:  </p> <ul> <li>Select the Data For New Task block in the Flow Editor and find the URL there.  </li> <li>Alternatively, open the flow version description in the Flow Manager, where the full URL is listed.  </li> </ul> <p>The complete URL includes placeholders for all required parameters:  </p> <pre><code>https://[YOUR APP HOSTNAME]\n    /api/automation/flow/C4C5E4E4-E412-4CBC-8758-24E5AF547FBB/trigger/B66A837A-2C9C-87CE-45D5-10A4A66EEC46/activate?\n    Description=CreatedByFlowRunner\u2122Trigger&amp;\n    Done=false&amp;\n    Due=1732140000000&amp;\n    Responsible%20User%20Email=youremailexample@gmail.com\n</code></pre>"},{"location":"training/sample-error-handling.html#running-the-flow_1","title":"Running the Flow","text":"<p>Copy the URL into your browser and replace <code>[YOUR APP HOSTNAME]</code> with the appropriate hostname for your Backendless app. Ensure all required parameters are included. When the URL is executed correctly, the flow will:  </p> <ol> <li>Log the incoming parameters.  </li> <li>Save the task to the database.  </li> <li>Send a notification email to the specified user.  </li> <li>Update the task record to indicate the notification was sent.  </li> </ol> <p>If any parameters are missing or invalid, the flow triggers an error. For example, try the following scenarios and observe how the flow handles the errors:</p> <ul> <li>Omit the value for the <code>Responsible User Email</code> parameter or providing a poorly formatted email address</li> <li>Specify an invalid date value for the  <code>Due</code> argument. (for example, <code>abc</code>)</li> <li>Specify a wrong parameter name. (for example, <code>Responsible User Email1</code>)</li> </ul>"},{"location":"training/welcome-email.html","title":"Welcome Email Flow","text":"<p>The Welcome Email Flow is a straightforward yet effective example of automation in FlowRunner\u2122. It demonstrates how to automatically send personalized emails to new users when they register in your application. This flow incorporates user role detection, conditional logic, and email delivery, showcasing essential FlowRunner\u2122 capabilities.  </p>"},{"location":"training/welcome-email.html#how-the-flow-works","title":"How the Flow Works","text":"<p>When a new user registers in the application, the flow is triggered by the User Registered block. This block detects user registrations and provides user details from the registration form. These include user's <code>email</code> and the <code>objectId</code>. </p> <p></p> <p>To demonstrate the flow, a sample web page is provided where users can register through a form. Once the trigger activates, the flow passes the user\u2019s <code>objectId</code> to a Get User Roles custom action. This block uses Backendless APIs to retrieve all roles assigned to the user. </p> <p>Note</p> <p>If you are interested to find out how the custom action is implemented, navigate to the API Services section of the Backendless Console. (Click <code>QUICK ACCESS</code> &gt; Select <code>API Services</code> -&gt; Locate the <code>Users</code> service and explore the <code>getUserRoles</code> method)</p> <p>The data returned by the custom action, a list of JSON objects, is stored as <code>Registered User Roles</code>.  </p> <p></p> <p>The flow then evaluates the retrieved roles using the Is Admin condition block. To understand how the condition works, it is important to know the format of the JSON data processed by the block. The JSON data is a value returned by the Get User Roles block and it looks like this: <pre><code>[\n    {\n        \"system\": true,\n        \"roleId\": \"67EC9EA5-C29B-44D4-B2B4-28DA66C39939\",\n        \"name\": \"AuthenticatedUser\"\n    },\n    {\n        \"system\": false,\n        \"roleId\": \"112F0F74-93F0-40B8-AEDC-B9E737CF17CB\",\n        \"name\": \"Admin\"\n    }\n]\n</code></pre></p> <p>The Is Admin block checks if any of the roles in the JSON array has the key <code>name</code> with the value <code>Admin</code>. </p> <p></p> <p>If the condition is true, the flow sends a welcome email addressed to an admin user. If the condition is false, a different email is sent to welcome a regular user.  </p> <p>To send these emails, the flow uses Gmail integration for authentication and delivery. Before running the flow, you must configure the Gmail blocks by logging in and creating an OAuth connection. </p> <p></p> <p>The email content, including the recipient, subject, and body, is dynamically populated based on the user's role.  </p>"},{"location":"training/welcome-email.html#running-the-flow","title":"Running the Flow","text":"<p>You can test this flow using the provided web page. The web page is built in UI Builder and you are welcome to modify it to fit your scenario. The page includes a registration form where you can specify user details and assign a role (either \"Admin\" or \"None\"). Submitting the form triggers the flow.  </p> <p></p> <p>To access this page, navigate to UI Builder in the Backendless Console and locate the RegisterUserWithRole page. You can preview and run the page directly from the UI Builder or follow the link provided in the flow version description.  </p> <p>To enable the flow, go to the Flow Manager in FlowRunner\u2122 (this is the main FlowRunner\u2122 screen with a list of flows) and click the Start Flow icon. Once activated, the flow will monitor for user registrations and send the appropriate welcome email based on the user\u2019s role.  </p> <p>This flow is an excellent starting point for learning FlowRunner\u2122 basics, including triggers, conditions, and email integration. It also highlights how Backendless APIs and custom actions can work together to create dynamic, role-specific automations.  </p>"}]}